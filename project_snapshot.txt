
--- START OF FILE app/components/auth/LoginModal.jsx ---
import React, { useState, useEffect } from 'react';
import { Modal, View, Text, TextInput, TouchableOpacity, Alert, StyleSheet, KeyboardAvoidingView, Platform } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import { MaterialIcons } from '@expo/vector-icons';

const LoginModal = ({ visible, onClose, onLoginSuccess }) => {
    const [userId, setUserId] = useState('');
    const [pin, setPin] = useState('');
    const [userClass, setUserClass] = useState('');

    useEffect(() => {
        const loadCredentials = async () => {
            if (visible) {
                const storedUserId = await SecureStore.getItemAsync('userId');
                const storedPin = await SecureStore.getItemAsync('pin');
                const storedClass = await SecureStore.getItemAsync('userClass');
                if (storedUserId) setUserId(storedUserId);
                if (storedPin) setPin(storedPin);
                if (storedClass) setUserClass(storedClass);
            }
        };
        loadCredentials();
    }, [visible]);

    const handleLogin = async () => {
        if (!userId.trim() || !pin.trim() || !userClass.trim()) {
            Alert.alert('Incomplete Information', 'Please fill in all fields: User ID, PIN, and Class.');
            return;
        }
        try {
            await SecureStore.setItemAsync('userId', userId.trim());
            await SecureStore.setItemAsync('pin', pin.trim());
            await SecureStore.setItemAsync('userClass', userClass.trim());
            if (onLoginSuccess) {
                onLoginSuccess({
                    userId: userId.trim(),
                    pin: pin.trim(),
                    userClass: userClass.trim()
                });
            }
            onClose();
        } catch (error) {
            Alert.alert('Error', 'Failed to save your credentials. Please try again.');
        }
    };

    return (
        <Modal
            visible={visible}
            transparent={true}
            animationType="slide"
            onRequestClose={onClose}
        >
            <KeyboardAvoidingView
                behavior={Platform.OS === "ios" ? "padding" : "height"}
                style={styles.modalOverlay}
            >
                <View style={styles.modalContent}>
                    <View style={styles.header}>
                        <MaterialIcons name="person" size={24} color="#4F46E5" />
                        <Text style={styles.title}>User Information</Text>
                    </View>
                    <Text style={styles.subtitle}>
                        This information is required to save and sync your contributions.
                    </Text>

                    <TextInput
                        style={styles.input}
                        placeholder="User ID (e.g., your name)"
                        placeholderTextColor="#9ca3af"
                        value={userId}
                        onChangeText={setUserId}
                        autoCapitalize="none"
                    />
                    <TextInput
                        style={styles.input}
                        placeholder="PIN (4-6 digits)"
                        placeholderTextColor="#9ca3af"
                        value={pin}
                        onChangeText={setPin}
                        keyboardType="number-pad"
                        secureTextEntry
                        maxLength={6}
                    />
                    <TextInput
                        style={styles.input}
                        placeholder="Class (e.g., S4-DS)"
                        placeholderTextColor="#9ca3af"
                        value={userClass}
                        onChangeText={setUserClass}
                        autoCapitalize="characters"
                    />

                    <View style={styles.buttonContainer}>
                        <TouchableOpacity style={styles.closeButton} onPress={onClose}>
                            <Text style={styles.closeButtonText}>Cancel</Text>
                        </TouchableOpacity>
                        <TouchableOpacity style={styles.saveButton} onPress={handleLogin}>
                            <Text style={styles.saveButtonText}>Save & Continue</Text>
                        </TouchableOpacity>
                    </View>
                </View>
            </KeyboardAvoidingView>
        </Modal>
    );
};

const styles = StyleSheet.create({
    modalOverlay: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
        width: '90%',
        backgroundColor: 'white',
        borderRadius: 12,
        padding: 24,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.25,
        shadowRadius: 4,
        elevation: 5,
    },
    header: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 8,
    },
    title: {
        fontSize: 20,
        fontWeight: 'bold',
        color: '#1f2937',
        marginLeft: 8,
    },
    subtitle: {
        fontSize: 14,
        color: '#4b5563',
        marginBottom: 20,
    },
    input: {
        height: 50,
        borderColor: '#d1d5db',
        borderWidth: 1,
        borderRadius: 8,
        paddingHorizontal: 16,
        marginBottom: 16,
        fontSize: 16,
        backgroundColor: '#f9fafb',
    },
    buttonContainer: {
        flexDirection: 'row',
        justifyContent: 'flex-end',
        marginTop: 10,
    },
    closeButton: {
        paddingVertical: 12,
        paddingHorizontal: 20,
        borderRadius: 8,
        marginRight: 10,
    },
    closeButtonText: {
        color: '#4b5563',
        fontSize: 16,
        fontWeight: '500',
    },
    saveButton: {
        backgroundColor: '#4F46E5',
        paddingVertical: 12,
        paddingHorizontal: 20,
        borderRadius: 8,
    },
    saveButtonText: {
        color: 'white',
        fontSize: 16,
        fontWeight: 'bold',
    },
});

export default LoginModal;
--- END OF FILE app/components/auth/LoginModal.jsx ---

--- START OF FILE app/components/notes/ChannelModal.jsx ---
import React from 'react';
import { Modal, View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const ChannelModal = ({ visible, onClose, channels, onSelectChannel, onDeleteChannel }) => {
  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onClose}>
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <Text style={styles.title}>Select Channel</Text>
          
          <TouchableOpacity
            style={styles.channelItem}
            onPress={() => onSelectChannel('default')}
          >
            <Text style={styles.channelName}>Default (Original)</Text>
          </TouchableOpacity>

          {channels.map(channel => (
            <View key={channel.id} style={styles.channelItem}>
              <TouchableOpacity
                onPress={() => onSelectChannel(channel.id)}
                style={styles.channelTouchable}
              >
                <Text style={styles.channelName}>{channel.name} ({channel.type})</Text>
              </TouchableOpacity>
              {channel.canDelete && (
                <TouchableOpacity
                  style={styles.deleteButton}
                  onPress={() => onDeleteChannel(channel.id)}
                >
                  <Ionicons name="trash" size={20} color="#ef4444" />
                </TouchableOpacity>
              )}
            </View>
          ))}
          
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Text style={styles.closeButtonText}>Close</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    width: '85%',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
    color: '#1f2937',
  },
  channelItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e5e7eb',
  },
  channelTouchable: {
    flex: 1,
  },
  channelName: {
    fontSize: 16,
    color: '#374151',
  },
  deleteButton: {
    padding: 8,
  },
  closeButton: {
    marginTop: 20,
    backgroundColor: '#e5e7eb',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center',
  },
  closeButtonText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#374151',
  },
});

export default ChannelModal;
--- END OF FILE app/components/notes/ChannelModal.jsx ---

--- START OF FILE app/components/notes/UploadModal.jsx ---
import React, { useState } from 'react';
import { Modal, View, Text, Switch, TouchableOpacity, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const UploadModal = ({ visible, onClose, onUpload, userId }) => {
  const [isPublic, setIsPublic] = useState(true);

  const handleUploadPress = () => {
    onUpload(isPublic);
  };

  return (
    <Modal visible={visible} transparent animationType="slide" onRequestClose={onClose}>
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <Text style={styles.title}>Upload Note</Text>
          <Text style={styles.userInfo}>Uploading as: {userId}</Text>
          
          <View style={styles.switchContainer}>
            <Text style={styles.switchLabel}>Make Publicly Visible</Text>
            <Switch
              trackColor={{ false: "#767577", true: "#81b0ff" }}
              thumbColor={isPublic ? "#4f46e5" : "#f4f3f4"}
              onValueChange={setIsPublic}
              value={isPublic}
            />
          </View>
          
          <View style={styles.buttonContainer}>
            <TouchableOpacity style={styles.cancelButton} onPress={onClose}>
              <Text style={styles.buttonText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.uploadButton} onPress={handleUploadPress}>
              <Ionicons name="cloud-upload" size={20} color="white" />
              <Text style={styles.uploadButtonText}>Upload</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    width: '85%',
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#1f2937',
  },
  userInfo: {
    fontSize: 14,
    color: '#6b7280',
    marginBottom: 16,
  },
  switchContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 12,
    marginBottom: 20,
  },
  switchLabel: {
    fontSize: 16,
    color: '#374151',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 10,
  },
  cancelButton: {
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
    backgroundColor: '#e5e7eb',
  },
  uploadButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 20,
    borderRadius: 8,
    backgroundColor: '#4f46e5',
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '500',
    color: '#374151',
  },
  uploadButtonText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: 'white',
    marginLeft: 8,
  },
});

export default UploadModal;
--- END OF FILE app/components/notes/UploadModal.jsx ---

--- START OF FILE app/components/progress/UploadSyllabusDialog.jsx ---
import React, { useState, useEffect } from 'react';
import { Modal, View, Text, TextInput, TouchableOpacity, Alert, StyleSheet, ActivityIndicator, ScrollView } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import { getDatabase, ref, set } from 'firebase/database';
import Toast from 'react-native-toast-message';

import LoginModal from '../auth/LoginModal';

const UploadSyllabusDialog = ({ visible, onClose, firebaseApp }) => {
    const [userInfo, setUserInfo] = useState(null);
    const [isLoginModalVisible, setLoginModalVisible] = useState(false);
    const [syllabusName, setSyllabusName] = useState('');
    const [syllabusContent, setSyllabusContent] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    useEffect(() => {
        const checkUser = async () => {
            if (visible) {
                const userId = await SecureStore.getItemAsync('userId');
                const pin = await SecureStore.getItemAsync('pin');
                const userClass = await SecureStore.getItemAsync('userClass');
                if (userId && pin && userClass) {
                    setUserInfo({ userId, pin, userClass });
                } else {
                    setUserInfo(null);
                }
            }
        };
        checkUser();
    }, [visible]);

    const handleUpload = async () => {
        if (!userInfo) {
            setLoginModalVisible(true);
            return;
        }

        if (!syllabusName.trim() || !syllabusContent.trim()) {
            Alert.alert('Incomplete', 'Please provide a name and JSON content for the syllabus.');
            return;
        }

        let parsedContent;
        try {
            parsedContent = JSON.parse(syllabusContent);
            if (!Array.isArray(parsedContent)) throw new Error("JSON must be an array.");
        } catch (error) {
            Alert.alert('Invalid JSON', `The provided content is not valid JSON. ${error.message}`);
            return;
        }

        setIsLoading(true);
        try {
            const db = getDatabase(firebaseApp);
            const sanitizedSyllabusName = syllabusName.trim().replace(/[^a-zA-Z0-9-]/g, '_');
            const syllabusRef = ref(db, `syllabi/${userInfo.userId}/${sanitizedSyllabusName}`);

            const dataToUpload = {
                content: parsedContent,
                metadata: {
                    uploader: userInfo.userId,
                    class: userInfo.userClass,
                    timestamp: Date.now(),
                    originalName: syllabusName.trim(),
                },
            };

            await set(syllabusRef, dataToUpload);

            Toast.show({
                type: 'success',
                text1: 'Upload Successful',
                text2: `Syllabus '${syllabusName.trim()}' has been saved.`
            });
            onClose(); // Close the main dialog on success
        } catch (error) {
            console.error("Syllabus upload error:", error);
            Alert.alert('Upload Failed', 'Could not save the syllabus to the database. Please try again.');
        } finally {
            setIsLoading(false);
        }
    };

    const onLoginSuccess = (credentials) => {
        setUserInfo(credentials);
        setLoginModalVisible(false);
        // Automatically trigger upload after successful login
        // But need to ensure syllabus content is already entered.
        // Better to just let the user click "Upload" again.
        Toast.show({ type: 'success', text1: 'Logged In', text2: 'You can now upload your syllabus.' });
    };

    return (
        <Modal
            visible={visible}
            transparent={true}
            animationType="slide"
            onRequestClose={onClose}
        >
            <View style={styles.modalOverlay}>
                <View style={styles.modalContent}>
                    <Text style={styles.title}>Upload New Syllabus</Text>
                    {!userInfo ? (
                        <View style={styles.loginPrompt}>
                            <Text style={styles.loginPromptText}>You must be logged in to upload a syllabus.</Text>
                            <TouchableOpacity style={styles.loginButton} onPress={() => setLoginModalVisible(true)}>
                                <Text style={styles.loginButtonText}>Login / Register</Text>
                            </TouchableOpacity>
                        </View>
                    ) : (
                        <ScrollView>
                            <Text style={styles.label}>Syllabus Name</Text>
                            <TextInput
                                style={styles.input}
                                placeholder="e.g., S4 Data Science"
                                value={syllabusName}
                                onChangeText={setSyllabusName}
                            />
                            <Text style={styles.label}>Syllabus JSON Content</Text>
                            <TextInput
                                style={[styles.input, styles.textArea]}
                                placeholder='[{"name":"Module 1", "topics":...}]'
                                value={syllabusContent}
                                onChangeText={setSyllabusContent}
                                multiline
                                numberOfLines={10}
                            />
                            {isLoading ? (
                                <ActivityIndicator size="large" color="#4F46E5" />
                            ) : (
                                <TouchableOpacity style={styles.uploadButton} onPress={handleUpload}>
                                    <Text style={styles.uploadButtonText}>Upload to Firebase</Text>
                                </TouchableOpacity>
                            )}
                        </ScrollView>
                    )}

                    <TouchableOpacity style={styles.closeButton} onPress={onClose}>
                        <Text style={styles.closeButtonText}>Cancel</Text>
                    </TouchableOpacity>
                </View>

                <LoginModal
                    visible={isLoginModalVisible}
                    onClose={() => setLoginModalVisible(false)}
                    onLoginSuccess={onLoginSuccess}
                />
            </View>
        </Modal>
    );
};

const styles = StyleSheet.create({
    modalOverlay: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.6)',
    },
    modalContent: {
        width: '90%',
        maxHeight: '80%',
        backgroundColor: 'white',
        borderRadius: 12,
        padding: 20,
    },
    title: {
        fontSize: 20,
        fontWeight: 'bold',
        marginBottom: 16,
        color: '#1f2937',
    },
    loginPrompt: {
        alignItems: 'center',
        marginVertical: 20,
    },
    loginPromptText: {
        fontSize: 16,
        color: '#4b5563',
        textAlign: 'center',
        marginBottom: 16,
    },
    loginButton: {
        backgroundColor: '#4F46E5',
        paddingVertical: 12,
        paddingHorizontal: 24,
        borderRadius: 8,
    },
    loginButtonText: {
        color: 'white',
        fontSize: 16,
        fontWeight: 'bold',
    },
    label: {
        fontSize: 16,
        fontWeight: '500',
        marginBottom: 8,
        color: '#374151',
    },
    input: {
        borderColor: '#d1d5db',
        borderWidth: 1,
        borderRadius: 8,
        padding: 12,
        marginBottom: 16,
        fontSize: 16,
        backgroundColor: '#f9fafb',
    },
    textArea: {
        textAlignVertical: 'top',
        height: 200,
    },
    uploadButton: {
        backgroundColor: '#10b981',
        paddingVertical: 14,
        borderRadius: 8,
        alignItems: 'center',
    },
    uploadButtonText: {
        color: 'white',
        fontSize: 16,
        fontWeight: 'bold',
    },
    closeButton: {
        marginTop: 12,
        padding: 10,
        alignItems: 'center',
    },
    closeButtonText: {
        fontSize: 16,
        color: '#6b7280',
    },
});

export default UploadSyllabusDialog;
--- END OF FILE app/components/progress/UploadSyllabusDialog.jsx ---

--- START OF FILE app/notes/[...path].js ---
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TextInput, TouchableOpacity, StatusBar, ActivityIndicator, SafeAreaView, ScrollView, KeyboardAvoidingView, Platform, Alert } from 'react-native';
import { WebView } from 'react-native-webview';
import * as FileSystem from 'expo-file-system';
import { useLocalSearchParams } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import * as SecureStore from 'expo-secure-store';
import { initializeApp } from 'firebase/app';
import { getDatabase, ref, set, get, child, remove, query, equalTo, limitToFirst } from 'firebase/database';

import LoginModal from '../components/auth/LoginModal';
import ChannelModal from '../components/notes/ChannelModal';
import UploadModal from '../components/notes/UploadModal';

// Markdown placeholder for template
const MARKDOWN_PLACEHOLDER = "%MARKDOWN_CONTENT%";

const firebaseConfig = {
  apiKey: "AIzaSyAnjWWep4dtxvn1YKtmdU7A002X2NAvlX0",
  authDomain: "data-science-ef878.firebaseapp.com",
  databaseURL: "https://data-science-ef878-default-rtdb.firebaseio.com",
  projectId: "data-science-ef878",
  storageBucket: "data-science-ef878.firebasestorage.app",
  messagingSenderId: "1010841233830",
  appId: "1:1010841233830:web:e7aa0b516ace71c1720767",
  measurementId: "G-FL7XZR6X7Q"
};

const app = initializeApp(firebaseConfig);
const database = getDatabase(app);

const sanitizePath = (path) => {
  return path
    .replace(/#/g, '%23')
    .replace(/\./g, '%2E')
    .replace(/\$/g, '%24')
    .replace(/\[/g, '%5B')
    .replace(/\]/g, '%5D')
    .replace(/%/g, '%25');
};

const INDEX_HTML_CONTENT_TEMPLATE = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>Notes Preview</title>
    <!-- GitHub Markdown CSS -->
    <link rel="stylesheet" href="github-markdown.min.css"
        integrity="sha512-H5FUvsR2W84sZ09/w6oFuncsnL1edP8HkvL8B2FZdT1TcXzw1MpL#1EdU0jN17xHxaqBZv4iSaS5S0Zd7l3F1lg" crossorigin="anonymous">
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="katex.min.css"
        integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
    <!-- Showdown -->
    <script src="showdown.min.js"></script>
    <!-- KaTeX JS (deferred for performance) -->
    <script defer src="katex.min.js"
        integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
    <!-- KaTeX Auto-Render (deferred) -->
    <script defer src="contrib/auto-render.min.js"
        integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="tryRenderMath()"></script>
    <!-- MathJax (async for optional math rendering) -->
    <script id="MathJax-script" async src="mathjax.min.js"></script>
    <!-- Highlight.js for Code Syntax Highlighting -->
    <link rel="stylesheet" href="github.min.css">
    <script src="highlight.min.js"></script>
    <style>
    body {
        background: #ffffff;
        padding: 30px;
        margin: 0;
        display: flex;
        width: 100vw;
        font-family:arial;
        color: #000000;
    }
    .markdown-body {
        font-size:14pt;
        max-width: 100%;
        padding-top:30px;
        background: #ffffff;
    }
    </style>
    <script>
        function sendToRN(type, message) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({ type, message }));
            }
        }
        function reportLoadError(resource) {
            sendToRN('error', \`Failed to load resource: \${resource}\`);
        }
        window.onerror = function(message, source, lineno, colno, error) {
            sendToRN('error', \`Script error: \${message} at \${source}:\${lineno}:\${colno}\`);
        };
        window.onload = function() {
            if (!document.getElementById('content')) {
                sendToRN('error', 'HTML loading failed: Content element not found');
            } else {
                sendToRN('log', 'HTML content loaded successfully');
                processMarkdown();
            }
            document.body.style.zoom = '90%';
        };
        setTimeout(function() {
            if (!window.showdown || !window.hljs || !window.katex) {
                sendToRN('error', 'HTML loading timeout: Essential libraries not loaded');
            }
        }, 5000);
        function tryRenderMath() {
            if (typeof renderMathInElement === 'function') {
                sendToRN('log', 'renderMathInElement is defined');
                const mathElements = document.body.getElementsByTagName('*');
                let mathCount = 0;
                for (let el of mathElements) {
                    if (el.textContent.match(/[$\\[\]()]/)) {
                        mathCount++;
                    }
                }
                sendToRN('log', \`Found \${mathCount} potential math elements\`);
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                    ],
                    throwOnError: false
                });
                sendToRN('log', 'renderMathInElement called');
            } else {
                sendToRN('error', 'renderMathInElement is not defined');
            }
        }
        function processMarkdown() {
            try {
                const md = ${MARKDOWN_PLACEHOLDER}
                let converter = new showdown.Converter({
                    tables: true,
                    ghCodeBlocks: true,
                    tasklists: true,
                    literalMidWordUnderscores: true,
                    extensions: []
                });
                document.getElementById("content").innerHTML = converter.makeHtml(md);
                document.querySelectorAll("pre code").forEach(block => hljs.highlightElement(block));
                tryRenderMath();
                sendToRN('log', 'Markdown processed successfully');
            } catch (e) {
                sendToRN('error', \`Markdown processing error: \${e.message}\`);
            }
        }
    </script>
</head>
<body>
    <article id="content" class="markdown-body"></article>
</body>
</html>
`;

const DEPENDENCIES = {
  'github-markdown.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css',
  'katex.min.css': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css',
  'showdown.min.js': 'https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js',
  'katex.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js',
  'contrib/auto-render.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js',
  'mathjax.min.js': 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
  'github.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css',
  'highlight.min.js': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js',
};

const NotesPage = () => {
  const basepath = useLocalSearchParams()?.path;
  const path = Array.isArray(basepath) ? basepath.join('/') : (basepath || 'default.md');

  if (path.endsWith('.html') || path.endsWith('/')) {
    return (
      <SafeAreaView className="flex-1 bg-white">
        <StatusBar barStyle="light-content" backgroundColor="#fff" />
        <WebView
          className="mt-10"
          originWhitelist={['*']}
          source={{ uri: `https://ihjas-ahammed.github.io/${path}` }}
          javaScriptEnabled={true}
          domStorageEnabled={true}
        />
      </SafeAreaView>
    );
  }

  const sanitizedPath = sanitizePath(path);
  const webViewRef = useRef(null);
  const [localHtmlPath, setLocalHtmlPath] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [progress, setProgress] = useState(0);
  const [markdown, setMarkdown] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [error, setError] = useState(null);
  const [markdownLoaded, setMarkdownLoaded] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState("Preparing...");

  // User and Channel State
  const [channels, setChannels] = useState([]);
  const [selectedChannel, setSelectedChannel] = useState('default');
  const [userId, setUserId] = useState('');
  const [pin, setPin] = useState('');
  const [userClass, setUserClass] = useState('');

  // Modal Visibility State
  const [showChannelModal, setShowChannelModal] = useState(false);
  const [showUploadModal, setShowUploadModal] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false);

  const fetchChannels = async () => {
    try {
        const dbRef = ref(database);
        const snapshot = await get(child(dbRef, `notes/${sanitizedPath}`));
        
        const storedUserId = await SecureStore.getItemAsync('userId');
        const storedPin = await SecureStore.getItemAsync('pin');
  
        if (snapshot.exists()) {
          const data = snapshot.val();
          const channelList = Object.entries(data).map(([key, value]) => ({
            id: key,
            ...value,
            visible: value.type === 'public' || (storedUserId && value.name === storedUserId && value.pin === storedPin),
            canDelete: storedUserId && value.name === storedUserId && value.pin === storedPin
          })).filter(channel => channel.visible);
          setChannels(channelList);
        } else {
          setChannels([]);
        }
      } catch (err) {
        setError(`Failed to fetch channels: ${err.message}`);
      }
  };

  useEffect(() => {
    const loadCredentials = async () => {
      const storedUserId = await SecureStore.getItemAsync('userId');
      const storedPin = await SecureStore.getItemAsync('pin');
      const storedClass = await SecureStore.getItemAsync('userClass');
      if (storedUserId && storedPin) {
        setUserId(storedUserId);
        setPin(storedPin);
        setUserClass(storedClass || '');
        await fetchChannels();
      }
    };
    loadCredentials();
  }, []);

  const ensureDirectoryExists = async (dirPath) => {
    const info = await FileSystem.getInfoAsync(dirPath);
    if (!info.exists) {
      await FileSystem.makeDirectoryAsync(dirPath, { intermediates: true });
    }
  };

  const safeDownloadFile = async (url, filePath, onProgress) => {
    try {
      const info = await FileSystem.getInfoAsync(filePath);
      if (info.exists) {
        onProgress(100);
        return;
      }
      setLoadingMessage(`Downloading: ${url.split('/').pop()}`);
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      await ensureDirectoryExists(dirPath);
      const downloadResumable = FileSystem.createDownloadResumable(
        url,
        filePath,
        {},
        (downloadProgress) => {
          const percent = (downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite) * 100;
          onProgress(percent);
        }
      );
      const { status } = await downloadResumable.downloadAsync();
      if (status < 200 || status >= 300) {
        throw new Error(`Download failed with status code: ${status}`);
      }
      console.log(`Successfully downloaded ${url} to ${filePath}`);
    } catch (err) {
      console.error(`Failed to download ${url} to ${filePath}:`, err);
      throw err;
    }
  };

  const handleDeleteChannel = async (channelId) => {
    if (!userId || !pin) {
        setError('Please log in to delete notes');
        setShowLoginModal(true);
        return;
    }

    try {
        const dbRef = ref(database, `notes/${sanitizedPath}/${channelId}`);
        const snapshot = await get(dbRef);

        if (!snapshot.exists()) {
            setError('Note not found');
            return;
        }

        const channelData = snapshot.val();
        if (channelData.name !== userId || channelData.pin !== pin) {
            setError('You can only delete your own notes');
            return;
        }

        Alert.alert(
            "Confirm Delete", "Are you sure you want to delete this note?",
            [{ text: "Cancel", style: "cancel" }, {
                text: "Delete", style: "destructive",
                onPress: async () => {
                    setIsLoading(true);
                    try {
                        await remove(dbRef);
                        await fetchChannels();
                        if (selectedChannel === channelId) {
                            await handleChannelSelect('default');
                        }
                    } catch (err) {
                        setError(`Failed to delete note: ${err.message}`);
                    } finally {
                        setIsLoading(false);
                    }
                }
            }]
        );
    } catch (err) {
        setError(`Error verifying note ownership: ${err.message}`);
    }
  };

  const handleLoginSuccess = async (credentials) => {
    setUserId(credentials.userId);
    setPin(credentials.pin);
    setUserClass(credentials.userClass);
    await fetchChannels();
    setShowLoginModal(false);
  };

  const handleUpload = async (isPublic) => {
    if (!userId || !pin) {
        setShowUploadModal(false);
        setShowLoginModal(true);
        return;
    }

    setIsLoading(true);
    setShowUploadModal(false);
    try {
        const uClass = await SecureStore.getItemAsync('userClass');
        const userNotesQuery = query(ref(database, `notes/${sanitizedPath}`), equalTo(userId), limitToFirst(1));
        const snapshot = await get(userNotesQuery);
        let existingChannelId = null;

        if (snapshot.exists()) {
            const data = snapshot.val();
            existingChannelId = Object.keys(data)[0];
            const existingNote = Object.values(data)[0];
            if (existingNote.pin !== pin) {
                setError('PIN does not match existing note');
                setIsLoading(false);
                return;
            }
        }

        const channelId = existingChannelId || `${sanitizePath(userId)}`;
        const channelData = { name: userId, pin: pin, class: uClass, note: markdown, type: isPublic ? 'public' : 'private' };
        await set(ref(database, `notes/${sanitizedPath}/${channelId}`), channelData);
        await fetchChannels();
        setSelectedChannel(channelId);
    } catch (err) {
        setError(`Upload failed: ${err.message}`);
    } finally {
        setIsLoading(false);
    }
  };
  
  const handleChannelSelect = async (channelId) => {
    setIsLoading(true);
    try {
      const mdUrl = `https://ihjas-ahammed.github.io/${path}`;
      const dataDir = `${FileSystem.documentDirectory}notes`;
      let mdFilePath = `${dataDir}/${path}`;
      if (!path.includes('.')) {
        mdFilePath = `${dataDir}/${path}/index.md`;
      }
      let mdc = '';
      if (channelId === 'default') {
        await FileSystem.deleteAsync(mdFilePath, { idempotent: true });
        await safeDownloadFile(mdUrl, mdFilePath, setProgress);
        mdc = await FileSystem.readAsStringAsync(mdFilePath, { encoding: FileSystem.EncodingType.UTF8 });
        setMarkdown(mdc);
      } else {
        const dbRef = ref(database);
        const snapshot = await get(child(dbRef, `notes/${sanitizedPath}/${channelId}`));
        if (snapshot.exists()) {
          mdc = snapshot.val().note;
          setMarkdown(mdc);
        }
      }
      const htmlPath = `${dataDir}/index.html`;
      const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, JSON.stringify(mdc));
      await FileSystem.deleteAsync(htmlPath, { idempotent: true });
      await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
      await FileSystem.writeAsStringAsync(mdFilePath, mdc, { encoding: FileSystem.EncodingType.UTF8 });
      setLocalHtmlPath(htmlPath);
      setSelectedChannel(channelId);
      webViewRef.current?.reload();
    } catch (err) {
      setError(`Failed to load channel: ${err.message}`);
    } finally {
      setIsLoading(false);
      setShowChannelModal(false);
    }
  };

  useEffect(() => {
    const setupFiles = async () => {
      setIsLoading(true);
      setError(null);
      setProgress(0);
      try {
        const dataDir = `${FileSystem.documentDirectory}notes`;
        const htmlPath = `${dataDir}/index.html`;
        let mdFilePath = `${dataDir}/${path}`;
        if (!path.includes('.')) {
          mdFilePath = `${dataDir}/${path}/index.md`;
        }
        const mdFileDir = mdFilePath.substring(0, mdFilePath.lastIndexOf('/'));
        await ensureDirectoryExists(dataDir);
        await ensureDirectoryExists(mdFileDir);

        let filesDownloaded = 0;
        const fontCount = 25; // Estimated number of fonts for KaTeX v0.16.21
        const totalFiles = Object.keys(DEPENDENCIES).length + 1 + fontCount;

        for (const [fileName, url] of Object.entries(DEPENDENCIES)) {
          const filePath = `${dataDir}/${fileName}`;
          await safeDownloadFile(url, filePath, (percent) => {
            setProgress(Math.min(((filesDownloaded + (percent / 100)) / totalFiles) * 100, 100));
          });
          filesDownloaded += 1;
          setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
        }

        let mdContent = '';
        const mdFileInfo = await FileSystem.getInfoAsync(mdFilePath);
        if (mdFileInfo.exists) {
          mdContent = await FileSystem.readAsStringAsync(mdFilePath, { encoding: FileSystem.EncodingType.UTF8 });
          filesDownloaded += 1;
          setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
        } else {
          try {
            await fetchChannels();
            const mdUrl = `https://ihjas-ahammed.github.io/${path}`;
            await safeDownloadFile(mdUrl, mdFilePath, (percent) => {
              setProgress(Math.min(((filesDownloaded + (percent / 100)) / totalFiles) * 100, 100));
            });
            mdContent = await FileSystem.readAsStringAsync(mdFilePath, { encoding: FileSystem.EncodingType.UTF8 });
            filesDownloaded += 1;
            setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
          } catch (err) {
            mdContent = `# ${path.split('/').pop().replace('.md', '')}\n\nStart writing...\n\nInline: $E = mc^2$\n\nDisplay:\n$$\\int_0^1 x^2 dx = \\frac{1}{3}$$\n\n\`\`\`javascript\nconsole.log("Hello");\n\`\`\``;
            await FileSystem.writeAsStringAsync(mdFilePath, mdContent, { encoding: FileSystem.EncodingType.UTF8 });
            filesDownloaded += 1;
            setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
          }
        }
        setMarkdown(mdContent);

        const fontDir = `${dataDir}/fonts`;
        await ensureDirectoryExists(fontDir);
        const katexCssPath = `${dataDir}/katex.min.css`;
        const cssContent = await FileSystem.readAsStringAsync(katexCssPath, { encoding: FileSystem.EncodingType.UTF8 });
        const fontUrls = new Set();
        const urlRegex = /url\(['"]?([^'")]+)['"]?\)/g;
        let match;
        while ((match = urlRegex.exec(cssContent)) !== null) {
          const relativeUrl = match[1];
          if (relativeUrl.startsWith('fonts/')) {
            fontUrls.add(relativeUrl);
          }
        }
        const katexBaseUrl = DEPENDENCIES['katex.min.css'].replace('katex.min.css', '');
        for (const relativeUrl of fontUrls) {
          const filename = relativeUrl.split('/').pop();
          const absoluteUrl = `${katexBaseUrl}${relativeUrl}`;
          const localFontPath = `${fontDir}/${filename}`;
          await safeDownloadFile(absoluteUrl, localFontPath, (percent) => {
            setProgress(Math.min(((filesDownloaded + (percent / 100)) / totalFiles) * 100, 100));
          });
          filesDownloaded += 1;
          setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
        }
        console.log(`Total fonts downloaded: ${fontUrls.size}`);

        const jsonMarkdown = JSON.stringify(mdContent);
        const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, jsonMarkdown);
        await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
        setLocalHtmlPath(htmlPath);
      } catch (error) {
        console.error('Error setting up files:', error);
        setError(`Error: ${error.message}`);
      } finally {
        setIsLoading(false);
        await fetchChannels();
      }
    };
    setupFiles();
  }, [path]);

  const handleSave = async () => {
    setIsLoading(true);
    setLoadingMessage('Saving changes...');
    try {
      const dataDir = `${FileSystem.documentDirectory}notes`;
      let mdFilePath = `${dataDir}/${path}`;
      if (!path.includes('.')) {
        mdFilePath = `${dataDir}/${path}/index.md`;
      }
      const mdFileDir = mdFilePath.substring(0, mdFilePath.lastIndexOf('/'));
      await ensureDirectoryExists(mdFileDir);
      await FileSystem.writeAsStringAsync(mdFilePath, markdown, { encoding: FileSystem.EncodingType.UTF8 });
      const htmlPath = `${dataDir}/index.html`;
      const jsonMarkdown = JSON.stringify(markdown);
      const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, jsonMarkdown);
      await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
      setIsEditing(false);
    } catch (error) {
      setError(`Save error: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleMessage = (event) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);
      if (data.type === 'log') {
        if (data.message === 'Markdown processed successfully') {
          setMarkdownLoaded(true);
        } else if (data.message === 'renderMathInElement is defined') {
          setMarkdownLoaded(false);
        }
        console.log('WebView Log:', data.message);
      } else if (data.type === 'error') {
        console.error('WebView Error:', data.message);
      }
    } catch (error) {
      console.error('Failed to parse WebView message:', error);
    }
  };

  if (isLoading) {
    return (
      <View className="flex-1 justify-center items-center bg-white">
        <ActivityIndicator size="large" color="#000000" />
        <Text className="text-black mt-2">{Math.min(progress, 100).toFixed(0)}%</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View className="flex-1 justify-center items-center p-5 bg-[#1E1E1E]">
        <Text className="text-[#FF5555] mb-5 text-center text-base">{error}</Text>
        <TouchableOpacity
          className="bg-[#2D5AF2] px-5 py-2.5 rounded"
          onPress={() => {
            setError(null);
            setIsLoading(true);
            setTimeout(() => setIsLoading(false), 100);
          }}
        >
          <Text className="text-white text-base">Retry</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView className="flex-1 bg-white">
      <StatusBar barStyle="light-content" backgroundColor="#ffffff" />
      <View className="absolute top-2 right-0 flex-col items-center justify-end px-2.5 z-10">
        {isEditing ? (
          <>
            <TouchableOpacity className="p-2" onPress={handleSave}>
              <Ionicons name="sync" size={18} color="black" />
            </TouchableOpacity>
            <TouchableOpacity className="p-2" onPress={() => setIsEditing(false)}>
              <Ionicons name="close" size={18} color="black" />
            </TouchableOpacity>
          </>
        ) : (
          <>
            <TouchableOpacity className="p-2" onPress={() => setIsEditing(true)}>
              <Ionicons name="pencil" size={18} color="black" />
            </TouchableOpacity>
            <TouchableOpacity className="p-2" onPress={() => setShowChannelModal(true)}>
              <Ionicons name="cloud" size={18} color="black" />
            </TouchableOpacity>
            <TouchableOpacity className="p-2" onPress={() => setShowUploadModal(true)}>
              <Ionicons name="cloud-upload" size={18} color="black" />
            </TouchableOpacity>
            {userId && pin ? (
              <TouchableOpacity className="p-2" onPress={() => { setUserId(''); setPin(''); setUserClass(''); SecureStore.deleteItemAsync('userId'); SecureStore.deleteItemAsync('pin'); SecureStore.deleteItemAsync('userClass'); setChannels([]); }}>
                <Ionicons name="log-out" size={18} color="black" />
              </TouchableOpacity>
            ) : (
              <TouchableOpacity className="p-2" onPress={() => setShowLoginModal(true)}>
                <Ionicons name="log-in" size={18} color="black" />
              </TouchableOpacity>
            )}
          </>
        )}
      </View>
      {isEditing ? (
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={{ flex: 1 }}
        >
          <TextInput
            className="p-[30px] text-black bg-white text-normal min-h-[200px]"
            multiline
            value={markdown}
            onChangeText={setMarkdown}
            autoCapitalize="none"
            autoCorrect={false}
            spellCheck={false}
            keyboardType="ascii-capable"
            textAlignVertical="top"
          />
        </KeyboardAvoidingView>
      ) : (
        <View style={{ flex: 1 }}>
          <WebView
            className="mt-10"
            ref={webViewRef}
            originWhitelist={['*']}
            source={{ uri: localHtmlPath }}
            baseUrl={`${FileSystem.documentDirectory}notes/`}
            allowFileAccess={true}
            mixedContentMode="always"
            onMessage={handleMessage}
            allowUniversalAccessFromFileURLs={true}
            allowFileAccessFromFileURLs={true}
            domStorageEnabled={true}
            javaScriptEnabled={true}
          />
          {!markdownLoaded ? (
            <View style={{
              position: 'absolute',
              top: 0, left: 0, right: 0, bottom: 0,
              justifyContent: 'center',
              alignItems: 'center',
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              zIndex: 10
            }}>
              <ActivityIndicator size="large" color="#000000" />
              <Text style={{ color: '#000', marginTop: 10 }}>Loading Markdown...</Text>
            </View>
          ) : null}
        </View>
      )}

      <ChannelModal 
        visible={showChannelModal}
        onClose={() => setShowChannelModal(false)}
        channels={channels}
        onSelectChannel={handleChannelSelect}
        onDeleteChannel={handleDeleteChannel}
      />
      <UploadModal 
        visible={showUploadModal}
        onClose={() => setShowUploadModal(false)}
        onUpload={handleUpload}
        userId={userId}
      />
      <LoginModal 
        visible={showLoginModal}
        onClose={() => setShowLoginModal(false)}
        onLoginSuccess={handleLoginSuccess}
      />
    </SafeAreaView>
  );
};

export default NotesPage;
--- END OF FILE app/notes/[...path].js ---

--- START OF FILE app/pages/Progress.jsx ---
import React, { useState, useEffect } from 'react';
import { View, ScrollView, TouchableOpacity, ActivityIndicator, Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import { getDatabase, ref, get } from 'firebase/database';
import { MaterialIcons } from '@expo/vector-icons';
import Toast from 'react-native-toast-message';
import { SafeAreaView } from 'react-native-safe-area-context';

import LearningCard from '../components/progress/LearningCard';
import TopicProgress from '../components/progress/TopicProgress';
import ProgressStats from '../components/progress/ProgressStats';
import EditDialog from '../components/progress/EditDialog';
import ImportExportDialog from '../components/progress/ImportExportDialog';
import RoutineModal from '../components/progress/RoutineModal';
import UploadSyllabusDialog from '../components/progress/UploadSyllabusDialog';

const checkNetworkStatus = async () => {
    try {
        const response = await fetch("https://8.8.8.8", {
            method: "HEAD",
            timeout: 5000
        });
        return response.status >= 200 && response.status < 300;
    } catch (error) {
        return false;
    }
};

const Progress = ({ firebaseApp, setPage }) => {
    // State declarations
    const [data, setData] = useState([]);
    const [store, setStore] = useState([]);
    const [activeBook, setActiveBook] = useState(null);
    const [activeTopic, setActiveTopic] = useState(null);
    const [editDialog, setEditDialog] = useState(false);
    const [importExportDialog, setImportExportDialog] = useState(false);
    const [routineModal, setRoutineModal] = useState(false);
    const [isUploadSyllabusModalVisible, setUploadSyllabusModalVisible] = useState(false);
    const [currentModule, setCurrentModule] = useState([]);
    const [isOnline, setIsOnline] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    const defaultData = [
        // Your default data structure here
    ];

    // Data loading functions
    const loadData = async () => {
        try {
            const storedData = await SecureStore.getItemAsync('progressData');
            if (storedData) {
                setData(JSON.parse(storedData));
            } else {
                await SecureStore.setItemAsync('progressData', JSON.stringify(defaultData));
                setData(defaultData);
            }
        } catch (error) {
            console.error('Error loading progress data:', error);
        }
    };

    const loadStore = async () => {
        try {
            const db = getDatabase(firebaseApp);
            const storeRef = ref(db, 'store');
            const snapshot = await get(storeRef);
            if (snapshot.exists()) {
                setStore(snapshot.val());
            }
        } catch (error) {
            console.error('Error loading store data:', error);
        }
    };

    // Initial data loading and network checking
    useEffect(() => {
        const initializeData = async () => {
            setIsLoading(true);
            await Promise.all([loadData()]);
            setIsLoading(false);
        };

        initializeData();

        const intervalId = setInterval(async () => {
            setIsOnline(await checkNetworkStatus());
            await Promise.all([loadStore()]);
        }, 5000);

        const netStat = async () => {
            setIsOnline(await checkNetworkStatus());
            await Promise.all([loadStore()]);
        }

        try{
            netStat()
        }catch(e){

        }

        return () => clearInterval(intervalId);
    }, []);

    // Data manipulation functions
    const saveData = async (newData) => {
        try {
            await SecureStore.setItemAsync('progressData', JSON.stringify(newData));
            setData(newData);
        } catch (error) {
            console.error('Error saving progress data:', error);
        }
    };

    const handleImportData = async (importedData) => {
        await saveData(importedData);
    };

    const handleLevelChange = async (bookName, topicName, subtopicName, newValue) => {
        const newData = data.map(book => {
            if (book.name === bookName) {
                return {
                    ...book,
                    topics: book.topics.map(topic => {
                        if (topic.name === topicName) {
                            return {
                                ...topic,
                                subtopics: topic.subtopics.map(subtopic => {
                                    if (subtopic.name === subtopicName) {
                                        return { ...subtopic, level: newValue + 1 };
                                    }
                                    return subtopic;
                                }),
                            };
                        }
                        return topic;
                    }),
                };
            }
            return book;
        });
        await saveData(newData);
    };

    // Progress calculation functions
    const getColorByPercentage = (percentage) => {
        if (percentage < 0 || percentage > 100) return '#94A3B8'; // Slate color for invalid values
        
        // Create a color scale that avoids the indigo/purple spectrum used in backgrounds
        if (percentage < 25) {
            // Low progress - red
            return '#7bed9f'; // Tailwind red-500
        } else if (percentage < 50) {
            // Some progress - yellow/amber
            return '#2ed573'; // Tailwind amber-500
        } else if (percentage < 75) {
            // Good progress - teal (avoiding pure green which might be hard to read)
            return '#1e90ff'; // Tailwind teal-500
        } else {
            // Excellent progress - cyan (avoiding blue/indigo used in the UI)
            return '#6c5ce7'; // Tailwind cyan-500
        }
    };

    const calculateProgress = (items) => {
        if (!items || items.length === 0) return 0;
        const totalPossible = items.length * 6;
        const current = items.reduce((sum, item) => sum + (item.level - 1 || 0), 0);
        return (current / totalPossible) * 100;
    };

    const calculateStats = () => {
        const allTopics = data.flatMap(book => book.topics.flatMap(topic => topic.subtopics));
        const totalProgress = calculateProgress(allTopics);
        const stats = [{
            title: 'Overall Progress',
            value: Math.round(totalProgress),
            color: getColorByPercentage(Math.round(totalProgress)),
            description: 'Total learning progress',
        }];
        
        data.forEach(book => {
            const bookProgress = calculateProgress(book.topics.flatMap(t => t.subtopics));
            stats.push({
                title: book.name,
                value: parseInt(bookProgress),
                color: getColorByPercentage(parseInt(bookProgress)),
                description: '',
            });
        });
        return stats;
    };

    // Button handlers
    const handleCloudButtonClick = () => {
        if (!isOnline) {
            Toast.show({
                type: 'error',
                text1: 'Error',
                text2: 'No network available for import/export',
            });
            return;
        }
        setImportExportDialog(true);
    };

    return (
        <SafeAreaView className="flex-1 bg-white dark:bg-gray-800">
            <View className="h-[1px] bg-indigo-100 dark:bg-indigo-800" />
            <ScrollView contentContainerStyle={{ padding: 16 }}>
                {/* Header */}
                <View className="flex-row justify-end items-center mb-4">
                    <View className="flex-row space-x-3 gap-2">
                        <TouchableOpacity
                            onPress={() => setUploadSyllabusModalVisible(true)}
                            className="bg-indigo-600 dark:bg-indigo-700 p-2 rounded-lg"
                        >
                            <MaterialIcons name="upload-file" size={24} color="white" />
                        </TouchableOpacity>
                        <TouchableOpacity
                            onPress={handleCloudButtonClick}
                            className="bg-indigo-600 dark:bg-indigo-700 p-2 rounded-lg"
                        >
                            <MaterialIcons name="cloud" size={24} color="white" />
                        </TouchableOpacity>
                        <TouchableOpacity
                            onPress={() => isOnline ? setEditDialog(true) : alert('No network available')}
                            className="bg-indigo-600 dark:bg-indigo-700 p-2 rounded-lg"
                        >
                            <MaterialIcons name="edit" size={24} color="white" />
                        </TouchableOpacity>
                    </View>
                </View>

                {/* Progress Stats */}
                <ProgressStats 
                    stats={calculateStats()} 
                    onAddTask={(index) => {
                        setCurrentModule(data[index]);
                        setRoutineModal(true);
                    }}
                />

                {/* Learning Cards */}
                <View className="space-y-4 mt-4">
                    {data.map(book => (
                        <View key={book.name}>
                            <LearningCard
                                title={book.name}
                                progress={calculateProgress(book.topics.flatMap(t => t.subtopics))}
                                onClick={() => setActiveBook(activeBook === book.name ? null : book.name)}
                                isActive={activeBook === book.name}
                            />
                            {activeBook === book.name && (
                                <View className="ml-8 mt-4 space-y-4">
                                    {book.topics.map(topic => (
                                        <View key={topic.name}>
                                            <LearningCard
                                                title={topic.name}
                                                progress={calculateProgress(topic.subtopics)}
                                                onClick={() => setActiveTopic(activeTopic === topic.name ? null : topic.name)}
                                                isActive={activeTopic === topic.name}
                                            />
                                            {activeTopic === topic.name && (
                                                <View className="ml-8 mt-4 space-y-3">
                                                    {topic.subtopics.map(subtopic => (
                                                        <TopicProgress
                                                            key={subtopic.name}
                                                            topic={subtopic}
                                                            onLevelChange={(newValue) =>
                                                                handleLevelChange(book.name, topic.name, subtopic.name, newValue)
                                                            }
                                                        />
                                                    ))}
                                                </View>
                                            )}
                                        </View>
                                    ))}
                                </View>
                            )}
                        </View>
                    ))}
                </View>
            </ScrollView>

            {/* Dialogs and Modals */}
            <EditDialog
                open={editDialog}
                courses={store}
                onClose={() => setEditDialog(false)}
                data={data}
                onSave={async (dt) => {
                    if (isOnline) await saveData(dt);
                    else alert('Cannot save changes offline');
                }}
            />

            <ImportExportDialog
                open={importExportDialog}
                onClose={() => setImportExportDialog(false)}
                firebaseApp={firebaseApp}
                onImportData={handleImportData}
            />

            <RoutineModal
                visible={routineModal}
                courseData={currentModule}
                onClose={() => {
                    setRoutineModal(false);
                }}
                onSave={() => {
                    setRoutineModal(false);
                    setPage("Routine");
                }}
            />

            <UploadSyllabusDialog
                visible={isUploadSyllabusModalVisible}
                onClose={() => setUploadSyllabusModalVisible(false)}
                firebaseApp={firebaseApp}
            />

            {/* Loading Overlay */}
            {isLoading && (
                <View 
                    className="absolute inset-0 flex justify-center items-center"
                    style={{ backgroundColor: 'rgba(255, 255, 255, 0.7)' }}
                >
                    <ActivityIndicator size="large" color="#6366f1" />
                </View>
            )}

            <Toast />
        </SafeAreaView>
    );
};

export default Progress;
--- END OF FILE app/pages/Progress.jsx ---
