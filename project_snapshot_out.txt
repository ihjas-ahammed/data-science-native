--- START OF FILE .gitattributes ---
# Auto detect text files and perform LF normalization
* text=auto

--- END OF FILE .gitattributes ---

--- START OF FILE .gitignore ---
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# @generated expo-cli sync-8d4afeec25ea8a192358fae2f8e2fc766bdce4ec
# The following patterns were generated by expo-cli

# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# @end expo-cli
--- END OF FILE .gitignore ---

--- START OF FILE app.config.js ---
export default ({ config }) => {

  return {
    expo: {
      name: "Sirius",
      slug: "data-science-native",
      scheme: "org",
      version: "1.2.5",
      orientation: "portrait",
      icon: "./assets/icon.png",
      userInterfaceStyle: "light",
      splash: {
        image: "./assets/icon.png",
        resizeMode: "cover",
        backgroundColor: "#000000"
      },
      newArchEnabled: true,
      android: {
        package: "me.ihjas.notes",
        versionCode: 19,
        permissions: ["INTERNET", "CAMERA"],
        runtimeVersion: "1.2.5",
        
      },
      web: {
        favicon: "./assets/icon.png",
        bundler: "metro"
      },
      plugins: [
        "expo-router",
        "expo-secure-store",
        [
          "expo-notifications",
          {
            icon: "./assets/image.png",
            color: "#ffffff"
          }
        ],
        [
          'expo-build-properties',
          {
            android: {
              compileSdkVersion: 35,
              targetSdkVersion: 35,
              buildToolsVersion: '35.0.0',
              packagingOptions: {
                abiFilters: ['armeabi-v7a', 'arm64-v8a']
              }
            },
            ios: {
              deploymentTarget: '15.1',
            },
          },
        ],
      ],
      extra: {
        router: {
          origin: false
        },
        eas: {
          projectId: "f98e6168-8ce2-4498-856d-8dee633447f7"
        }
      },
      updates: {
        url: "https://u.expo.dev/f98e6168-8ce2-4498-856d-8dee633447f7"
      },
      ios: {
        runtimeVersion: "1.1",
        bundleIdentifier: "me.ihjas.notes"
      }
    }
  };
};
--- END OF FILE app.config.js ---

--- START OF FILE babel.config.js ---
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel"
    ],
  };
};

--- END OF FILE babel.config.js ---

--- START OF FILE index.js ---
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

--- END OF FILE index.js ---

--- START OF FILE LICENSE ---
MIT License

Copyright (c) 2025 Ihjas Ahammed K

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--- END OF FILE LICENSE ---

--- START OF FILE metro.config.js ---
const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require('nativewind/metro');

const config = getDefaultConfig(__dirname)

module.exports = withNativeWind(config, { input: './app/global.css' })
--- END OF FILE metro.config.js ---

--- START OF FILE tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  // NOTE: Update this to include the paths to all of your component files.
  content: ["./app/*.{js,jsx,ts,tsx}","./app/**/*.{js,jsx,ts,tsx}"],
  presets: [require("nativewind/preset")],
  theme: {
    extend: {},
  },
  plugins: [],
}
--- END OF FILE tailwind.config.js ---

--- START OF FILE update.bat ---
EAS_BUILD_PROFILE=preview  eas update --branch preview

AIzaSyAu9swfNci4KFg63TjnxoV9zCfwXz9wuuA
--- END OF FILE update.bat ---

--- START OF FILE .github/workflows/build-apk.yml ---
name: Build Development and Release APKs Locally

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm install

      - name: Install Expo CLI
        run: npm install -g expo-cli

      - name: Prebuild
        run: npx expo prebuild

      - name: Setup Java (JDK)
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Build Android APKs
        run: |
          cd android
          chmod +x gradlew
          ./gradlew assembleRelease
        env:
          ANDROID_HOME: $ANDROID_SDK_ROOT

      - name: Upload Release APK Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-release-apk
          path: android/app/build/outputs/apk/release/app-release.apk
--- END OF FILE .github/workflows/build-apk.yml ---

--- START OF FILE app/cog.js ---
import { View, Text, StatusBar, ActivityIndicator, ScrollView, TouchableHighlight, Modal, TextInput, Image, Linking } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import React, { useState, useEffect, useCallback } from 'react';
import { useLocalSearchParams, router } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import * as FileSystem from 'expo-file-system';
import * as SecureStore from 'expo-secure-store';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import TestComponent from './components/TestComponent';
import ApiKeyManager from './components/cog/ApiKeyManager';

// Utility function to shuffle an array (Fisher-Yates algorithm)
const shuffle = (array) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

// Define sample sizes for each section
const sampleSizes = {
  "Section A": 8,
  "Section B": 5,
  "Section C": 1
};

const cog = () => {
  const { dt } = useLocalSearchParams();
  const { qa, title } = JSON.parse(dt);
  const { path, obj } = qa;

  const [data, setData] = useState([]);
  const [sampleQ, setSampleQ] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [scores, setScores] = useState({});
  const [allWrongQuestions, setAllWrongQuestions] = useState([]);
  const [activeTab, setActiveTab] = useState('topics');
  const [modalVisible, setModalVisible] = useState(false);
  const [apiKey, setApiKey] = useState('');
  const [apiKeyModalVisible, setApiKeyModalVisible] = useState(false);
  const [savedApiKey, setSavedApiKey] = useState('');

  const [isDiceRolled, setIsDiceRolled] = useState(false)

  const filePath = `${FileSystem.documentDirectory}quiz_data/${path}`;
  const directoryPath = filePath.substring(0, filePath.lastIndexOf('/'));
  // Use sanitized title for the sample questions file path
  const sanitizedTitle = title.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
  const sampleFilePath = `${FileSystem.documentDirectory}quiz_data/${sanitizedTitle}/sample_current.json`;

  const sanitizeKey = (name) => {
    return name.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
  };

  // Load Google API key from secure storage
  useEffect(() => {
    const loadApiKey = async () => {
      try {
        const storedApiKey = await SecureStore.getItemAsync('google-api');
        if (storedApiKey) {
          setSavedApiKey(storedApiKey);
        } else {
          setSavedApiKey('AIzaSyBpxFwmq8_b9snWnAaRnyeUmmy3FzT-7rM')
        }
      } catch (err) {
        console.error('Failed to load API key:', err);
      }
    };
    loadApiKey();
  }, []);

  // Load main quiz data
  useEffect(() => {
    const loadData = async () => {
      try {
        const fileInfo = await FileSystem.getInfoAsync(filePath);
        if (fileInfo.exists) {
          const fileContent = await FileSystem.readAsStringAsync(filePath, { encoding: FileSystem.EncodingType.UTF8 });
          setData(JSON.parse(fileContent));
        } else {
          await FileSystem.makeDirectoryAsync(directoryPath, { intermediates: true });
          const downloadUrl = `https://ihjas-ahammed.github.io/${path}`;
          const downloadResult = await FileSystem.downloadAsync(downloadUrl, filePath);
          if (downloadResult.status === 200) {
            const downloadedContent = await FileSystem.readAsStringAsync(filePath, { encoding: FileSystem.EncodingType.UTF8 });
            setData(JSON.parse(downloadedContent));
          } else {
            throw new Error('Download failed');
          }
        }
      } catch (err) {
        setError('Failed to load quiz data');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };
    loadData();
  }, [path]);

  const reloadSampleQ = async () => {
    try {
      setIsLoading(true);
      await FileSystem.deleteAsync(filePath);
      await FileSystem.makeDirectoryAsync(directoryPath, { intermediates: true });
      const downloadUrl = `https://ihjas-ahammed.github.io/${path}`;
      const downloadResult = await FileSystem.downloadAsync(downloadUrl, filePath);
      if (downloadResult.status === 200) {
        const downloadedContent = await FileSystem.readAsStringAsync(filePath, { encoding: FileSystem.EncodingType.UTF8 });
        setData(JSON.parse(downloadedContent));
      } else {
        throw new Error('Download failed');
      }

      if (data && data.sample && data.sample.sections) {
        const generatedSampleQ = data.sample.sections.map(section => {
          const questions = section.questions;
          const sampleSize = sampleSizes[section.name] || 0;
          const availableQuestions = questions.length;
          const numToSelect = Math.min(sampleSize, availableQuestions);
          const selectedQuestions = shuffle([...questions]).slice(0, numToSelect);
          return {
            name: section.name,
            marks: section.marks || 0,
            questions: selectedQuestions
          };
        });

        await FileSystem.writeAsStringAsync(sampleFilePath, JSON.stringify(generatedSampleQ), { encoding: FileSystem.EncodingType.UTF8 });
        setSampleQ(generatedSampleQ);
        setIsDiceRolled(true)
      }
    } catch (err) {
      setError('Failed to reload quiz data');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  // Load or generate sampleQ after main data is loaded
  useEffect(() => {
    if (data && data[obj]) {
      const loadSampleQ = async () => {
        try {
          // Ensure the directory exists
          const sampleDirectory = sampleFilePath.substring(0, sampleFilePath.lastIndexOf('/'));
          await FileSystem.makeDirectoryAsync(sampleDirectory, { intermediates: true });

          const fileInfo = await FileSystem.getInfoAsync(sampleFilePath);
          if (fileInfo.exists) {
            // Load existing sampleQ
            const fileContent = await FileSystem.readAsStringAsync(sampleFilePath, { encoding: FileSystem.EncodingType.UTF8 });
            setSampleQ(JSON.parse(fileContent));

            setIsDiceRolled(true)
          } else if (data.sample && data.sample.sections) {
            // Generate sampleQ
            const generatedSampleQ = data.sample.sections.map(section => {
              const questions = section.questions;
              const sampleSize = sampleSizes[section.name] || 0;
              const availableQuestions = questions.length;
              const numToSelect = Math.min(sampleSize, availableQuestions);
              const selectedQuestions = shuffle([...questions]).slice(0, numToSelect);
              return {
                name: section.name,
                marks: section.marks || 0,
                questions: selectedQuestions
              };
            });
            // Save to file
            await FileSystem.writeAsStringAsync(sampleFilePath, JSON.stringify(generatedSampleQ), { encoding: FileSystem.EncodingType.UTF8 });
            setSampleQ(generatedSampleQ);
          }
        } catch (err) {
          console.error('Failed to load or generate sample questions:', err);
        }
      };
      loadSampleQ();
    }
  }, [data, obj]);

  const loadRepracticeQuestions = useCallback(async () => {
    if (data && data[obj]) {
      const repracticePromises = data[obj].map((section) => {
        const key = sanitizeKey(title + section.name);
        const repracticeKey = `repractice-${key}`;
        return SecureStore.getItemAsync(repracticeKey).then((str) => ({
          key,
          questions: str ? JSON.parse(str) : [],
        }));
      });
      const repracticeArray = await Promise.all(repracticePromises);
      const allQuestions = repracticeArray.flatMap(({ key, questions }) =>
        questions.map((question, index) => ({ sectionKey: key, question, index }))
      );
      setAllWrongQuestions(allQuestions);
    }
  }, [data, obj, title]);

  useFocusEffect(
    useCallback(() => {
      const loadScoresAndRepractice = async () => {
        if (data && data[obj]) {
          const scorePromises = data[obj].map((section) => {
            const key = sanitizeKey(title + section.name);
            return SecureStore.getItemAsync(key).then((scr) => ({
              key,
              score: scr ? parseInt(scr, 10) : 0,
            }));
          });
          const [scoresArray] = await Promise.all([Promise.all(scorePromises)]);
          const scoresObj = scoresArray.reduce((acc, { key, score }) => {
            acc[key] = score;
            return acc;
          }, {});
          setScores(scoresObj);
          await loadRepracticeQuestions();
        }
      };
      loadScoresAndRepractice();
    }, [data, obj, loadRepracticeQuestions])
  );

  const removeQuestion = async (sectionKey, questionIndex) => {
    try {
      const repracticeKey = `repractice-${sectionKey}`;
      const str = await SecureStore.getItemAsync(repracticeKey);
      if (str) {
        const questions = JSON.parse(str);
        questions.splice(questionIndex, 1);
        await SecureStore.setItemAsync(repracticeKey, JSON.stringify(questions));
        await loadRepracticeQuestions();
      }
    } catch (err) {
      console.error('Failed to remove question:', err);
    }
  };



  if (isLoading) {
    return (
      <SafeAreaView className="flex-1 justify-center items-center bg-indigo-50 dark:bg-gray-900">
        <ActivityIndicator size="large" color="#6366f1" />
      </SafeAreaView>
    );
  }

  if (error) {
    return (
      <SafeAreaView className="flex-1 justify-center items-center bg-indigo-50 dark:bg-gray-900">
        <Text className="text-red-500 text-lg">{error}</Text>
      </SafeAreaView>
    );
  }

  const handleExit = () => {
    router.back();
  };

  // Custom progress bar component to match TestComponent style
  const GameProgressBar = ({ score, total }) => {
    // Calculate percentage
    const percentage = (score / total) * 100;

    // Determine color based on score percentage
    const getProgressColor = () => {
      if (percentage < 40) return '#FF4D4D'; // Bright red for low scores
      if (percentage < 70) return '#FFD700'; // Gold for medium scores
      return '#32CD32'; // Lime green for high scores
    };

    // Create array of circles based on total
    const circles = Array.from({ length: total > 10 ? 10 : total }, (_, i) => i + 1);
    const filledCircles = Math.ceil((circles.length * score) / total);

    return (
      <View className="flex-row flex-wrap max-w-full justify-end">
        {circles.map((circle, index) => {
          // Determine if this circle should be filled based on score
          const isActive = index < filledCircles;

          return (
            <View
              key={circle}
              className={`h-2 w-2 rounded-full m-0.5 ${isActive ? 'shadow' : ''}`}
              style={{
                backgroundColor: isActive ? getProgressColor() : 'rgba(255,255,255,0.3)',
                shadowColor: isActive ? getProgressColor() : 'transparent',
                shadowOffset: { width: 0, height: 0 },
                shadowOpacity: isActive ? 0.7 : 0,
                shadowRadius: isActive ? 2 : 0,
              }}
            />
          );
        })}
      </View>
    );
  };

  return (
    <SafeAreaView className="flex-1 bg-indigo-50 dark:bg-gray-900">
      <StatusBar barStyle="light-content" backgroundColor="#4F46E5" />

      {/* Header */}
      <View className="h-14 bg-indigo-600 dark:bg-indigo-800 flex-row items-center px-4 shadow-md">
        <TouchableHighlight underlayColor="#4338CA" onPress={handleExit} className="p-2 rounded-full">
          <MaterialIcons name="arrow-back" size={24} color="#E0E7FF" />
        </TouchableHighlight>
        <Text className="text-indigo-50 text-lg font-bold flex-1 ml-4">{title}</Text>
        {activeTab === 'test' && (
          <TouchableHighlight underlayColor="#4338CA" onPress={reloadSampleQ} className="p-2 rounded-full">
            <Ionicons name="dice" size={24} color="#E0E7FF" />
          </TouchableHighlight>
        )}
      </View>

      {/* Main Content */}
      <View className="flex-1">
        <ScrollView className="flex-1 p-4 mb-4">
          {activeTab === 'topics' ? (
            data[obj]?.map((section, index) => {
              const key = sanitizeKey(title + section.name);
              const score = scores[key] || 0;
              const total = section.qa.length < 10 ? section.qa.length : 9;
              return (
                <TouchableHighlight
                  key={index}
                  onPress={() => {
                    router.push('/quiz?qs=' + JSON.stringify({ name: section.name, qa: section.qa, key: key }));
                  }}
                  underlayColor="#E0E7FF"
                  className="mb-4 rounded-lg overflow-hidden"
                >
                  <View className="p-4 bg-white dark:bg-gray-800 rounded-lg shadow border border-indigo-100 dark:border-indigo-800">
                    <View className="flex-row items-center mb-2">
                      <MaterialIcons name="stars" size={24} color="#6366f1" />
                      <Text className="text-lg font-semibold text-indigo-700 dark:text-indigo-300 ml-2">
                        {section.name}
                      </Text>
                    </View>

                    <View className="bg-indigo-50 dark:bg-gray-700 p-3 rounded-lg relative">
                      <View className="absolute top-2 right-2 z-10">
                        <GameProgressBar score={score} total={total} />
                      </View>

                      <View style={{ paddingTop: 20 }}>
                        <Text className="text-gray-600 dark:text-gray-300">
                          {score}/{total} completed
                        </Text>
                        {score >= total ? (
                          <View className="flex-row items-center mt-1">
                            <MaterialIcons name="check-circle" size={18} color="#10b981" />
                            <Text className="text-green-500 ml-1">Completed!</Text>
                          </View>
                        ) : (
                          <Text className="text-indigo-600 dark:text-indigo-300 mt-1">
                            Tap to continue quiz
                          </Text>
                        )}
                      </View>
                    </View>
                  </View>
                </TouchableHighlight>
              );
            })
          ) : activeTab === 'tools' ? (
            <View className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow border border-indigo-100 dark:border-indigo-800">
              <View className="flex-row items-center mb-3 bg-indigo-100 dark:bg-indigo-900 p-2 rounded-lg">
                <MaterialIcons name="build" size={24} color="#6366f1" />
                <Text className="text-lg font-semibold text-indigo-700 dark:text-indigo-300 ml-2">
                  Tools & Practice
                </Text>
              </View>

              <TouchableHighlight
                onPress={() => {
                  if (allWrongQuestions.length > 0) {
                    router.push('/quiz?qs=' + JSON.stringify({
                      name: "Repractice",
                      qa: allWrongQuestions.map(item => item.question),
                      key: "repractice",
                      maxNo: allWrongQuestions.length,
                    }));
                  } else {
                    alert("No questions to repractice.");
                  }
                }}
                underlayColor="#E0E7FF"
                className="mb-4 p-4 bg-indigo-50 dark:bg-gray-700 rounded-lg relative"
              >
                <View>
                  <View className="flex-row justify-between items-center">
                    <Text className="text-gray-800 dark:text-gray-200 font-semibold">
                      Repractice Questions
                    </Text>
                    <Text className="text-indigo-600 dark:text-indigo-300 font-semibold">
                      {allWrongQuestions.length}
                    </Text>
                  </View>
                  <Text className="text-gray-600 dark:text-gray-300 mt-1">
                    Review questions you've struggled with
                  </Text>
                </View>
              </TouchableHighlight>

              <TouchableHighlight
                onPress={() => setModalVisible(true)}
                underlayColor="#E0E7FF"
                className="mb-4 p-4 bg-indigo-50 dark:bg-gray-700 rounded-lg"
              >
                <View className="flex-row justify-between items-center">
                  <View>
                    <Text className="text-gray-800 dark:text-gray-200 font-semibold">
                      Manage Practice Items
                    </Text>
                    <Text className="text-gray-600 dark:text-gray-300 mt-1">
                      Edit your repractice question list
                    </Text>
                  </View>
                  <MaterialIcons name="edit" size={24} color="#6366f1" />
                </View>
              </TouchableHighlight>

              {/* New API Key Management Section */}
              <TouchableHighlight
                onPress={() => setApiKeyModalVisible(true)}
                underlayColor="#E0E7FF"
                className="p-4 bg-indigo-50 dark:bg-gray-700 rounded-lg"
              >
                <View className="flex-row justify-between items-center">
                  <View>
                    <Text className="text-gray-800 dark:text-gray-200 font-semibold">
                      Manage Google API Key
                    </Text>
                    <Text className="text-gray-600 dark:text-gray-300 mt-1">
                      {savedApiKey ? "API key is configured" : "Set your Google API key for AI features"}
                    </Text>
                  </View>
                  <MaterialIcons name="vpn-key" size={24} color="#6366f1" />
                </View>
              </TouchableHighlight>
            </View>
          ) : (
            sampleQ.length > 0 ? (
              <TestComponent sampleQ={sampleQ} isDiceRolled={isDiceRolled} />
            ) : (
              <View className="flex items-center justify-center p-4">
                <Text className="text-gray-500">No tests available!</Text>
              </View>
            )
          )}
        </ScrollView>

        {/* Bottom Navigation */}
        <View className="h-16 bg-white dark:bg-gray-800 flex-row items-center justify-around shadow-lg border-t border-indigo-100 dark:border-indigo-800">
          <TouchableHighlight
            underlayColor="#E0E7FF"
            onPress={() => setActiveTab('topics')}
            className="flex-1 items-center justify-center"
          >
            <View className="items-center">
              <MaterialIcons
                name="quiz"
                size={24}
                color={activeTab === 'topics' ? '#6366f1' : '#9ca3af'}
              />
              <Text
                className={`text-sm ${activeTab === 'topics' ? 'text-indigo-600 dark:text-indigo-400' : 'text-gray-500'}`}
              >
                Quiz
              </Text>
            </View>
          </TouchableHighlight>

          <TouchableHighlight
            underlayColor="#E0E7FF"
            onPress={() => setActiveTab('test')}
            className="flex-1 items-center justify-center"
          >
            <View className="items-center">
              <MaterialIcons
                name="assignment"
                size={24}
                color={activeTab === 'test' ? '#6366f1' : '#9ca3af'}
              />
              <Text
                className={`text-sm ${activeTab === 'test' ? 'text-indigo-600 dark:text-indigo-400' : 'text-gray-500'}`}
              >
                Test
              </Text>
            </View>
          </TouchableHighlight>

          <TouchableHighlight
            underlayColor="#E0E7FF"
            onPress={() => setActiveTab('tools')}
            className="flex-1 items-center justify-center"
          >
            <View className="items-center">
              <MaterialIcons
                name="build"
                size={24}
                color={activeTab === 'tools' ? '#6366f1' : '#9ca3af'}
              />
              <Text
                className={`text-sm ${activeTab === 'tools' ? 'text-indigo-600 dark:text-indigo-400' : 'text-gray-500'}`}
              >
                Tools
              </Text>
            </View>
          </TouchableHighlight>
        </View>
      </View>

      {/* Repractice Questions Modal */}
      <Modal
        animationType="slide"
        transparent={false}
        visible={modalVisible}
        onRequestClose={() => setModalVisible(false)}
      >
        <SafeAreaView className="flex-1 bg-indigo-50 dark:bg-gray-900">
          <View className="h-14 bg-indigo-600 dark:bg-indigo-800 flex-row items-center px-4 shadow-md">
            <TouchableHighlight
              underlayColor="#4338CA"
              onPress={() => setModalVisible(false)}
              className="p-2 rounded-full"
            >
              <MaterialIcons name="close" size={24} color="#E0E7FF" />
            </TouchableHighlight>
            <Text className="text-indigo-50 text-lg font-bold flex-1 ml-4">
              Edit Repractice Questions
            </Text>
          </View>

          <ScrollView className="flex-1 p-4">
            {allWrongQuestions.length > 0 ? (
              allWrongQuestions.map((item, idx) => (
                <View
                  key={`${item.sectionKey}-${item.index}`}
                  className="mb-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow border border-indigo-100 dark:border-indigo-800"
                >
                  <View className="flex-row justify-between items-center">
                    <Text className="text-gray-800 dark:text-gray-200 flex-1 mr-2">
                      {item.question.question}
                    </Text>
                    <TouchableHighlight
                      onPress={() => removeQuestion(item.sectionKey, item.index)}
                      underlayColor="#E0E7FF"
                      className="p-2 bg-indigo-100 dark:bg-indigo-700 rounded-full"
                    >
                      <MaterialIcons name="delete" size={20} color="#6366f1" />
                    </TouchableHighlight>
                  </View>
                </View>
              ))
            ) : (
              <View className="items-center justify-center p-8 my-8">
                <MaterialIcons name="assignment-turned-in" size={48} color="#9ca3af" />
                <Text className="text-gray-500 text-center mt-4 text-lg">
                  No repractice questions available
                </Text>
                <Text className="text-gray-400 text-center mt-2">
                  Questions you struggle with will appear here
                </Text>
              </View>
            )}
          </ScrollView>
        </SafeAreaView>
      </Modal>

      <ApiKeyManager
        isVisible={apiKeyModalVisible}
        onClose={() => setApiKeyModalVisible(false)}
        savedApiKey={savedApiKey}
        onApiKeySaved={(newKey) => setSavedApiKey(newKey)}
      />
    </SafeAreaView>
  );
};

export default cog;
--- END OF FILE app/cog.js ---

--- START OF FILE app/global.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;
--- END OF FILE app/global.css ---

--- START OF FILE app/index.js ---
import { SafeAreaView, StatusBar, Text, View } from 'react-native';
import './global.css';
import NavBar from './components/NavBar';
import Home from './pages/Home';
import { useState } from 'react';
import Routine from './pages/Routine';
import { initializeApp } from 'firebase/app';
import Progress from './pages/Progress';
import Extras from './pages/Misc';
import Learn from './pages/Learn';

const firebaseConfig = {
  apiKey: 'AIzaSyAnjWWep4dtxvn1YKtmdU7A002X2NAvlX0',
  authDomain: 'data-science-ef878.firebaseapp.com',
  databaseURL: 'https://data-science-ef878-default-rtdb.firebaseio.com',
  projectId: 'data-science-ef878',
  storageBucket: 'data-science-ef878.firebasestorage.app',
  messagingSenderId: '1010841233830',
  appId: '1:1010841233830:web:e7aa0b516ace71c1720767',
  measurementId: 'G-FL7XZR6X7Q',
};



// Initialize Firebase
const app = initializeApp(firebaseConfig);

export default function App() {
  const [current, setCurrent] = useState('Learn');
  

  return (
    <SafeAreaView className="flex-1 bg-white dark:bg-gray-800">
      <StatusBar barStyle="dark-content" backgroundColor="#fff" />
      <View className="h-[1px] bg-indigo-100 dark:bg-indigo-800" />
      <View className="py-4 px-5 border-b border-indigo-100 dark:border-indigo-800">
        <Text className="text-2xl font-bold text-indigo-700 dark:text-indigo-300 text-center">
          {current}
        </Text>
      </View>
      <View className="flex-1">
        {current === 'Notes' && <Home />}
        {current === 'Routine' && <Routine firebaseApp={app} />}
        {current === 'Progress' && (
          <Progress firebaseApp={app} setPage={setCurrent} />
        )}
        {current == 'Extras'&& (
          <Extras/>
        )} 
        {current == 'Learn' && (
          <Learn firebaseApp={app}/>
        )}
      </View>
      <NavBar current={current} setCurrent={setCurrent} />
    </SafeAreaView>
  );
}
--- END OF FILE app/index.js ---

--- START OF FILE app/lesson.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, Image } from 'react-native'
import React, { useEffect } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import { Ionicons } from '@expo/vector-icons'

const Lesson = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()

    const { subject, index, subInt, lesson } = JSON.parse(exp)

    // Get a background color based on the subject
    const getSubjectColor = () => {
        const colors = {
            math: 'bg-blue-600',
            science: 'bg-green-600',
            history: 'bg-amber-600',
            language: 'bg-purple-600',
            default: 'bg-indigo-600'
        }
        return colors[subject.name?.toLowerCase()] || colors.default
    }

    useEffect(()=>{
      if(lesson.tools.length == 1){
            const e = JSON.parse(exp)
            e.toolInt = 0
            router.push(`/tools/${lesson.tools[0].name}?exp=${JSON.stringify(e)}`)
      }  
    },[])

    // Get an icon based on tool type
    const getToolIcon = (toolName) => {
        const toolIcons = {
            quiz: "help-circle",
            memory: "help-circle",
            video: "videocam",
            reader: "document-text",
            practice: "pencil",
            calculator: "calculator",
            flashcards: "card",
            default: "apps",
            fib:"pencil",
            program:"calculator",
            qna: "help-circle"
        }
        
        // Check if tool name contains any of the keys
        for (const [key, icon] of Object.entries(toolIcons)) {
            if (toolName.toLowerCase().includes(key)) {
                return icon
            }
        }
        return toolIcons.default
    }

    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="light-content" backgroundColor="#4F46E5" />
            
            {/* Enhanced Action Bar */}
            <View className={`${getSubjectColor()} shadow-md`}>
                <View className="flex-row items-center justify-between py-4 px-4">
                    <View className="flex-row items-center">
                        <TouchableOpacity
                            className="p-2 bg-white/20 rounded-full"
                            onPress={() => router.back()}
                        >
                            <Ionicons name="arrow-back" size={24} color="#fff" />
                        </TouchableOpacity>
                        <Text className="text-white font-bold text-xl ml-3">{lesson.name}</Text>
                    </View>
                    
                </View>
                
            </View>
            
            {/* Enhanced Tools List */}
            <ScrollView className="px-4 pt-2 pb-8">
                {lesson.tools.map((tool, i) => (
                    <TouchableOpacity 
                        key={i} 
                        onPress={() => {
                            const e = JSON.parse(exp)
                            e.toolInt = i
                            router.push(`/tools/${tool.name}?exp=${JSON.stringify(e)}`)
                        }}
                        className="bg-white rounded-xl shadow-sm mb-4 overflow-hidden border border-gray-100"
                    >
                        <View className="flex-row items-center p-4">
                            <View className={`${getSubjectColor()} bg-opacity-20 w-12 h-12 rounded-full items-center justify-center`}>
                                <Ionicons name={getToolIcon(tool.name)} size={24} color={"#fff"} />
                            </View>
                            <View className="ml-4 flex-1">
                                <Text className="font-bold text-gray-800 text-lg">{tool.label}</Text>
                                <Text className="text-gray-500 mt-1" numberOfLines={1}>
                                    {`Upto ${tool.score} points`}
                                </Text>
                            </View>
                            <Ionicons name="chevron-forward" size={22} color="#9CA3AF" />
                        </View>
                    </TouchableOpacity>
                ))}
                
                {/* Empty state if no tools */}
                {lesson.tools.length === 0 && (
                    <View className="items-center justify-center py-16">
                        <Ionicons name="construct-outline" size={56} color="#D1D5DB" />
                        <Text className="text-gray-400 text-lg mt-4">No tools available</Text>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    )
}

export default Lesson
--- END OF FILE app/lesson.jsx ---

--- START OF FILE app/quiz.js ---
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { View, Text, TouchableHighlight, Animated, StatusBar, ScrollView, LayoutAnimation, Platform, TouchableOpacity, Vibration, Image } from 'react-native';
import { router, useLocalSearchParams } from 'expo-router';
import { MaterialIcons } from '@expo/vector-icons';
import * as SecureStore from 'expo-secure-store';
import { Audio } from 'expo-av';

const quiz = () => {
  // State declarations
  const [questions, setQuestions] = useState([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [options, setOptions] = useState([]);
  const [score, setScore] = useState(0);
  const [showFeedback, setShowFeedback] = useState(false);
  const [feedbackColor, setFeedbackColor] = useState('#28a745');
  const [feedbackMessage, setFeedbackMessage] = useState('');
  const [askedQuestions, setAskedQuestions] = useState([]);
  const [gameQuestions, setGameQuestions] = useState([]); // New state for unique questions
  const [progressAnim] = useState(new Animated.Value(0));
  const [progressBarColor] = useState(new Animated.Value(0));
  const [completed, setCompleted] = useState(false);
  const [answerSelected, setAnswerSelected] = useState(false);
  const [selectedOptionIndex, setSelectedOptionIndex] = useState(null);
  const [canProceed, setCanProceed] = useState(false);
  const [lastAnswerCorrect, setLastAnswerCorrect] = useState(false);
  const [isDescriptionGray, setIsDescriptionGray] = useState(false);
  const correctSoundRef = useRef(null);

  // Parse query parameters
  const { qs } = useLocalSearchParams();
  const { name, qa, key, maxNo } = JSON.parse(qs);

  const title = name;
  const sampleQuestions = qa;
  const TARGET_CORRECT_ANSWERS = maxNo ? maxNo : 10;

  // Load sound effect for correct answers
  useEffect(() => {
    const loadSound = async () => {
      try {
        const { sound } = await Audio.Sound.createAsync(
          require('../assets/sounds/correct.wav')
        );
        correctSoundRef.current = sound;
      } catch (error) {
        console.error('Error loading sound:', error);
      }
    };
    loadSound();
    return () => {
      if (correctSoundRef.current) {
        correctSoundRef.current.unloadAsync();
      }
    };
  }, []);

  // Initialize questions with shuffled order
  useEffect(() => {
    const shuffledQuestions = [...sampleQuestions].sort(() => Math.random() - 0.5);
    setQuestions(shuffledQuestions);
    setAskedQuestions([]);
    setGameQuestions([]); // Reset on initialization
  }, []);

  // Update score in SecureStore
  const updateScore = () => {
    SecureStore.getItemAsync(key).then(async (scr) => {
      if (parseInt(scr) <= score || !scr) {
        await SecureStore.setItemAsync(key, score.toString());
      }
    });
  };

  // Shuffle options when current question changes
  useEffect(() => {
    if (questions.length > 0) {
      const currentQuestion = questions[currentQuestionIndex];
      const questionOptions = currentQuestion.options.map((option, index) => ({
        text: option,
        isCorrect: index === currentQuestion.correct,
        originalIndex: index,
      }));
      const shuffledOptions = [...questionOptions].sort(() => Math.random() - 0.5);
      setOptions(shuffledOptions);
      setAnswerSelected(false);
      setSelectedOptionIndex(null);
      setCanProceed(false);
      setShowFeedback(false);
    }
  }, [questions, currentQuestionIndex]);

  // Update progress bar animation
  useEffect(() => {
    Animated.timing(progressAnim, {
      toValue: score / TARGET_CORRECT_ANSWERS,
      duration: 300,
      useNativeDriver: false,
    }).start();
    Animated.timing(progressBarColor, {
      toValue: score / TARGET_CORRECT_ANSWERS,
      duration: 300,
      useNativeDriver: false,
    }).start();
  }, [score]);

  const interpolatedColor = progressBarColor.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: ['#FF4D4D', '#FFD700', '#32CD32'],
  });


  // Handle answer selection
  const handleAnswer = async (isCorrect, index) => {
    setAnswerSelected(true);
    setSelectedOptionIndex(index);
    setAskedQuestions([...askedQuestions, questions[currentQuestionIndex]]);

    // Add to gameQuestions if not already present
    setGameQuestions(prev => {
      const currentQuestion = questions[currentQuestionIndex];
      if (prev.some(q => q === currentQuestion)) {
        return prev;
      } else {
        return [...prev, currentQuestion];
      }
    });

    const newScore = isCorrect ? score + 1 : Math.max(0, score - 1);
    setScore(newScore);
    setFeedbackMessage(isCorrect ? 'Correct! +1 point' : 'Incorrect! -1 point');
    setFeedbackColor(isCorrect ? '#28a745' : '#dc3545');
    setLastAnswerCorrect(isCorrect);
    setShowFeedback(true);
    updateScore();

    if (isCorrect && correctSoundRef.current) {
      try {
        await correctSoundRef.current.playAsync();
      } catch (error) {
        console.error('Error playing sound:', error);
      }
    } else {
      Vibration.vibrate(500);
    }

    const repracticeKey = `repractice-${key}`;
    try {
      const currentRepractice = await SecureStore.getItemAsync(repracticeKey);
      let repracticeList = currentRepractice ? JSON.parse(currentRepractice) : [];
      const currentQuestion = questions[currentQuestionIndex];

      if (isCorrect) {
        repracticeList = repracticeList.filter(q => q.question !== currentQuestion.question);
      } else {
        if (!repracticeList.some(q => q.question === currentQuestion.question)) {
          repracticeList.push(currentQuestion);
        }
      }
      await SecureStore.setItemAsync(repracticeKey, JSON.stringify(repracticeList));
    } catch (error) {
      console.error('Error updating repractice list:', error);
    }

    const correctOption = options.find(opt => opt.isCorrect);
    let optionsToKeep = isCorrect ? [correctOption] : [correctOption, options[index]];
    if (Platform.OS !== 'web') {
      LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
    }
    setOptions(optionsToKeep);

    if (isCorrect) {
      setCanProceed(true);
      setIsDescriptionGray(false);
    } else {
      setCanProceed(false);
      setIsDescriptionGray(true);
      setTimeout(() => {
        setCanProceed(true);
        setIsDescriptionGray(false);
      }, 2000);
    }

    if (newScore >= TARGET_CORRECT_ANSWERS) {
      setCompleted(true);
    }
  };

  // Move to next question
  const nextQ = async () => {
    if (correctSoundRef.current) {
      try {
        await correctSoundRef.current.stopAsync();
      } catch (error) {
        console.error('Error stopping sound:', error);
      }
    }
    setShowFeedback(false);
    moveToNextQuestion();
  };

  const moveToNextQuestion = useCallback(() => {
    if (currentQuestionIndex >= questions.length - 1) {
      if (askedQuestions.length >= questions.length) {
        const remainingQuestions = questions.filter(
          (q) => !askedQuestions.some((asked) => asked === q && asked.answeredCorrectly)
        );
        const shuffledQuestions =
          remainingQuestions.length === 0
            ? [...questions].sort(() => Math.random() - 0.5)
            : [...remainingQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffledQuestions);
        setAskedQuestions([]);
        setCurrentQuestionIndex(0);
      } else {
        setCurrentQuestionIndex(0);
      }
    } else {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
    }
  }, [currentQuestionIndex, questions, askedQuestions]);

  // Handle exit
  const handleExit = () => {
    router.back();
  };

  // Handle restart
  const handleRestart = () => {
    setScore(0);
    setCurrentQuestionIndex(0);
    setAskedQuestions([]);
    setGameQuestions([]); // Reset gameQuestions
    setCompleted(false);
    setAnswerSelected(false);
    setSelectedOptionIndex(null);
    const shuffledQuestions = [...sampleQuestions].sort(() => Math.random() - 0.5);
    setQuestions(shuffledQuestions);
  };

  // Completed Screen
  if (completed) {
    return (
      <View className="flex-1 bg-indigo-50 dark:bg-gray-800">
        <StatusBar barStyle="light-content" />
        <View className="h-14 bg-indigo-100 dark:bg-indigo-900 flex-row items-center px-4 shadow-md">
          <TouchableHighlight 
            underlayColor="#e0e7ff" 
            onPress={handleExit} 
            className="p-2 rounded-full"
          >
            <MaterialIcons name="arrow-back" size={24} color="#6366f1" />
          </TouchableHighlight>
          <Text className="text-indigo-700 dark:text-indigo-300 text-lg font-bold flex-1 ml-4">{title}</Text>
        </View>
        <ScrollView className="flex-1">
          <View className="justify-center items-center p-6">
            <MaterialIcons name="celebration" size={80} color="#6366f1" />
            <Text className="text-2xl font-bold text-indigo-700 dark:text-indigo-300 mt-6 mb-4">Congratulations!</Text>
            <Text className="text-lg text-center text-gray-600 dark:text-gray-300 mb-8">
              You've successfully completed the quiz with {score} correct answers.
            </Text>
          </View>
          <View className="px-4 mb-8">
            <Text className="text-xl font-bold text-indigo-700 dark:text-indigo-300 mb-4">Summary of Questions Asked</Text>
            {gameQuestions.map((q, index) => (
              <View key={index} className="bg-white dark:bg-gray-700 rounded-lg p-4 mb-4 shadow-sm border border-indigo-100 dark:border-indigo-800">
                <Text className="text-lg font-semibold text-indigo-700 dark:text-indigo-300 mb-2">Question {index + 1}</Text>
                <Text className="text-base text-gray-600 dark:text-gray-300 mb-2">{q.question}</Text>
                <Text className="text-base text-indigo-600 dark:text-indigo-400 mb-2">Correct Answer: {q.options[q.correct]}</Text>
                <Text className="text-base text-gray-700 dark:text-gray-200">Description: {q.describe}</Text>
              </View>
            ))}
          </View>
        </ScrollView>
        <View className="p-4 bg-indigo-50 dark:bg-gray-800">
          <TouchableHighlight
            underlayColor="#818cf8"
            onPress={handleRestart}
            className="bg-indigo-600 py-3 px-8 rounded-lg mb-4 w-full items-center"
          >
            <Text className="text-white text-lg font-bold">Try Again</Text>
          </TouchableHighlight>
          <TouchableHighlight
            underlayColor="#e0e7ff"
            onPress={handleExit}
            className="bg-indigo-100 dark:bg-indigo-900 py-3 px-8 rounded-lg w-full items-center"
          >
            <Text className="text-indigo-700 dark:text-indigo-300 text-lg font-bold">Exit</Text>
          </TouchableHighlight>
        </View>
      </View>
    );
  }

  // Loading State
  if (questions.length === 0 || options.length === 0) {
    return (
      <View className="flex-1 bg-indigo-50 dark:bg-gray-800 justify-center items-center">
        <Text className="text-lg text-indigo-600 dark:text-indigo-400">Loading questions...</Text>
      </View>
    );
  }

  // Main Quiz UI
  return (
    <View className="flex-1 bg-indigo-50 dark:bg-gray-800">
      <View className="h-14 bg-indigo-100 dark:bg-indigo-900 flex-row items-center px-4 shadow-md">
        <TouchableHighlight 
          underlayColor="#e0e7ff" 
          onPress={handleExit} 
          className="p-2 rounded-full"
        >
          <MaterialIcons name="arrow-back" size={24} color="#6366f1" />
        </TouchableHighlight>
        <Text className="text-indigo-700 dark:text-indigo-300 text-lg font-bold flex-1 ml-4">{title}</Text>
        
      </View>
      
      <View className="h-8 bg-indigo-100 dark:bg-gray-700 rounded-lg mx-4 mt-4 overflow-hidden">
        <Animated.View
          style={{
            height: '100%',
            position: 'absolute',
            left: 0,
            top: 0,
            width: progressAnim.interpolate({
              inputRange: [0, 1],
              outputRange: ['0%', '100%'],
            }),
            backgroundColor: interpolatedColor,
          }}
        />
      </View>
      
      <View className="bg-white dark:bg-gray-700 rounded-lg p-4 m-4 shadow-sm border border-indigo-100 dark:border-indigo-800">
        <View className="flex-row justify-between items-center mb-2">
          <Text className="text-sm text-indigo-600 dark:text-indigo-400">
            Question {currentQuestionIndex + 1} of {questions.length}
          </Text>
          
          <View className="flex-row items-center">
            <MaterialIcons name="stars" size={18} color="#6366f1" />
            <Text className="text-sm font-semibold text-indigo-700 dark:text-indigo-300 ml-1">
              Score: {score}/{TARGET_CORRECT_ANSWERS}
            </Text>
          </View>
        </View>
        
        <Text className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-6">
          {questions[currentQuestionIndex].question}
        </Text>
        
        <View>
          {options.map((option, index) => (
            <TouchableHighlight
              key={option.originalIndex}
              underlayColor={answerSelected ? (option.isCorrect ? "#9AE6B4" : "#FEB2B2") : "#e0e7ff"}
              onPress={() => !answerSelected && handleAnswer(option.isCorrect, index)}
              disabled={answerSelected}
              className={`p-4 rounded-lg mb-3 border ${
                !answerSelected 
                  ? "bg-indigo-50 dark:bg-gray-600 border-indigo-200 dark:border-indigo-700" 
                  : option.isCorrect 
                    ? "bg-green-100 dark:bg-green-900 border-green-300 dark:border-green-700" 
                    : "bg-red-100 dark:bg-red-900 border-red-300 dark:border-red-700"
              }`}
            >
              <Text className={`text-base ${
                !answerSelected 
                  ? "text-gray-800 dark:text-gray-200" 
                  : option.isCorrect 
                    ? "text-green-800 dark:text-green-200 font-medium" 
                    : "text-red-800 dark:text-red-200"
              }`}>
                {option.text}
              </Text>
            </TouchableHighlight>
          ))}
        </View>
      </View>
      
      {showFeedback && questions[currentQuestionIndex].describe !== options.find(opt => opt.isCorrect)?.text && (
        <View className="px-4 pb-4 flex-1">
          <TouchableOpacity
            onPress={nextQ}
            disabled={!canProceed}
            className={`rounded-lg mb-3 border ${
              !canProceed 
                ? "bg-indigo-50 dark:bg-gray-600 border-indigo-200 dark:border-indigo-700" 
                : "bg-indigo-100 dark:bg-indigo-900 border-indigo-300 dark:border-indigo-700"
            }`}
          >
            <View className="p-4">
              <Text className="text-base font-medium text-indigo-700 dark:text-indigo-300 mb-1">Explanation:</Text>
              <Text className="text-base text-gray-700 dark:text-gray-200">
                {questions[currentQuestionIndex].describe}
              </Text>
            </View>
          </TouchableOpacity>
          <Text className="text-center text-indigo-600 dark:text-indigo-400 mt-3 mb-5">
            {canProceed ? "Tap explanation to continue" : "Please wait..."}
          </Text>
        </View>
      )}
    </View>
  );
};

export default quiz;
--- END OF FILE app/quiz.js ---

--- START OF FILE app/sub.js ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar } from 'react-native'
import React from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import { Ionicons } from '@expo/vector-icons'

const Subject = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()

    const { subject, index } = JSON.parse(exp)

    return (
        <SafeAreaView className="flex-1 ">
        <StatusBar barStyle="light-content" backgroundColor="#4F46E5" />
            {/* Action Bar */}
            <View className="flex-row items-center  bg-indigo-600 py-2 px-4">
                <TouchableOpacity 
                    className="p-2"
                    onPress={() => router.back()}
                >
                    <Ionicons name="arrow-back" size={24} color="#fff" />
                </TouchableOpacity>
                <Text className="text-white font-bold text-lg ml-2">{subject.name}</Text>
                
            </View>

            {/* Lessons List */}
            <ScrollView className="p-4">
                {subject.lessons.map((e, i) => (
                    <TouchableOpacity 
                        key={i}
                        className="bg-white rounded-xl mb-3 shadow-sm"
                        onPress={() => {
                            router.push(`/lesson?exp=${JSON.stringify({
                                subject: subject,
                                subInt: index,
                                lesson: e,
                                index: i
                            })}`)
                        }}
                    >
                        <View className="flex-row items-center p-4">
                            <View className="w-8 h-8 rounded-full bg-indigo-100 items-center justify-center mr-3">
                                <Text className="font-bold text-indigo-600">{i + 1}</Text>
                            </View>
                            <View className="flex-1">
                                <Text className="text-base font-semibold text-gray-800 mb-1">{e.name}</Text>
                                {e.duration && (
                                    <View className="flex-row items-center">
                                        <Ionicons name="time-outline" size={14} color="#6B7280" />
                                        <Text className="text-sm text-gray-500 ml-1">{e.duration}</Text>
                                    </View>
                                )}
                            </View>
                            <Ionicons name="chevron-forward" size={20} color="#6B7280" />
                        </View>
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </SafeAreaView>
    )
}

export default Subject
--- END OF FILE app/sub.js ---

--- START OF FILE app/theme.js ---
const appTheme = {
    // Backgrounds
    backgroundPrimary: 'bg-gray-900',     // Main screen background
    backgroundSecondary: 'bg-gray-800',   // Headers, nav bars, cards
    backgroundTertiary: 'bg-gray-700',    // List items, secondary elements
    
    // Text
    textPrimary: 'text-gray-200',         // Main text
    textSecondary: 'text-gray-400',       // Secondary text
    textError: 'text-red-500',            // Error messages
    
    // Borders
    border: 'border-gray-700',            // Card borders
    
    // Icons
    iconActive: '#e5e7eb',                // Active icons
    iconInactive: '#9ca3af',              // Inactive icons
    
    // Status colors
    success: '#10b981',                   // Success indicators
    
    // Interactive
    touchableUnderlay: '#4b5563'          // Touchable highlight effect
  }

  export default appTheme
--- END OF FILE app/theme.js ---

--- START OF FILE app/_layout.js ---
import { View, Text } from 'react-native'
import React from 'react'
import { Stack } from 'expo-router'
import "./global.css"

const RootLayout = () => {
    return (
        <Stack screenOptions={{ headerShown: false }} />
    )
}



export default RootLayout
--- END OF FILE app/_layout.js ---

--- START OF FILE app/components/EasyMarkDown.jsx ---
import React, { useState, useEffect, useRef } from 'react';
import { View, ActivityIndicator, Text } from 'react-native';
import { WebView } from 'react-native-webview';
import * as FileSystem from 'expo-file-system';

// Define dependencies (same as in NotesPage)
const DEPENDENCIES = {
  'github-markdown.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css',
  'katex.min.css': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css',
  'showdown.min.js': 'https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js',
  'katex.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js',
  'contrib/auto-render.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js',
  'mathjax.min.js': 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
  'github.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css',
  'highlight.min.js': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js',
};

// Utility to ensure directory exists
const ensureDirectoryExists = async (dirPath) => {
  const info = await FileSystem.getInfoAsync(dirPath);
  if (!info.exists) {
    await FileSystem.makeDirectoryAsync(dirPath, { intermediates: true });
  }
};

// Utility to download files safely
const safeDownloadFile = async (url, filePath) => {
  const info = await FileSystem.getInfoAsync(filePath);
  if (!info.exists) {
    const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
    await ensureDirectoryExists(dirPath);
    const downloadResumable = FileSystem.createDownloadResumable(url, filePath);
    const { status } = await downloadResumable.downloadAsync();
    if (status < 200 || status >= 300) {
      throw new Error(`Download failed with status code: ${status}`);
    }
  }
};

const EasydownView = ({ markdown }) => {
  const webViewRef = useRef(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [webViewReady, setWebViewReady] = useState(false);
  const [markdownLoaded, setMarkdownLoaded] = useState(false);
  const [localHtmlPath, setLocalHtmlPath] = useState(null);

  const dataDir = `${FileSystem.documentDirectory}markdown-view`;

  useEffect(() => {
    const setupFiles = async () => {
      setIsLoading(true);
      setError(null);

      try {
        await ensureDirectoryExists(dataDir);

        // Download dependencies
        for (const [fileName, url] of Object.entries(DEPENDENCIES)) {
          const filePath = `${dataDir}/${fileName}`;
          await safeDownloadFile(url, filePath);
        }

        // Download KaTeX fonts
        const fontDir = `${dataDir}/fonts`;
        await ensureDirectoryExists(fontDir);
        const katexCssPath = `${dataDir}/katex.min.css`;
        const cssContent = await FileSystem.readAsStringAsync(katexCssPath, {
          encoding: FileSystem.EncodingType.UTF8,
        });
        const fontUrls = new Set();
        const urlRegex = /url\(['"]?([^'")]+)['"]?\)/g;
        let match;
        while ((match = urlRegex.exec(cssContent)) !== null) {
          if (match[1].startsWith('fonts/')) {
            fontUrls.add(match[1]);
          }
        }
        const katexBaseUrl = 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/';
        for (const relativeUrl of fontUrls) {
          const filename = relativeUrl.split('/').pop();
          const absoluteUrl = `${katexBaseUrl}${relativeUrl}`;
          const localFontPath = `${fontDir}/${filename}`;
          await safeDownloadFile(absoluteUrl, localFontPath);
        }

        // Generate static HTML
        const htmlPath = `${dataDir}/index.html`;
        const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>Markdown View</title>
    <link rel="stylesheet" href="github-markdown.min.css">
    <link rel="stylesheet" href="katex.min.css">
    <script src="showdown.min.js"></script>
    <script defer src="katex.min.js"></script>
    <script defer src="contrib/auto-render.min.js" onload="tryRenderMath()"></script>
    <script async src="mathjax.min.js"></script>
    <link rel="stylesheet" href="github.min.css">
    <script src="highlight.min.js"></script>
    <style>
    body {
        background: #ffffff;
        padding: 30px;
        margin: 0;
        display: flex;
        width: 100vw;
        font-family: arial;
        color: #000000;
    }
    .markdown-body {
        font-size: 14pt;
        max-width: 100%;
        padding-top: 30px;
        background: #ffffff;
    }
    </style>
    <script>
    function sendToRN(type, message) {
        if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({ type, message }));
        }
    }
    window.addEventListener('message', function(event) {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'updateMarkdown') {
                const md = data.markdown;
                const converter = new showdown.Converter({
                    tables: true,
                    ghCodeBlocks: true,
                    tasklists: true,
                    literalMidWordUnderscores: true,
                    extensions: []
                });
                const html = converter.makeHtml(md);
                document.getElementById('content').innerHTML = html;
                document.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));
                if (typeof renderMathInElement === 'function') {
                    renderMathInElement(document.getElementById('content'), {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false },
                        ],
                        throwOnError: false
                    });
                }
                sendToRN('log', 'Markdown processed successfully');
            }
        } catch (e) {
            sendToRN('error', \`Error processing markdown: \${e.message}\`);
        }
    });
    function tryRenderMath() {}
    window.onload = function() {
        sendToRN('log', 'WebView loaded');
        sendToRN('ready', 'WebView is ready');
    };
    </script>
</head>
<body>
    <article id="content" class="markdown-body"></article>
</body>
</html>
        `;
        await FileSystem.writeAsStringAsync(htmlPath, htmlContent, {
          encoding: FileSystem.EncodingType.UTF8,
        });
        setLocalHtmlPath(htmlPath);
      } catch (err) {
        setError(`Error setting up files: ${err.message}`);
      } finally {
        setIsLoading(false);
      }
    };

    setupFiles();
  }, []);

  useEffect(() => {
    if (webViewReady && markdown) {
      webViewRef.current?.postMessage(
        JSON.stringify({ type: 'updateMarkdown', markdown })
      );
    }
  }, [webViewReady, markdown]);

  const handleMessage = (event) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);
      if (data.type === 'ready') {
        setWebViewReady(true);
      } else if (data.type === 'log') {
        if (data.message === 'Markdown processed successfully') {
          setMarkdownLoaded(true);
        }
        console.log('WebView Log:', data.message);
      } else if (data.type === 'error') {
        console.error('WebView Error:', data.message);
        setError(data.message);
      }
    } catch (err) {
      console.error('Failed to parse WebView message:', err);
    }
  };

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#000" />
        <Text style={{ marginTop: 10 }}>Loading dependencies...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text style={{ color: '#FF5555' }}>{error}</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1 }}>
      <WebView
        ref={webViewRef}
        source={{ uri: `file://${localHtmlPath}` }}
        baseUrl={`file://${dataDir}/`}
        allowFileAccess={true}
        allowUniversalAccessFromFileURLs={true}
        allowFileAccessFromFileURLs={true}
        mixedContentMode="always"
        onMessage={handleMessage}
        style={{ flex: 1, backgroundColor: '#fff' }}
      />
      {!markdownLoaded && (
        <View
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.8)',
          }}
        >
          <ActivityIndicator size="large" color="#000" />
          <Text style={{ color: '#000', marginTop: 10 }}>
            Loading Markdown...
          </Text>
        </View>
      )}
    </View>
  );
};

export default EasydownView;
--- END OF FILE app/components/EasyMarkDown.jsx ---

--- START OF FILE app/components/MarkDownView.jsx ---
import React, { useState, useEffect, useRef } from 'react';
import { View, ActivityIndicator, Text } from 'react-native';
import { WebView } from 'react-native-webview';
import * as FileSystem from 'expo-file-system';

// Define dependencies (same as in NotesPage)
const DEPENDENCIES = {
  'github-markdown.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css',
  'katex.min.css': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css',
  'showdown.min.js': 'https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js',
  'katex.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js',
  'contrib/auto-render.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js',
  'mathjax.min.js': 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
  'github.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css',
  'highlight.min.js': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js',
};

// Utility to ensure directory exists
const ensureDirectoryExists = async (dirPath) => {
  const info = await FileSystem.getInfoAsync(dirPath);
  if (!info.exists) {
    await FileSystem.makeDirectoryAsync(dirPath, { intermediates: true });
  }
};

// Utility to download files safely
const safeDownloadFile = async (url, filePath) => {
  const info = await FileSystem.getInfoAsync(filePath);
  if (!info.exists) {
    const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
    await ensureDirectoryExists(dirPath);
    const downloadResumable = FileSystem.createDownloadResumable(url, filePath);
    const { status } = await downloadResumable.downloadAsync();
    if (status < 200 || status >= 300) {
      throw new Error(`Download failed with status code: ${status}`);
    }
  }
};

const MarkdownView = ({ markdown }) => {
  const webViewRef = useRef(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [webViewReady, setWebViewReady] = useState(false);
  const [markdownLoaded, setMarkdownLoaded] = useState(false);
  const [localHtmlPath, setLocalHtmlPath] = useState(null);

  const dataDir = `${FileSystem.documentDirectory}markdown-view`;

  useEffect(() => {
    const setupFiles = async () => {
      setIsLoading(true);
      setError(null);

      try {
        await ensureDirectoryExists(dataDir);

        // Download dependencies
        for (const [fileName, url] of Object.entries(DEPENDENCIES)) {
          const filePath = `${dataDir}/${fileName}`;
          await safeDownloadFile(url, filePath);
        }

        // Download KaTeX fonts
        const fontDir = `${dataDir}/fonts`;
        await ensureDirectoryExists(fontDir);
        const katexCssPath = `${dataDir}/katex.min.css`;
        const cssContent = await FileSystem.readAsStringAsync(katexCssPath, {
          encoding: FileSystem.EncodingType.UTF8,
        });
        const fontUrls = new Set();
        const urlRegex = /url\(['"]?([^'")]+)['"]?\)/g;
        let match;
        while ((match = urlRegex.exec(cssContent)) !== null) {
          if (match[1].startsWith('fonts/')) {
            fontUrls.add(match[1]);
          }
        }
        const katexBaseUrl = 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/';
        for (const relativeUrl of fontUrls) {
          const filename = relativeUrl.split('/').pop();
          const absoluteUrl = `${katexBaseUrl}${relativeUrl}`;
          const localFontPath = `${fontDir}/${filename}`;
          await safeDownloadFile(absoluteUrl, localFontPath);
        }

        // Generate static HTML
        const htmlPath = `${dataDir}/index.html`;
        const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>Markdown View</title>
    <link rel="stylesheet" href="github-markdown.min.css">
    <link rel="stylesheet" href="katex.min.css">
    <script src="showdown.min.js"></script>
    <script defer src="katex.min.js"></script>
    <script defer src="contrib/auto-render.min.js" onload="tryRenderMath()"></script>
    <script async src="mathjax.min.js"></script>
    <link rel="stylesheet" href="github.min.css">
    <script src="highlight.min.js"></script>
    <style>
    body {
        background: #ffffff;
        padding: 30px;
        margin: 0;
        display: flex;
        width: 100vw;
        font-family: arial;
        color: #000000;
    }
    .markdown-body {
        font-size: 14pt;
        max-width: 100%;
        padding-top: 30px;
        background: #ffffff;
    }
    </style>
    <script>
    function sendToRN(type, message) {
        if (window.ReactNativeWebView) {
            window.ReactNativeWebView.postMessage(JSON.stringify({ type, message }));
        }
    }
    window.addEventListener('message', function(event) {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'updateMarkdown') {
                const md = data.markdown;
                const converter = new showdown.Converter({
                    tables: true,
                    ghCodeBlocks: true,
                    tasklists: true,
                    literalMidWordUnderscores: true,
                    extensions: []
                });
                const html = converter.makeHtml(md);
                document.getElementById('content').innerHTML = html;
                document.querySelectorAll('pre code').forEach(block => hljs.highlightElement(block));
                if (typeof renderMathInElement === 'function') {
                    renderMathInElement(document.getElementById('content'), {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false },
                        ],
                        throwOnError: false
                    });
                }
                sendToRN('log', 'Markdown processed successfully');
            }
        } catch (e) {
            sendToRN('error', \`Error processing markdown: \${e.message}\`);
        }
    });
    function tryRenderMath() {}
    window.onload = function() {
        sendToRN('log', 'WebView loaded');
        sendToRN('ready', 'WebView is ready');
    };
    </script>
</head>
<body>
    <article id="content" class="markdown-body"></article>
</body>
</html>
        `;
        await FileSystem.writeAsStringAsync(htmlPath, htmlContent, {
          encoding: FileSystem.EncodingType.UTF8,
        });
        setLocalHtmlPath(htmlPath);
      } catch (err) {
        setError(`Error setting up files: ${err.message}`);
      } finally {
        setIsLoading(false);
      }
    };

    setupFiles();
  }, []);

  useEffect(() => {
    if (webViewReady && markdown) {
      webViewRef.current?.postMessage(
        JSON.stringify({ type: 'updateMarkdown', markdown })
      );
    }
  }, [webViewReady, markdown]);

  const handleMessage = (event) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);
      if (data.type === 'ready') {
        setWebViewReady(true);
      } else if (data.type === 'log') {
        if (data.message === 'Markdown processed successfully') {
          setMarkdownLoaded(true);
        }
        console.log('WebView Log:', data.message);
      } else if (data.type === 'error') {
        console.error('WebView Error:', data.message);
        setError(data.message);
      }
    } catch (err) {
      console.error('Failed to parse WebView message:', err);
    }
  };

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#000" />
        <Text style={{ marginTop: 10 }}>Loading dependencies...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text style={{ color: '#FF5555' }}>{error}</Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1 }}>
      <WebView
        ref={webViewRef}
        source={{ uri: `file://${localHtmlPath}` }}
        baseUrl={`file://${dataDir}/`}
        allowFileAccess={true}
        allowUniversalAccessFromFileURLs={true}
        allowFileAccessFromFileURLs={true}
        mixedContentMode="always"
        onMessage={handleMessage}
        style={{ flex: 1, backgroundColor: '#fff' }}
      />
      {!markdownLoaded && (
        <View
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: 'rgba(255, 255, 255, 0.8)',
          }}
        >
          <ActivityIndicator size="large" color="#000" />
          <Text style={{ color: '#000', marginTop: 10 }}>
            Loading Markdown...
          </Text>
        </View>
      )}
    </View>
  );
};

export default MarkdownView;
--- END OF FILE app/components/MarkDownView.jsx ---

--- START OF FILE app/components/NavBar.jsx ---
import React from 'react';
import { View, TouchableOpacity, Text } from 'react-native';
// Consolidate icon imports if possible, or keep both if needed elsewhere
import { MaterialIcons } from '@expo/vector-icons'; // Using MaterialIcons for all now
import { SafeAreaView } from 'react-native-safe-area-context';
import '../global.css'; // Ensure your global CSS supports TailwindCSS Native classes

// Define a single reusable NavItem component
const NavItem = ({ page, icon, label, current, setCurrent, IconComponent = MaterialIcons }) => {
  const isSelected = page === current;
  return (
    <TouchableOpacity
      // Use flex: 1 to distribute space equally
      // Removed horizontal padding (px-*), relying on flex: 1 for spacing
      // Kept vertical padding (py-2.5) for internal spacing
      className={`flex-1 py-2.5 flex-col items-center rounded-lg ${
        isSelected ? 'bg-indigo-100 dark:bg-indigo-900' : ''
      }`}
      onPress={() => setCurrent(page)}
      accessibilityLabel={label}
    >
      <IconComponent // Use the passed IconComponent
        name={icon}
        size={24}
        color={isSelected ? '#6366f1' : '#9ca3af'}
      />
      <Text
        className={`text-sm font-medium ${
          isSelected ? 'text-indigo-700 dark:text-indigo-300' : 'text-gray-500 dark:text-gray-400'
        }`}
        // Add numberOfLines to prevent text wrapping and ensure consistent height
        numberOfLines={1}
      >
        {label}
      </Text>
    </TouchableOpacity>
  );
};

// Main NavBar component
const NavBar = ({ current, setCurrent }) => {
  return (
    // Consider adding edges={['bottom']} if you only want bottom padding for safe area
    <SafeAreaView className="bg-white dark:bg-gray-800 shadow-md px-1" edges={['bottom']}>
      {/* Top Border */}
      <View className="h-[1px] bg-gray-200 dark:bg-gray-700" />
      {/* Container for Nav Items */}
      {/* Removed justify-around as flex: 1 on children handles distribution */}
      <View className="w-full flex-row items-center py-1 ">
        {/* Use the unified NavItem for all items */}
        <NavItem
          page="Notes"
          icon="notes" // MaterialIcons
          label="Read"
          current={current}
          setCurrent={setCurrent}
          // IconComponent={MaterialIcons} // Default, so optional
        />
        <NavItem
          page="Progress"
          icon="bar-chart" // MaterialIcons
          label="Progress"
          current={current}
          setCurrent={setCurrent}
          // IconComponent={MaterialIcons} // Default, so optional
        />
        <NavItem
          page="Learn"
          // Changed icon to a MaterialIcons equivalent for 'flash'
          icon="flash-on" // Or 'bolt' from MaterialIcons
          label="Learn"
          current={current}
          setCurrent={setCurrent}
          // IconComponent={MaterialIcons} // Default, so optional
        />
        <NavItem
          page="Routine"
          icon="calendar-today" // MaterialIcons
          label="Routine"
          current={current}
          setCurrent={setCurrent}
          // IconComponent={MaterialIcons} // Default, so optional
        />
        <NavItem
          page="Extras"
          icon="science" // MaterialIcons
          label="Tools"
          current={current}
          setCurrent={setCurrent}
          // IconComponent={MaterialIcons} // Default, so optional
        />
      </View>
    </SafeAreaView>
  );
};

export default NavBar;
--- END OF FILE app/components/NavBar.jsx ---

--- START OF FILE app/components/TestComponent.jsx ---
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableHighlight, TextInput, Image, ActivityIndicator, Alert, Animated } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import * as FileSystem from 'expo-file-system';
import * as SecureStore from 'expo-secure-store';
import { MaterialIcons } from '@expo/vector-icons';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { LinearGradient } from 'expo-linear-gradient';

const TestComponent = ({ sampleQ, isDiceRolled = false }) => {
    // State declarations
    const [activeQuestion, setActiveQuestion] = useState(null);
    const [prompt, setPrompt] = useState('');
    const [selectedImage, setSelectedImage] = useState(null);
    const [evaluations, setEvaluations] = useState({});
    const [isApiLoading, setIsApiLoading] = useState(false);
    const [errorMessage, setErrorMessage] = useState(null);
    const [apiKey, setApiKey] = useState(null);
    const [isInputFocused, setIsInputFocused] = useState(false);
    const [feedbackAnimation] = useState(new Animated.Value(1)); // Set to 1 by default so feedback is visible immediately

    // Load API key and previous evaluations on component mount
    useEffect(() => {
        const loadData = async () => {
            try {
                // Load API key
                const storedApiKey = await SecureStore.getItemAsync('google-api');
                setApiKey(storedApiKey);
                
                // Load stored evaluations for each question
                const loadedEvaluations = {};
                
                // Only load evaluations if the component is shown after dice roll or always load them
                if (sampleQ) {
                    for (let sectionIndex = 0; sectionIndex < sampleQ.length; sectionIndex++) {
                        const section = sampleQ[sectionIndex];
                        for (let questionIndex = 0; questionIndex < section.questions.length; questionIndex++) {
                            const question = section.questions[questionIndex];
                            const sanitizedKey = `eval-${sanitizeKey(question)}`;
                            
                            const storedEvaluation = await SecureStore.getItemAsync(sanitizedKey);
                            if (storedEvaluation) {
                                try {
                                    loadedEvaluations[`${sectionIndex}-${questionIndex}`] = JSON.parse(storedEvaluation);
                                } catch (e) {
                                    console.error('Error parsing stored evaluation:', e);
                                }
                            }
                        }
                    }
                    setEvaluations(loadedEvaluations);
                }
            } catch (error) {
                console.error('Error loading data:', error);
            }
        };
        
        loadData();
    }, [sampleQ]); // Removed isDiceRolled dependency so evaluations load regardless

    // Helper function to sanitize question text for use as a SecureStore key
    const sanitizeKey = (text) => {
        // Limit length and remove special characters that might cause issues in key names
        return text.slice(0, 50)
            .replace(/[^a-zA-Z0-9]/g, '-')
            .replace(/-+/g, '-')
            .toLowerCase();
    };

    // Function to pick an image from the library
    const pickImage = async () => {
        const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
        if (!permissionResult.granted) {
            alert('Permission to access camera roll is required!');
            return;
        }
        const pickerResult = await ImagePicker.launchImageLibraryAsync({
            mediaTypes: ImagePicker.MediaTypeOptions.Images,
            allowsEditing: true,
            quality: 1,
        });
        if (!pickerResult.canceled) {
            setSelectedImage(pickerResult.assets[0].uri);
        }
    };

    // Function to take a picture using the camera
    const takePicture = async () => {
        const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
        if (!permissionResult.granted) {
            alert('Permission to access camera is required!');
            return;
        }
        const pickerResult = await ImagePicker.launchCameraAsync({
            allowsEditing: true,
            quality: 1,
        });
        if (!pickerResult.canceled) {
            setSelectedImage(pickerResult.assets[0].uri);
        }
    };

    // Helper function to determine MIME type from file extension
    const getMimeType = (uri) => {
        const extension = uri.split('.').pop().toLowerCase();
        switch (extension) {
            case 'jpg':
            case 'jpeg':
                return 'image/jpeg';
            case 'png':
                return 'image/png';
            case 'gif':
                return 'image/gif';
            default:
                return 'image/jpeg';
        }
    };

    // Function to save image to FileSystem and return a unique identifier
    const saveImage = async (uri) => {
        if (!uri) return null;
        
        try {
            // Create a unique filename based on timestamp
            const timestamp = new Date().getTime();
            const newFilename = `${timestamp}.jpg`;
            const newUri = `${FileSystem.documentDirectory}images/${newFilename}`;
            
            // Ensure the images directory exists
            const dirInfo = await FileSystem.getInfoAsync(`${FileSystem.documentDirectory}images`);
            if (!dirInfo.exists) {
                await FileSystem.makeDirectoryAsync(`${FileSystem.documentDirectory}images`, { intermediates: true });
            }
            
            // Copy the image file
            await FileSystem.copyAsync({
                from: uri,
                to: newUri
            });
            
            return newUri;
        } catch (error) {
            console.error('Error saving image:', error);
            return null;
        }
    };
    
    // Function to load a saved image
    const loadSavedImage = async (uri) => {
        if (!uri) return null;
        
        try {
            const fileInfo = await FileSystem.getInfoAsync(uri);
            if (fileInfo.exists) {
                return uri;
            }
            return null;
        } catch (error) {
            console.error('Error loading saved image:', error);
            return null;
        }
    };

    // Function to handle retry for a question
    const handleRetry = async (sectionIndex, questionIndex) => {
        try {
            // Set UI state to show the answer form
            setActiveQuestion({ sectionIndex, questionIndex });
            setPrompt('');
            setSelectedImage(null);
            setErrorMessage(null);
            setIsInputFocused(false);
            
            // Delete evaluation from state
            const key = `${sectionIndex}-${questionIndex}`;
            const newEvaluations = { ...evaluations };
            delete newEvaluations[key];
            setEvaluations(newEvaluations);
            
            // Delete evaluation from SecureStore
            const currentQuestion = sampleQ[sectionIndex].questions[questionIndex];
            const sanitizedKey = `eval-${sanitizeKey(currentQuestion)}`;
            await SecureStore.deleteItemAsync(sanitizedKey);
        } catch (error) {
            console.error('Error clearing evaluation data:', error);
            setErrorMessage('Failed to reset. Please try again.');
        }
    };

    // Animation for feedback reveal - no longer needed as we show it immediately
    const animateFeedback = () => {
        // Always set to 1 to ensure visibility
        feedbackAnimation.setValue(1);
    };

    // Function to submit the answer for evaluation
    const handleSend = async () => {
        if (!activeQuestion) return;
        
        // Check if API key exists
        if (!apiKey) {
            Alert.alert(
                "API Key Missing",
                "Please set your Google API key in tools section.",
                [{ text: "OK" }]
            );
            return;
        }
        
        const { sectionIndex, questionIndex } = activeQuestion;
        const currentQuestion = sampleQ[sectionIndex].questions[questionIndex];
        const maxMarks = sampleQ[sectionIndex].marks;

        if (!prompt.trim() && !selectedImage) {
            setErrorMessage('Please provide an answer with text or an image.');
            return;
        }

        try {
            setIsApiLoading(true);
            setErrorMessage(null);
            feedbackAnimation.setValue(1); // Always visible

            const genAI = new GoogleGenerativeAI(apiKey);
            const model = genAI.getGenerativeModel({
                model: selectedImage ? 'gemini-2.0-flash' : 'gemini-2.0-flash-lite'
            });

            const fullPrompt = `Question: ${currentQuestion}\nMax Marks: ${maxMarks}\n\nUser's Answer: ${prompt}\n\nPlease evaluate the user's answer and provide a score out of ${maxMarks}. If an image is provided, consider it as part of the answer. {give only a raw json {with explanation and score as output}, explanation must be like a teacher explaining to a student. explanaton should be pain with no markdown or anything}`;
            console.log(fullPrompt)

            let imagePart = null;
            let savedImageUri = null;
            
            if (selectedImage) {
                // Save the image first
                savedImageUri = await saveImage(selectedImage);
                
                const mimeType = getMimeType(selectedImage);
                const base64Data = await FileSystem.readAsStringAsync(selectedImage, {
                    encoding: FileSystem.EncodingType.Base64,
                });
                imagePart = { inlineData: { mimeType, data: base64Data } };
            }

            const parts = [{ text: fullPrompt }];
            if (imagePart) parts.push(imagePart);

            const result = await model.generateContent({
                contents: [{ role: 'user', parts }],
            });

            const responseText = result.response.text();
            const processed = responseText.startsWith('```')
                ? responseText.substring(7, responseText.length - 3)
                : responseText;
            
            console.log(result)

            const dt = JSON.parse(processed);
            
            const newEvaluation = { 
                score: dt.score, 
                explanation: dt.explanation,
                userAnswer: prompt,
                timestamp: new Date().toISOString(),
                savedImageUri: savedImageUri // Save the image URI
            };
            
            // Update state
            setEvaluations(prev => ({ ...prev, [`${sectionIndex}-${questionIndex}`]: newEvaluation }));
            
            // Store in SecureStore for persistence
            const sanitizedKey = `eval-${sanitizeKey(currentQuestion)}`;
            await SecureStore.setItemAsync(sanitizedKey, JSON.stringify(newEvaluation));
            
            // No animation delay needed, show immediately
            animateFeedback();
            
        } catch (err) {
            setErrorMessage(err.message || 'An error occurred. Please try again.');
            alert(err.message)
        } finally {
            setIsApiLoading(false);
            setActiveQuestion(null);
            setPrompt('');
            setSelectedImage(null);
            setIsInputFocused(false);
        }
    };

    // Gamified progress bar component with dynamic circles based on max score
    const GameProgressBar = ({ score, maxScore }) => {
        // Calculate percentage for color determination
        const percentage = (score / maxScore) * 100;

        // Determine color based on score percentage
        const getProgressColor = () => {
            if (percentage < 40) return ['#FF4D4D', '#FF8C8C']; // Red gradient for low scores
            if (percentage < 70) return ['#FFD700', '#FFF06A']; // Gold gradient for medium scores
            return ['#32CD32', '#7AFF7A']; // Green gradient for high scores
        };

        // Create array of circles based on maxScore
        const circles = Array.from({ length: maxScore }, (_, i) => i + 1);

        return (
            <View style={{
                position: 'absolute',
                top: 8,
                right: 8,
                flexDirection: 'row',
                flexWrap: 'wrap',
                maxWidth: maxScore > 5 ? 100 : 80,
                justifyContent: 'flex-end',
                zIndex: 10,
                borderRadius: 12,
                padding: 4,
                backgroundColor: 'rgba(0,0,0,0.1)',
            }}>
                {circles.map((circle) => {
                    // Determine if this circle should be filled based on score
                    const isActive = circle <= score;
                    const colorGradient = getProgressColor();

                    return (
                        <View
                            key={circle}
                            style={{
                                height: 10,
                                width: 10,
                                borderRadius: 5,
                                margin: 2,
                                backgroundColor: isActive ? colorGradient[0] : 'rgba(255,255,255,0.3)',
                                shadowColor: isActive ? colorGradient[0] : 'transparent',
                                shadowOffset: { width: 0, height: 0 },
                                shadowOpacity: isActive ? 0.7 : 0,
                                shadowRadius: isActive ? 2 : 0,
                                borderWidth: isActive ? 0 : 1,
                                borderColor: 'rgba(0,0,0,0.1)',
                            }}
                        />
                    );
                })}
            </View>
        );
    };
    
    // Format the date for display
    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return date.toLocaleString();
    };
    
    // Render logic
    if (sampleQ.length === 0) {
        return (
            <View className="flex items-center justify-center p-4">
                <Text className="text-gray-500">No challenges available!</Text>
            </View>
        );
    }

    // Only show the component if isDiceRolled is true
    if (!isDiceRolled) {
        return (
            <View className="flex items-center justify-center p-4">
                <Text className="text-gray-500">Roll the dice to start challenges!</Text>
            </View>
        );
    }

    return (
        <View className="bg-indigo-50 dark:bg-gray-800 rounded-xl  shadow-md">
            {sampleQ.map((section, sectionIndex) => (
                <View key={sectionIndex} className="mb-6">
                    <LinearGradient
                        colors={['#4f46e5', '#6366f1']}
                        start={{ x: 0, y: 0 }}
                        end={{ x: 1, y: 0 }}
                        className="flex-row items-center mb-3 p-3 rounded-lg shadow-sm"
                    >
                        <MaterialIcons name="school" size={24} color="#ffffff" />
                        <Text className="text-lg font-bold text-white ml-2">
                            {section.name}
                        </Text>
                    </LinearGradient>

                    {section.questions.map((question, questionIndex) => {
                        const key = `${sectionIndex}-${questionIndex}`;
                        const evaluation = evaluations[key];
                        return (
                            <View key={questionIndex} className="mb-4 p-4 bg-white dark:bg-gray-700 rounded-lg shadow-md border border-indigo-100 dark:border-indigo-800">
                                <Text className="text-gray-800 dark:text-gray-200 font-medium mb-3">{question}</Text>

                                {evaluation ? (
                                    <Animated.View 
                                        style={{ opacity: 1 }} // Always fully visible
                                        className="rounded-lg relative overflow-hidden"
                                    >
                                        <LinearGradient
                                            colors={['#f5f3ff', '#e0e7ff']}
                                            className="p-4 rounded-lg dark:opacity-90"
                                        >
                                            {/* Progress indicator positioned in top right */}
                                            <GameProgressBar score={evaluation.score} maxScore={section.marks} />
                                            
                                            {/* Score display */}
                                            <View className="items-center justify-center mb-3">
                                                <View className="bg-indigo-600 px-4 py-1 rounded-full">
                                                    <Text className="text-white font-bold">
                                                        Score: {evaluation.score}/{section.marks}
                                                    </Text>
                                                </View>
                                            </View>

                                            {/* User answer section with gamified UI */}
                                            <View className="bg-white dark:bg-gray-800 p-4 rounded-lg mb-3 shadow-sm border border-indigo-100 dark:border-indigo-700">
                                                <View className="flex-row items-center mb-2">
                                                    <MaterialIcons name="question-answer" size={20} color="#6366f1" />
                                                    <Text className="text-indigo-700 dark:text-indigo-300 font-bold ml-2">Your Answer</Text>
                                                </View>
                                                
                                                <Text className="text-gray-700 dark:text-gray-300 mb-3">{evaluation.userAnswer}</Text>
                                                
                                                {/* Display saved image if available */}
                                                {evaluation.savedImageUri && (
                                                    <View className="mt-2 border border-indigo-200 dark:border-indigo-700 rounded-lg ">
                                                        <Image 
                                                            source={{ uri: evaluation.savedImageUri }} 
                                                            style={{ width: '100%',height:"150" }} 
                                                            className="rounded" 
                                                        />
                                                    </View>
                                                )}
                                            </View>
                                            
                                            {/* Feedback section with improved UI */}
                                            <View className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-indigo-100 dark:border-indigo-700">
                                                <View className="flex-row items-center mb-2">
                                                    <MaterialIcons name="psychology" size={20} color="#6366f1" />
                                                    <Text className="text-indigo-700 dark:text-indigo-300 font-bold ml-2">Feedback</Text>
                                                </View>
                                                <Text className="text-gray-700 dark:text-gray-300">{evaluation.explanation}</Text>
                                            </View>
                                            
                                            {evaluation.timestamp && (
                                                <Text className="text-gray-500 dark:text-gray-400 text-xs text-center mt-3">
                                                    Answered on: {formatDate(evaluation.timestamp)}
                                                </Text>
                                            )}
                                            
                                            <TouchableHighlight
                                                onPress={() => handleRetry(sectionIndex, questionIndex)}
                                                underlayColor="#e0e7ff"
                                                className="bg-indigo-500 hover:bg-indigo-600 p-2 rounded-lg mt-3 w-1/3 self-end shadow"
                                            >
                                                <View className="flex-row items-center justify-center">
                                                    <MaterialIcons name="refresh" size={16} color="#ffffff" />
                                                    <Text className="text-white text-center font-medium ml-1">Retry</Text>
                                                </View>
                                            </TouchableHighlight>
                                        </LinearGradient>
                                    </Animated.View>
                                ) : activeQuestion && activeQuestion.sectionIndex === sectionIndex && activeQuestion.questionIndex === questionIndex ? (
                                    <View>
                                        <View className="flex relative">
                                            {/* Only show image and camera buttons when no image is selected AND input is not focused */}
                                            {!selectedImage && !isInputFocused && (
                                                <View className="flex-row w-fit mb-2 right-2 top-3 z-10 mr-1 absolute">
                                                    <TouchableHighlight
                                                        onPress={pickImage}
                                                        underlayColor="#e0e7ff"
                                                        className="rounded-full mr-2 p-1 bg-indigo-100 dark:bg-indigo-800"
                                                    >
                                                        <MaterialIcons name="image" size={20} color="#6366f1" />
                                                    </TouchableHighlight>
                                                    <TouchableHighlight
                                                        onPress={takePicture}
                                                        underlayColor="#e0e7ff"
                                                        className="rounded-full p-1 bg-indigo-100 dark:bg-indigo-800"
                                                    >
                                                        <MaterialIcons name="camera-alt" size={20} color="#6366f1" />
                                                    </TouchableHighlight>
                                                </View>
                                            )}
                                            <View className="w-full z-0">
                                                <TextInput
                                                    className="bg-indigo-50 dark:bg-gray-600 text-gray-800 dark:text-gray-200 p-3 rounded-lg mb-2 w-full z-0 border border-indigo-200 dark:border-indigo-700"
                                                    placeholder="Type your answer here..."
                                                    placeholderTextColor="#9ca3af"
                                                    value={prompt}
                                                    onChangeText={setPrompt}
                                                    onFocus={() => setIsInputFocused(true)}
                                                    onBlur={() => setIsInputFocused(false)}
                                                    multiline
                                                />
                                            </View>
                                        </View>

                                        {selectedImage && (
                                            <View className="mt-2 relative border border-indigo-200 dark:border-indigo-700 rounded-lg overflow-hidden shadow">
                                                <Image source={{ uri: selectedImage }} style={{ width: '100%', height: 150 }} className="rounded" />
                                                <TouchableHighlight
                                                    onPress={() => setSelectedImage(null)}
                                                    underlayColor="#e0e7ff"
                                                    className="rounded-full bg-indigo-100 dark:bg-indigo-700 absolute right-1 top-2 mr-1 p-1"
                                                >
                                                    <MaterialIcons name="delete" size={20} color="#6366f1" />
                                                </TouchableHighlight>
                                            </View>
                                        )}

                                        <TouchableHighlight
                                            onPress={handleSend}
                                            underlayColor="#818cf8"
                                            className={`bg-indigo-600 p-3 rounded-lg mt-3 shadow ${isApiLoading ? 'opacity-50' : ''}`}
                                            disabled={isApiLoading || (!prompt.trim() && !selectedImage)}
                                        >
                                            <Text className="text-white text-center font-medium">Submit Answer</Text>
                                        </TouchableHighlight>

                                        {isApiLoading && (
                                            <View className="flex items-center justify-center mt-4">
                                                <Text className="text-indigo-600 dark:text-indigo-400 mb-2">Evaluating...</Text>
                                                <ActivityIndicator size="large" color="#6366f1" />
                                            </View>
                                        )}

                                        {errorMessage && (
                                            <View className="bg-red-50 dark:bg-red-900 p-2 rounded-lg mt-2 border border-red-200 dark:border-red-700">
                                                <Text className="text-red-600 dark:text-red-300">{errorMessage}</Text>
                                            </View>
                                        )}
                                    </View>
                                ) : (
                                    <TouchableHighlight
                                        onPress={() => {
                                            setActiveQuestion({ sectionIndex, questionIndex });
                                            setPrompt('');
                                            setSelectedImage(null);
                                            setErrorMessage(null);
                                            setIsInputFocused(false);
                                        }}
                                        underlayColor="#e0e7ff"
                                        className="bg-indigo-500 hover:bg-indigo-600 p-3 rounded-lg shadow"
                                    >
                                        <Text className="text-white text-center font-medium">Answer</Text>
                                    </TouchableHighlight>
                                )}
                            </View>
                        );
                    })}
                </View>
            ))}
        </View>
    );
};

export default TestComponent;
--- END OF FILE app/components/TestComponent.jsx ---

--- START OF FILE app/components/cog/ApiKeyManager.jsx ---
import React, { useState } from 'react';
import { View, Text, TouchableHighlight, Modal, TextInput, Linking } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import * as SecureStore from 'expo-secure-store';
import { MaterialIcons } from '@expo/vector-icons';

const ApiKeyManager = ({
  isVisible,
  onClose,
  savedApiKey,
  onApiKeySaved
}) => {
  const [apiKey, setApiKey] = useState('');

  const saveApiKey = async () => {
    try {
      if (apiKey.trim()) {
        await SecureStore.setItemAsync('google-api', apiKey.trim());
        onApiKeySaved(apiKey.trim());
        setApiKey('');
        onClose();
        alert('API key saved successfully!');
      } else {
        alert('Please enter a valid API key');
      }
    } catch (err) {
      console.error('Failed to save API key:', err);
      alert('Failed to save API key. Please try again.');
    }
  };

  const getApiKey = () => {
    Linking.openURL('https://aistudio.google.com/app/apikey');
  };

  return (
    <Modal
      animationType="slide"
      transparent={false}
      visible={isVisible}
      onRequestClose={onClose}
    >
      <SafeAreaView className="flex-1 bg-indigo-50 dark:bg-gray-900">
        <View className="h-14 bg-indigo-600 dark:bg-indigo-800 flex-row items-center px-4 shadow-md">
          <TouchableHighlight
            underlayColor="#4338CA"
            onPress={onClose}
            className="p-2 rounded-full"
          >
            <MaterialIcons name="close" size={24} color="#E0E7FF" />
          </TouchableHighlight>
          <Text className="text-indigo-50 text-lg font-bold flex-1 ml-4">
            Google API Key
          </Text>
        </View>

        <View className="flex-1 p-4">
          <View className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow mb-4">
            <Text className="text-gray-800 dark:text-gray-200 font-semibold mb-1">
              Current Status
            </Text>
            <View className="flex-row items-center">
              <MaterialIcons
                name={savedApiKey ? "check-circle" : "error"}
                size={20}
                color={savedApiKey ? "#10b981" : "#ef4444"}
              />
              <Text className={`ml-2 ${savedApiKey ? "text-green-500" : "text-red-500"}`}>
                {savedApiKey ? "API Key is configured" : "No API Key set"}
              </Text>
            </View>
          </View>

          <View className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow mb-4">
            <Text className="text-gray-800 dark:text-gray-200 font-semibold mb-4">
              Enter Google API Key
            </Text>
            <TextInput
              className="border border-gray-300 dark:border-gray-600 rounded-lg p-3 mb-4 text-gray-800 dark:text-gray-200 bg-gray-50 dark:bg-gray-700"
              placeholder="Paste your API key here"
              value={apiKey}
              onChangeText={setApiKey}
              placeholderTextColor="#9ca3af"
              secureTextEntry={true}
            />
            <TouchableHighlight
              underlayColor="#4338CA"
              onPress={saveApiKey}
              className="bg-indigo-600 dark:bg-indigo-700 rounded-lg p-3 items-center"
            >
              <Text className="text-white font-semibold">Save API Key</Text>
            </TouchableHighlight>
          </View>

          <TouchableHighlight
            underlayColor="#E0E7FF"
            onPress={getApiKey}
            className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow flex-row items-center justify-between"
          >
            <View>
              <Text className="text-gray-800 dark:text-gray-200 font-semibold">
                Get Google API Key
              </Text>
              <Text className="text-gray-600 dark:text-gray-300 mt-1">
                Opens Google AI Studio website
              </Text>

              <MaterialIcons name="open-in-new" size={24} color="#6366f1" />
            </View>
          </TouchableHighlight>
        </View>
      </SafeAreaView>
    </Modal>
  );
};

export default ApiKeyManager;
--- END OF FILE app/components/cog/ApiKeyManager.jsx ---

--- START OF FILE app/components/cog/CustomProgressBar.jsx ---
import { View } from 'react-native';
import React from 'react';

const CustomProgressBar = ({ progress, width, height }) => {
  // Clamp progress between 0 and 1 for safety
  const clampedProgress = Math.min(Math.max(progress, 0), 1);

  // Determine the color class based on progress

  const filledClass =
  clampedProgress < 0.1 ? 'bg-red-500'     // 10-20%
  : clampedProgress < 0.3 ? 'bg-orange-500' // 30-40%
  : clampedProgress < 0.5 ? 'bg-yellow-500' // 50-60%
  : clampedProgress < 0.7 ? 'bg-lime-500'  // 70-80%
  : clampedProgress < 0.9 ? 'bg-green-500'  // 80-90%
  : 'bg-green-500';


  // Calculate border radius for pill shape
  const borderRadius = height / 2;

  // Style for the inner bar, with dynamic width and conditional rounding
  const innerStyle = {
    width: `${clampedProgress * 100}%`,
    height: '100%',
    borderTopLeftRadius: borderRadius,
    borderBottomLeftRadius: borderRadius,
    ...(clampedProgress === 1 && {
      borderTopRightRadius: borderRadius,
      borderBottomRightRadius: borderRadius,
    }),
  };

  return (
    <View
      className="bg-gray-200 flex-1"
      style={{ height, borderRadius, overflow: 'hidden' }}
    >
      <View className={filledClass} style={innerStyle} />
    </View>
  );
};

export default CustomProgressBar;
--- END OF FILE app/components/cog/CustomProgressBar.jsx ---

--- START OF FILE app/components/cog/QuizComponent.jsx ---
import React from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableHighlight,
  Image,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { MaterialIcons } from '@expo/vector-icons'; // Assuming you're using Expo

const QuizComponent = ({
  sampleQ,
  currentSectionIndex,
  setCurrentSectionIndex,
  currentQuestionIndex,
  setCurrentQuestionIndex,
  prompt,
  setPrompt,
  selectedImage,
  setSelectedImage,
  isApiLoading,
  errorMessage,
  setErrorMessage,
  response,
  setResponse,
  pickImage, // Function to handle image picking
  takePicture, // Function to handle camera
  handleSend, // Function to handle submission
}) => {
  return (
    <View className="p-4 bg-gray-800 rounded-lg mb-4 border border-gray-700">
      {/* Display Section and Question Info */}
      <Text className="text-xl font-semibold text-gray-200 mb-3">
        {sampleQ[currentSectionIndex].name} - Question {currentQuestionIndex + 1}
      </Text>
      <Text className="text-gray-200 mb-2">
        {sampleQ[currentSectionIndex].questions[currentQuestionIndex]}
      </Text>
      <Text className="text-gray-400 mb-4">
        Max Marks: {sampleQ[currentSectionIndex].marks}
      </Text>

      {/* User Answer Input */}
      <TextInput
        className="bg-gray-700 text-gray-200 p-2 rounded mb-2"
        placeholder="Enter your answer"
        placeholderTextColor="#9ca3af"
        value={prompt}
        onChangeText={setPrompt}
        multiline
      />

      {/* Image Picker and Camera Buttons */}
      <View className="flex-row justify-end mb-2">
        <TouchableHighlight onPress={pickImage} underlayColor="#4b5563" className="p-2">
          <MaterialIcons name="image" size={24} color="#e5e7eb" />
        </TouchableHighlight>
        <TouchableHighlight onPress={takePicture} underlayColor="#4b5563" className="p-2 ml-2">
          <MaterialIcons name="camera-alt" size={24} color="#e5e7eb" />
        </TouchableHighlight>
      </View>

      {/* Display Selected Image and Clear Button */}
      {selectedImage && (
        <View className="mt-2">
          <Image source={{ uri: selectedImage }} style={{ width: 200, height: 200 }} className="rounded" />
          <TouchableHighlight
            onPress={() => setSelectedImage(null)}
            underlayColor="#4b5563"
            className="mt-2 p-2 bg-red-600 rounded"
          >
            <Text className="text-white text-center">Clear Image</Text>
          </TouchableHighlight>
        </View>
      )}

      {/* Submit Button */}
      <TouchableHighlight
        onPress={handleSend}
        underlayColor="#4b5563"
        className={`bg-blue-600 p-2 rounded ${isApiLoading ? 'opacity-50' : ''}`}
        disabled={isApiLoading || (!prompt.trim() && !selectedImage)}
      >
        <Text className="text-white text-center">Submit Answer</Text>
      </TouchableHighlight>

      {/* Loading Indicator */}
      {isApiLoading && <ActivityIndicator size="large" color="white" className="mt-4" />}

      {/* Error Message */}
      {errorMessage && <Text className="text-red-500 mt-2">{errorMessage}</Text>}

      {/* Response Display */}
      {response && (
        <ScrollView className="mt-4 p-2 bg-gray-700 rounded" style={{ maxHeight: 200 }}>
          <Text className="text-gray-200">{response}</Text>
        </ScrollView>
      )}

      {/* Navigation Buttons */}
      <View className="flex-row justify-between mt-4">
        <TouchableHighlight
          onPress={() => {
            if (currentQuestionIndex > 0) {
              setCurrentQuestionIndex(currentQuestionIndex - 1);
              setPrompt('');
              setSelectedImage(null);
              setResponse(null);
              setErrorMessage(null);
            } else if (currentSectionIndex > 0) {
              setCurrentSectionIndex(currentSectionIndex - 1);
              setCurrentQuestionIndex(sampleQ[currentSectionIndex - 1].questions.length - 1);
              setPrompt('');
              setSelectedImage(null);
              setResponse(null);
              setErrorMessage(null);
            }
          }}
          underlayColor="#4b5563"
          className={`p-2 bg-gray-600 rounded ${
            currentSectionIndex === 0 && currentQuestionIndex === 0 ? 'opacity-50' : ''
          }`}
          disabled={currentSectionIndex === 0 && currentQuestionIndex === 0}
        >
          <Text className="text-white">Previous</Text>
        </TouchableHighlight>
        <TouchableHighlight
          onPress={() => {
            if (currentQuestionIndex < sampleQ[currentSectionIndex].questions.length - 1) {
              setCurrentQuestionIndex(currentQuestionIndex + 1);
              setPrompt('');
              setSelectedImage(null);
              setResponse(null);
              setErrorMessage(null);
            } else if (currentSectionIndex < sampleQ.length - 1) {
              setCurrentSectionIndex(currentSectionIndex + 1);
              setCurrentQuestionIndex(0);
              setPrompt('');
              setSelectedImage(null);
              setResponse(null);
              setErrorMessage(null);
            }
          }}
          underlayColor="#4b5563"
          className={`p-2 bg-gray-600 rounded ${
            currentSectionIndex === sampleQ.length - 1 &&
            currentQuestionIndex === sampleQ[currentSectionIndex].questions.length - 1
              ? 'opacity-50'
              : ''
          }`}
          disabled={
            currentSectionIndex === sampleQ.length - 1 &&
            currentQuestionIndex === sampleQ[currentSectionIndex].questions.length - 1
          }
        >
          <Text className="text-white">Next</Text>
        </TouchableHighlight>
      </View>
    </View>
  );
};

export default QuizComponent;
--- END OF FILE app/components/cog/QuizComponent.jsx ---

--- START OF FILE app/components/progress/EditDialog.jsx ---
import React, { useEffect, useState } from 'react';
import { Modal, View, Text, TouchableOpacity, FlatList, StyleSheet } from 'react-native';
import { MaterialIcons } from '@expo/vector-icons';

const EditDialog = ({ open, onClose, courses, data, onSave }) => {
  const [selectedCourses, setSelectedCourses] = useState(data || []);

  // Toggle course selection
  const handleToggle = (course) => {
    if (!has(selectedCourses, course)) {
      setSelectedCourses([...selectedCourses, course]);
    } else {
      setSelectedCourses(selectedCourses.filter(c => c.name !== course.name));
    }
  };

  // Update selectedCourses when data prop changes
  useEffect(() => {
    setSelectedCourses(data || []);
  }, [data]);

  // Check if a course is selected
  const has = (courseList, course) => courseList.some(c => c.name === course.name);

  // Save changes and close dialog
  const handleSave = () => {
    onSave(selectedCourses);
    onClose();
  };

  // Render each course item
  const renderCourseItem = ({ item }) => (
    <TouchableOpacity
      onPress={() => handleToggle(item)}
      style={styles.courseItem}
    >
      <View
        style={[
          styles.checkbox,
          has(selectedCourses, item) ? styles.checkboxSelected : styles.checkboxUnselected
        ]}
      >
        {has(selectedCourses, item) && (
          <MaterialIcons name="check" size={18} color="#4338CA" />
        )}
      </View>
      <Text style={styles.courseText}>{item.name}</Text>
    </TouchableOpacity>
  );

  return (
    <Modal
      visible={open}
      transparent={true}
      animationType="slide"
      onRequestClose={onClose}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.dialogContainer}>
          {/* Dialog Title */}
          <View style={styles.titleContainer}>
            <MaterialIcons name="edit" size={22} color="#E0E7FF" />
            <Text style={styles.titleText}>Edit Courses</Text>
          </View>

          {/* Course List */}
          <FlatList
            data={courses}
            renderItem={renderCourseItem}
            keyExtractor={(item, index) => index.toString()}
            style={styles.courseList}
          />

          {/* Dialog Actions */}
          <View style={styles.actionContainer}>
            <TouchableOpacity
              onPress={onClose}
              style={styles.closeButton}
            >
              <Text style={styles.closeButtonText}>Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              onPress={handleSave}
              style={styles.saveButton}
            >
              <Text style={styles.saveButtonText}>Save</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  modalOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
  },
  dialogContainer: {
    width: '85%',
    backgroundColor: '#4338CA', // indigo-800
    borderRadius: 12,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(224, 231, 255, 0.2)', // indigo-100/20
    paddingBottom: 8,
  },
  titleText: {
    color: '#ffffff',
    fontSize: 20,
    fontWeight: 'bold',
    marginLeft: 8,
  },
  courseList: {
    maxHeight: 240,
  },
  courseItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(224, 231, 255, 0.1)', // indigo-100/10
  },
  checkbox: {
    width: 24,
    height: 24,
    borderRadius: 4,
    marginRight: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
  checkboxSelected: {
    backgroundColor: '#ffffff',
    borderWidth: 2,
    borderColor: '#ffffff',
  },
  checkboxUnselected: {
    borderWidth: 2,
    borderColor: '#A5B4FC', // indigo-300
    backgroundColor: 'transparent',
  },
  courseText: {
    color: '#E0E7FF', // indigo-100
    fontSize: 16,
  },
  actionContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 16,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: 'rgba(224, 231, 255, 0.2)', // indigo-100/20
  },
  closeButton: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    marginRight: 12,
  },
  closeButtonText: {
    color: '#A5B4FC', // indigo-300
    fontSize: 16,
    fontWeight: '500',
  },
  saveButton: {
    backgroundColor: '#E0E7FF', // indigo-100
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderRadius: 8,
  },
  saveButtonText: {
    color: '#4338CA', // indigo-800
    fontSize: 16,
    fontWeight: '600',
  },
});

export default EditDialog;
--- END OF FILE app/components/progress/EditDialog.jsx ---

--- START OF FILE app/components/progress/ImportExportDialog.jsx ---
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, Modal, StyleSheet, ActivityIndicator } from 'react-native';
import { getDatabase, ref, set, get } from 'firebase/database';
import Toast from 'react-native-toast-message';
import { MaterialIcons } from '@expo/vector-icons';
import * as SecureStore from 'expo-secure-store'; // For offline storage

const ImportExportDialog = ({ open, onClose, firebaseApp, onImportData }) => {
  const [userId, setUserId] = useState('');
  const [loading, setLoading] = useState(false);

  const handleImport = async () => {
    if (!userId.trim()) {
      Toast.show({
        type: 'error',
        text1: 'Error',
        text2: 'Please enter a valid user ID',
      });
      return;
    }

    setLoading(true);
    try {
      const db = getDatabase(firebaseApp);
      const progressRef = ref(db, `progress-${userId}`);
      const snapshot = await get(progressRef);

      if (snapshot.exists()) {
        const progressData = snapshot.val();
        onImportData(progressData);
        Toast.show({
          type: 'success',
          text1: 'Success',
          text2: 'Progress data imported successfully',
        });
        onClose();
      } else {
        Toast.show({
          type: 'error',
          text1: 'Error',
          text2: 'No progress data found for this user ID',
        });
      }
    } catch (error) {
      console.error('Import error:', error);
      Toast.show({
        type: 'error',
        text1: 'Error',
        text2: 'Failed to import progress data',
      });
    } finally {
      setLoading(false);
    }
  };

  const handleExport = async () => {
    if (!userId.trim()) {
      Toast.show({
        type: 'error',
        text1: 'Error',
        text2: 'Please enter a valid user ID',
      });
      return;
    }

    setLoading(true);
    try {
      const storedData = await SecureStore.getItemAsync('progressData');
      if (storedData) {
        const db = getDatabase(firebaseApp);
        const progressRef = ref(db, `progress-${userId}`);
        await set(progressRef, JSON.parse(storedData));
        Toast.show({
          type: 'success',
          text1: 'Success',
          text2: 'Progress data exported successfully',
        });
        onClose();
      } else {
        Toast.show({
          type: 'error',
          text1: 'Error',
          text2: 'No local progress data found to export',
        });
      }
    } catch (error) {
      console.error('Export error:', error);
      Toast.show({
        type: 'error',
        text1: 'Error',
        text2: 'Failed to export progress data',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal
      visible={open}
      transparent={true}
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.centeredView}>
        <View style={styles.modalView}>
          <View style={styles.titleContainer}>
            <MaterialIcons name="import-export" size={24} color="#E0E7FF" />
            <Text style={styles.modalTitle}>Import/Export Progress</Text>
          </View>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>User ID:</Text>
            <TextInput
              style={styles.input}
              value={userId}
              onChangeText={setUserId}
              placeholder="Enter user ID"
              placeholderTextColor="#A5B4FC"
              selectionColor="#818CF8"
            />
          </View>
          
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={[styles.button, styles.importButton, loading && styles.disabledButton]}
              onPress={handleImport}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <>
                  <MaterialIcons name="cloud-download" size={18} color="#ffffff" style={styles.buttonIcon} />
                  <Text style={styles.buttonText}>Import</Text>
                </>
              )}
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[styles.button, styles.exportButton, loading && styles.disabledButton]}
              onPress={handleExport}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <>
                  <MaterialIcons name="cloud-upload" size={18} color="#ffffff" style={styles.buttonIcon} />
                  <Text style={styles.buttonText}>Export</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
          
          <TouchableOpacity
            style={styles.closeButton}
            onPress={onClose}
          >
            <Text style={styles.closeButtonText}>Cancel</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  centeredView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
  },
  modalView: {
    width: '85%',
    backgroundColor: '#4338CA', // indigo-800
    borderRadius: 16,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 3,
    },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
    paddingBottom: 12,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(224, 231, 255, 0.2)', // indigo-100/20
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#E0E7FF', // indigo-100
    marginLeft: 8,
  },
  inputContainer: {
    width: '100%',
    marginBottom: 20,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#E0E7FF', // indigo-100
  },
  input: {
    width: '100%',
    height: 50,
    borderWidth: 1,
    borderColor: '#818CF8', // indigo-400
    borderRadius: 10,
    paddingHorizontal: 15,
    fontSize: 16,
    backgroundColor: 'rgba(224, 231, 255, 0.1)', // indigo-100/10
    color: '#ffffff',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
    marginBottom: 15,
  },
  button: {
    width: '48%',
    height: 50,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
  },
  buttonIcon: {
    marginRight: 6,
  },
  importButton: {
    backgroundColor: '#6366F1', // indigo-500
  },
  exportButton: {
    backgroundColor: '#55AA22', // custom green that fits with the theme
  },
  disabledButton: {
    opacity: 0.6,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  closeButton: {
    width: '100%',
    height: 50,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(224, 231, 255, 0.15)', // indigo-100/15
    borderWidth: 1,
    borderColor: 'rgba(224, 231, 255, 0.3)', // indigo-100/30
  },
  closeButtonText: {
    color: '#E0E7FF', // indigo-100
    fontSize: 16,
    fontWeight: '600',
  },
});

export default ImportExportDialog;
--- END OF FILE app/components/progress/ImportExportDialog.jsx ---

--- START OF FILE app/components/progress/LearningCard.jsx ---
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { MaterialIcons } from '@expo/vector-icons';

const LearningCard = ({ title, progress, onClick, isActive }) => {
  const getProgressColor = (percentage) => {
    if (percentage < 0 || percentage > 100) return '#94A3B8'; // Slate color for invalid values
        
        // Create a color scale that avoids the indigo/purple spectrum used in backgrounds
        if (percentage < 25) {
            // Low progress - red
            return '#7bed9f'; // Tailwind red-500
        } else if (percentage < 50) {
            // Some progress - yellow/amber
            return '#2ed573'; // Tailwind amber-500
        } else if (percentage < 75) {
            // Good progress - teal (avoiding pure green which might be hard to read)
            return '#1e90ff'; // Tailwind teal-500
        } else {
            // Excellent progress - cyan (avoiding blue/indigo used in the UI)
            return '#1e90ff'; // Tailwind cyan-500
        }
  };

  const progressColor = getProgressColor(progress);

  return (
    <TouchableOpacity
      onPress={onClick}
      activeOpacity={0.7}
      className="bg-indigo-800 rounded-lg p-3 mb-2 mx-1 shadow-sm"
    >
      <View className="flex-row items-center justify-between">
        <View className="flex-row items-center gap-3 w-fit max-w-[80%]">
          <MaterialIcons name="book" size={20} color="#E0E7FF" />
          <Text className="text-white font-semibold text-base " numberOfLines={2}>
            {title || 'Untitled'}
          </Text>
        </View>
        <View className="flex-row items-center gap-2">
          <MaterialIcons
            name="chevron-right"
            size={22}
            color="white"
            style={{ transform: [{ rotate: isActive ? '90deg' : '0deg' }] }}
          />
        </View>
      </View>
      <View className="mt-3">
        <View className="h-2 bg-indigo-300/30 dark:bg-indigo-900/50 rounded-full overflow-hidden">
          <View
            className="h-full"
            style={{ 
              width: `${parseInt(progress) || 0}%`,
              backgroundColor: progressColor
            }}
          />
        </View>
        <Text className="text-xs text-indigo-100 mt-1 text-right">
          {parseInt(progress) || 0}%
        </Text>
      </View>
    </TouchableOpacity>
  );
};

export default LearningCard;
--- END OF FILE app/components/progress/LearningCard.jsx ---

--- START OF FILE app/components/progress/ProgressStats.jsx ---
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { AnimatedCircularProgress } from 'react-native-circular-progress';

const ProgressStats = ({ stats, onAddTask }) => {
    return (
        <View className="p-2.5 gap-3">
            {/* First Stat (Overall Progress) */}
            {stats.length > 0 && (
                <View className="flex-1 w-full bg-indigo-800  rounded-lg p-4 mx-auto shadow-sm">
                    <View className="items-center gap-3">
                        <AnimatedCircularProgress
                            size={80}
                            width={6}
                            fill={stats[0].value}
                            tintColor={stats[0].color}
                            backgroundColor="#E0E7FF"
                            rotation={0}
                        >
                            {() => (
                                <Text
                                    className="text-base font-bold"
                                    style={{ color: 'white' }}
                                >
                                    {`${stats[0].value}%`}
                                </Text>
                            )}
                        </AnimatedCircularProgress>
                        <View className="items-center">
                            <Text className="text-white text-lg font-semibold text-center">
                                {stats[0].title}
                            </Text>
                            {stats[0].description && (
                                <Text className="text-indigo-100 text-sm text-center mt-1">
                                    {stats[0].description}
                                </Text>
                            )}
                        </View>
                    </View>
                </View>
            )}

            {/* Remaining Stats in Three Columns */}
            <View className="flex flex-row gap-2 flex-wrap justify-between">
                {stats.slice(1).map((stat, index) => (
                    <TouchableOpacity
                        className="bg-indigo-800 rounded-lg p-3 w-[31.5%] shadow-sm"
                        activeOpacity={0.7}
                        key={index}
                        onPress={() => onAddTask(index)}
                    >
                        <View className="flex items-center gap-2">
                            <AnimatedCircularProgress
                                size={60}
                                width={5}
                                fill={stat.value}
                                tintColor={stat.color}
                                backgroundColor="#E0E7FF"
                                rotation={0}
                            >
                                {() => (
                                    <Text
                                        className="text-sm font-bold"
                                        style={{ color: 'white' }}
                                    >
                                        {`${stat.value}%`}
                                    </Text>
                                )}
                            </AnimatedCircularProgress>
                            <Text className="text-white text-xs font-semibold text-center">
                                {stat.title}
                            </Text>
                        </View>
                    </TouchableOpacity>
                ))}
            </View>
        </View>
    );
};

export default ProgressStats;
--- END OF FILE app/components/progress/ProgressStats.jsx ---

--- START OF FILE app/components/progress/RoutineModal.jsx ---
import React, { useEffect, useState } from 'react';
import {
  Modal,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  ToastAndroid,
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import { Checkbox } from 'react-native-paper';
import * as SecureStore from 'expo-secure-store';
import * as Notifications from 'expo-notifications';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';

const RoutineModal = ({ visible, onClose, courseData, onSave }) => {
  const [selectedModule, setSelectedModule] = useState('');
  const [selectedSubtasks, setSelectedSubtasks] = useState({});
  const [time, setTime] = useState(''); // Displayed as "HH:MM AM/PM"
  const [duration, setDuration] = useState('');
  const [schedule, setSchedule] = useState([]);
  const [username, setUsername] = useState('admin');

  useEffect(() => {
    const loadSchedule = async () => {
      if (username) {
        const storedSchedule = await SecureStore.getItemAsync(`routine-${username}`);
        if (storedSchedule) {
          const parsedSchedule = JSON.parse(storedSchedule);
          const sortedSchedule = parsedSchedule.sort((a, b) => {
            const timeA = new Date(`2000/01/01 ${a.time}`);
            const timeB = new Date(`2000/01/01 ${b.time}`);
            return timeA - timeB;
          });
          setSchedule(sortedSchedule);
          scheduleNotifications(sortedSchedule);
        }
      }
    };
    loadSchedule();
    console.log(schedule);
  }, [username]);

  // Set default time like AddTaskModal
  useEffect(() => {
    const setDefaultTime = () => {
      const now = new Date();
      const hours = now.getHours();
      const minutes = now.getMinutes();
      const period = hours >= 12 ? 'PM' : 'AM';
      const displayHours = hours % 12 || 12;
      return `${displayHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${period}`;
    };
    if (!time) setTime(setDefaultTime());
  }, [visible]);

  // Get modules from the provided courseData
  const modules = courseData?.topics || [];

  // Get subtasks for the selected module
  const getSubtasksForModule = () => {
    if (!selectedModule) return [];
    const module = modules.find((m) => m.name === selectedModule);
    return module?.subtopics || [];
  };

  // Toggle subtask selection
  const toggleSubtask = (subtaskName) => {
    setSelectedSubtasks((prev) => ({
      ...prev,
      [subtaskName]: !prev[subtaskName],
    }));
  };

  const scheduleNotifications = async (tasks) => {
    await Notifications.cancelAllScheduledNotificationsAsync();

    tasks.forEach(task => {
      const [hours, minutes] = task.time.split(':');
      const trigger = new Date();
      trigger.setHours(parseInt(hours));
      trigger.setMinutes(parseInt(minutes));
      trigger.setSeconds(0);

      Notifications.scheduleNotificationAsync({
        content: {
          title: `${task.activity} session started`,
          body: `It will end in ${task.duration} minutes!`,
        },
        trigger,
      });
    });
  };

  // Handle save action
  const handleSave = async () => {
    const [timePart, period] = time.split(' ');
    let [hours, minutes] = timePart.split(':');
    hours = parseInt(hours);
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    const saveTime = `${hours.toString().padStart(2, '0')}:${minutes}`;

    const routineData = {
      activity: courseData.name,
      duration: duration,
      id: Date.now(),
      manualProgress: 0,
      progressType: 'subtasks',
      subtasks: Object.keys(selectedSubtasks)
        .filter((key) => selectedSubtasks[key])
        .map((text) => ({
          completed: false,
          text,
        })),
      time: saveTime,
    };

    await SecureStore.setItemAsync(`routine-${username}`, JSON.stringify([...schedule, routineData]));
    scheduleNotifications([...schedule, routineData]);
    ToastAndroid.show('Task added successfully!', ToastAndroid.SHORT);
    handleSaveI();
  };

  // Reset and close modal
  const handleCancel = () => {
    setSelectedModule('');
    setSelectedSubtasks({});
    setTime('');
    setDuration('');
    onClose();
  };

  const handleSaveI = () => {
    setSelectedModule('');
    setSelectedSubtasks({});
    setTime('');
    setDuration('');
    onSave();
  };

  // Time picker handlers
  const togglePeriod = () => {
    const [timePart, period] = time.split(' ');
    setTime(`${timePart} ${period === 'AM' ? 'PM' : 'AM'}`);
  };

  const handleHourChange = (text) => {
    const num = text.replace(/[^0-9]/g, '');
    if (num === '' || (parseInt(num) >= 0 && parseInt(num) <= 12)) {
      const [_, minutes, period] = time.split(/[: ]/);
      setTime(`${num.padStart(2, '')}:${minutes} ${period}`);
    }
  };

  const handleMinuteChange = (text) => {
    const num = text.replace(/[^0-9]/g, '');
    if (num === '' || (parseInt(num) >= 0 && parseInt(num) <= 59)) {
      const [hours, , period] = time.split(/[: ]/);
      setTime(`${hours}:${num.padStart(2, '')} ${period}`);
    }
  };

  if (!visible) return null;

  const isFormValid = selectedModule && 
    Object.keys(selectedSubtasks).some(key => selectedSubtasks[key]) && 
    time && 
    duration;

  return (
    <Modal
      animationType="slide"
      transparent={true}
      visible={visible}
      onRequestClose={onClose}
    >
      <View className="flex-1 justify-center items-center bg-black/60">
        <View className="w-[85%] bg-indigo-800 rounded-xl p-4 shadow-md">
          {/* Header */}
          <View className="flex-row items-center mb-4 border-b border-indigo-100/20 pb-2">
            <MaterialIcons name="event-note" size={22} color="#E0E7FF" />
            <Text className="text-white text-xl font-bold ml-2">
              Add Routine 
            </Text>
          </View>

          <ScrollView 
            className="max-h-96"
            showsVerticalScrollIndicator={false}
            contentContainerStyle={{ paddingBottom: 8 }}
          >
            {/* Form */}
            <View className="gap-4">
              {/* Module Selection */}
              <View className="mb-4">
                <View className="flex-row items-center mb-2">
                  <Ionicons name="book-outline" size={16} color="#A5B4FC" />
                  <Text className="text-indigo-100 ml-2 text-base">Module</Text>
                </View>
                <View className="border border-indigo-100/30 rounded-lg bg-indigo-100/10">
                  <Picker
                    selectedValue={selectedModule}
                    onValueChange={(itemValue) => {
                      setSelectedModule(itemValue);
                      setSelectedSubtasks({});
                    }}
                    style={{
                      color:"#ffffff"
                    }}
                    className="text-indigo-100"
                  >
                    <Picker.Item label="Select a module" value="" />
                    {modules.map((module, index) => (
                      <Picker.Item key={index} label={module.name} value={module.name} />
                    ))}
                  </Picker>
                </View>
              </View>

              {/* Subtasks Selection */}
              {selectedModule && getSubtasksForModule().length > 0 && (
                <View className="mb-4">
                  <View className="flex-row items-center mb-2">
                    <Ionicons name="checkbox-outline" size={16} color="#A5B4FC" />
                    <Text className="text-indigo-100 ml-2 text-base">Subtasks</Text>
                  </View>
                  <ScrollView className="min-h-40 flex border border-indigo-100/30 rounded-lg bg-indigo-100/10 p-1 ">
                    {getSubtasksForModule().map((subtask, index) => (
                      <View key={index} className="flex-row items-center py-2 border-b border-indigo-100/10">
                        <Checkbox
                          status={selectedSubtasks[subtask.name] ? 'checked' : 'unchecked'}
                          onPress={() => toggleSubtask(subtask.name)}
                          color="#A5B4FC"
                          uncheckedColor="#A5B4FC"
                        />
                        <Text className="text-indigo-100 text-base flex-1 ml-2">{subtask.name}</Text>
                      </View>
                    ))}
                  </ScrollView>
                </View>
              )}

              {/* Time Picker */}
              <View className="mb-4">
                <View className="flex-row items-center mb-2">
                  <Ionicons name="time-outline" size={16} color="#A5B4FC" />
                  <Text className="text-indigo-100 ml-2 text-base">Start Time</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <TextInput
                    className="w-14 border border-indigo-100/30 rounded-lg bg-indigo-100/10 px-3 py-2 text-center text-indigo-100 text-base"
                    value={time.split(/[: ]/)[0]}
                    onChangeText={handleHourChange}
                    keyboardType="numeric"
                    maxLength={2}
                    placeholder="HH"
                    placeholderTextColor="#A5B4FC"
                  />
                  <Text className="text-indigo-100 text-lg font-bold">:</Text>
                  <TextInput
                    className="w-14 border border-indigo-100/30 rounded-lg bg-indigo-100/10 px-3 py-2 text-center text-indigo-100 text-base"
                    value={time.split(/[: ]/)[1]}
                    onChangeText={handleMinuteChange}
                    keyboardType="numeric"
                    maxLength={2}
                    placeholder="MM"
                    placeholderTextColor="#A5B4FC"
                  />
                  <TouchableOpacity
                    onPress={togglePeriod}
                    className="bg-indigo-300 py-2 px-3 rounded-lg min-w-[50px] items-center"
                  >
                    <Text className="text-indigo-800 font-bold text-base">{time.split(/[: ]/)[2]}</Text>
                  </TouchableOpacity>
                </View>
              </View>

              {/* Duration Input */}
              <View className="mb-4">
                <View className="flex-row items-center mb-2">
                  <Ionicons name="timer-outline" size={16} color="#A5B4FC" />
                  <Text className="text-indigo-100 ml-2 text-base">Duration (minutes)</Text>
                </View>
                <TextInput
                  className="border border-indigo-100/30 rounded-lg bg-indigo-100/10 px-3 py-2 text-indigo-100 text-base"
                  placeholder="Duration in minutes"
                  keyboardType="numeric"
                  value={duration}
                  onChangeText={setDuration}
                  placeholderTextColor="#A5B4FC"
                />
              </View>
            </View>
          </ScrollView>

          {/* Footer Buttons */}
          <View className="flex-row justify-end mt-4 pt-2 border-t border-indigo-100/20">
            <TouchableOpacity
              className="py-2.5 px-4 mr-3"
              onPress={handleCancel}
            >
              <Text className="text-indigo-300 text-base font-medium">Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              className={`bg-indigo-100 py-2.5 px-4 rounded-lg ${!isFormValid ? 'bg-indigo-100/50' : ''}`}
              onPress={handleSave}
              disabled={!isFormValid}
            >
              <Text className="text-indigo-800 text-base font-semibold">Save</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

export default RoutineModal;
--- END OF FILE app/components/progress/RoutineModal.jsx ---

--- START OF FILE app/components/progress/TopicProgress.jsx ---
import React, { useState, useCallback } from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import Slider from '@react-native-community/slider';
import { MaterialIcons } from '@expo/vector-icons';

const TopicProgress = ({ topic, onLevelChange }) => {
  const [value, setValue] = useState(topic.level - 1);

  // Function to get background color based on level
  const getLevelColor = (level) => {
    const percentage = (level / 6) * 100; // Convert level to percentage (0-6 → 0-100%)

    if (percentage < 0 || percentage > 100) return '#94A3B8'; // Slate color for invalid values

    // Create a color scale that avoids the indigo/purple spectrum used in backgrounds
    if (percentage < 25) {
      // Low progress - red
      return '#7bed9f'; // Tailwind red-500
    } else if (percentage < 50) {
      // Some progress - yellow/amber
      return '#2ed573'; // Tailwind amber-500
    } else if (percentage < 75) {
      // Good progress - teal (avoiding pure green which might be hard to read)
      return '#1e90ff'; // Tailwind teal-500
    } else {
      // Excellent progress - cyan (avoiding blue/indigo used in the UI)
      return '#1e90ff'; // Tailwind cyan-500
    }
  };

  // Handle slider value change
  const handleValueChange = useCallback((newValue) => {
    setValue(newValue);
    onLevelChange(newValue);
  }, [onLevelChange]);

  // Calculate progress percentage for the progress bar
  const progressPercentage = ((value / 6) * 100);

  return (
    <View className="bg-indigo-800 rounded-lg p-4 mb-2 mx-1 shadow">
      <View className="flex-row items-center justify-between mb-3">
        <View className="flex-row items-center space-x-3 max-w-[80%] ">
          <MaterialIcons name="book" size={20} color="#E0E7FF" />
          <Text className="text-white text-base font-semibold ml-2">{topic.name.indexOf(":") != -1 ? topic.name.split(":")[0] : topic.name}</Text>
        </View>
        <View className="bg-white w-7 h-7 rounded-full items-center justify-center">
          <Text className="text-indigo-800 text-sm font-bold">{value}</Text>
        </View>
      </View>

      <View className="mt-1">
        <Slider
          style={{ width: '100%', height: 36 }}
          value={value}
          minimumValue={0}
          maximumValue={6}
          step={1}
          onValueChange={handleValueChange}
          minimumTrackTintColor={getLevelColor(value)}
          maximumTrackTintColor="rgba(224, 231, 255, 0.3)"
          thumbTintColor="#ffffff"
        />
        <Text className="text-indigo-100 text-xs text-right mt-1">
          {Math.round(progressPercentage)}%
        </Text>
      </View>
    </View>
  );
};

export default TopicProgress;
--- END OF FILE app/components/progress/TopicProgress.jsx ---

--- START OF FILE app/components/routine/AddTaskModal.jsx ---
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  TouchableOpacity, 
  Switch, 
  Modal, 
  Alert 
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const AddTaskModal = ({ isOpen, onClose, onSave, editingTask }) => {
  const [taskData, setTaskData] = useState({
    time: '', // Displayed as "HH:MM AM/PM", stored as "HH:MM" in 24h
    activity: '',
    duration: '',
    progressType: 'manual'
  });

  useEffect(() => {
    const setDefaultTime = () => {
      const now = new Date();
      const hours = now.getHours();
      const minutes = now.getMinutes();
      const period = hours >= 12 ? 'PM' : 'AM';
      const displayHours = hours % 12 || 12;
      return `${displayHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${period}`;
    };

    if (editingTask) {
      const [hours, minutes] = editingTask.time.split(':');
      let displayHours = parseInt(hours);
      const period = displayHours >= 12 ? 'PM' : 'AM';
      displayHours = displayHours % 12 || 12;
      setTaskData({
        time: `${displayHours.toString().padStart(2, '0')}:${minutes} ${period}`,
        activity: editingTask.activity,
        duration: editingTask.duration,
        progressType: editingTask.progressType
      });
    } else {
      setTaskData({
        time: setDefaultTime(),
        activity: '',
        duration: '',
        progressType: 'manual'
      });
    }
  }, [editingTask]);

  const calculateEndTime = () => {
    if (!taskData.time || !taskData.duration) return '';
    const [timePart, period] = taskData.time.split(' ');
    let [hours, minutes] = timePart.split(':');
    hours = parseInt(hours);
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    const date = new Date();
    date.setHours(hours, parseInt(minutes));
    date.setMinutes(date.getMinutes() + parseInt(taskData.duration));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  const togglePeriod = () => {
    const [timePart, period] = taskData.time.split(' ');
    setTaskData({
      ...taskData,
      time: `${timePart} ${period === 'AM' ? 'PM' : 'AM'}`
    });
  };

  const handleHourChange = (text) => {
  
    const num = text.replace(/[^0-9]/g, '');
    if (num === '' || (parseInt(num) >= 0 && parseInt(num) <= 12)) {
      const [_, minutes, period] = taskData.time.split(/[: ]/);
      setTaskData({
        ...taskData,
        time: `${num.padStart(2, '')}:${minutes} ${period}`
      });
    }
  };

  const handleMinuteChange = (text) => {
    const num = text.replace(/[^0-9]/g, '');
    if (num === '' || (parseInt(num) >= 0 && parseInt(num) <= 59)) {
      const [hours, , period] = taskData.time.split(/[: ]/);
      setTaskData({
        ...taskData,
        time: `${hours}:${num.padStart(2, '')} ${period}`
      });
    }
  };

  const handleSubmit = () => {
    if (!taskData.time || !taskData.activity || !taskData.duration) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }
    const [timePart, period] = taskData.time.split(' ');
    let [hours, minutes] = timePart.split(':');
    hours = parseInt(hours);
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    const saveTime = `${hours.toString().padStart(2, '0')}:${minutes}`;

    const saveData = { ...taskData, time: saveTime };
    if (editingTask) {
      onSave(editingTask.id, saveData);
    } else {
      onSave(saveData);
    }
    onClose();
  };

  if (!isOpen) return null;

  const [hours, minutes, period] = taskData.time.split(/[: ]/);

  return (
    <Modal
      visible={isOpen}
      animationType="slide"
      transparent={true}
    >
      <View className="flex-1 justify-center items-center bg-black/50">
        <View className="bg-white rounded-xl p-6 w-11/12 max-w-md shadow-lg">
          {/* Header */}
          <View className="flex-row justify-between items-center mb-4">
            <Text className="text-xl font-bold text-gray-800">
              {editingTask ? 'Edit Task' : 'Add Task'}
            </Text>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color="gray" />
            </TouchableOpacity>
          </View>

          {/* Form */}
          <View className="space-y-4 gap-4">
            {/* Time Picker */}
            <View>
              <View className="flex-row items-center mb-2">
                <Ionicons name="time-outline" size={16} color="gray" className="mr-2" />
                <Text className="text-gray-700">Start Time</Text>
              </View>
              <View className="flex-row items-center space-x-2 gap-2">
                {/* Hours Input */}
                <TextInput
                  className="w-16 border border-gray-300 rounded-lg p-2 text-gray-800 text-center bg-gray-50"
                  value={hours}
                  onChangeText={handleHourChange}
                  keyboardType="numeric"
                  maxLength={2}
                  placeholder="HH"
                  placeholderTextColor="#9CA3AF"
                />
                <Text className="text-gray-600 text-lg font-medium">:</Text>
                {/* Minutes Input */}
                <TextInput
                  className="w-16 border border-gray-300 rounded-lg p-2 text-gray-800 text-center bg-gray-50"
                  value={minutes}
                  onChangeText={handleMinuteChange}
                  keyboardType="numeric"
                  maxLength={2}
                  placeholder="MM"
                  placeholderTextColor="#9CA3AF"
                />
                {/* AM/PM Toggle */}
                <TouchableOpacity
                  onPress={togglePeriod}
                  className="bg-blue-500 rounded-lg px-3 py-2 min-w-[50px] items-center"
                >
                  <Text className="text-white font-medium">{period}</Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Activity Input */}
            <View>
              <View className="flex-row items-center mb-2">
                <Ionicons name="document-text-outline" size={16} color="gray" className="mr-2" />
                <Text className="text-gray-700">Activity</Text>
              </View>
              <TextInput
                className="border border-gray-300 rounded-lg p-2 text-gray-800 bg-gray-50"
                placeholder="Activity name"
                value={taskData.activity}
                onChangeText={(text) => setTaskData({ ...taskData, activity: text })}
              />
            </View>

            {/* Duration Input */}
            <View>
              <View className="flex-row items-center mb-2">
                <Ionicons name="timer-outline" size={16} color="gray" className="mr-2" />
                <Text className="text-gray-700">Duration (minutes)</Text>
              </View>
              <TextInput
                className="border border-gray-300 rounded-lg p-2 text-gray-800 bg-gray-50"
                placeholder="Duration in minutes"
                keyboardType="numeric"
                value={taskData.duration}
                onChangeText={(text) => setTaskData({ ...taskData, duration: text })}
              />
              {taskData.time && taskData.duration && (
                <Text className="text-gray-500 mt-1">
                  Ends at: {calculateEndTime()}
                </Text>
              )}
            </View>

            {/* Progress Type Toggle */}
            <View>
              <Text className="text-gray-700 mb-2">Progress Tracking Method</Text>
              <View className="flex-row items-center justify-between">
                <Text className="text-gray-600">
                  {taskData.progressType === 'manual' ? 'Manual' : 'Subtasks'}
                </Text>
                <Switch
                  value={taskData.progressType === 'subtasks'}
                  onValueChange={(value) => setTaskData({
                    ...taskData,
                    progressType: value ? 'subtasks' : 'manual'
                  })}
                  trackColor={{ false: '#D1D5DB', true: '#3B82F6' }}
                  thumbColor="#fff"
                />
              </View>
            </View>
          </View>

          {/* Footer Buttons */}
          <View className="flex-row justify-end space-x-2 mt-6 gap-1">
            <TouchableOpacity
              className="bg-gray-200 px-4 py-2 rounded-lg"
              onPress={onClose}
            >
              <Text className="text-gray-700 font-medium">Cancel</Text>
            </TouchableOpacity>
            <TouchableOpacity
              className="bg-blue-500 px-4 py-2 rounded-lg"
              onPress={handleSubmit}
            >
              <Text className="text-white font-medium">Save</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

export default AddTaskModal;
--- END OF FILE app/components/routine/AddTaskModal.jsx ---

--- START OF FILE app/components/routine/ImportExportRoutineDialog.jsx ---
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, Modal, StyleSheet, ActivityIndicator } from 'react-native';
import { getDatabase, ref, set, get } from 'firebase/database';
import * as SecureStore from 'expo-secure-store';
import { Ionicons } from '@expo/vector-icons';

const ImportExportRoutineDialog = ({ isOpen, onClose, firebaseApp, username, onImportData }) => {
  const [userId, setUserId] = useState('');
  const [loading, setLoading] = useState(false);
  const [statusMessage, setStatusMessage] = useState({ type: '', message: '' });

  const showStatus = (type, message) => {
    setStatusMessage({ type, message });
    setTimeout(() => {
      setStatusMessage({ type: '', message: '' });
    }, 3000);
  };

  const handleImport = async () => {
    if (!userId.trim()) {
      showStatus('error', 'Please enter a valid user ID');
      return;
    }

    setLoading(true);
    try {
      const db = getDatabase(firebaseApp);
      const routineRef = ref(db, `routine-${userId}`);
      const snapshot = await get(routineRef);

      if (snapshot.exists()) {
        const routineData = snapshot.val();
        await SecureStore.setItemAsync(`routine-${username}`, JSON.stringify(routineData));
        onImportData(routineData);
        showStatus('success', 'Routine data imported successfully');
        setTimeout(() => onClose(), 2000);
      } else {
        showStatus('error', 'No routine data found for this user ID');
      }
    } catch (error) {
      console.error('Import error:', error);
      showStatus('error', 'Failed to import routine data');
    } finally {
      setLoading(false);
    }
  };

  const handleExport = async () => {
    if (!userId.trim()) {
      showStatus('error', 'Please enter a valid user ID');
      return;
    }

    setLoading(true);
    try {
      const storedData = await SecureStore.getItemAsync(`routine-${username}`);
      if (storedData) {
        const db = getDatabase(firebaseApp);
        const routineRef = ref(db, `routine-${userId}`);
        await set(routineRef, JSON.parse(storedData));
        showStatus('success', 'Routine data exported successfully');
        setTimeout(() => onClose(), 2000);
      } else {
        showStatus('error', 'No local routine data found to export');
      }
    } catch (error) {
      console.error('Export error:', error);
      showStatus('error', 'Failed to export routine data');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal
      visible={isOpen}
      transparent={true}
      animationType="fade"
      onRequestClose={onClose}
    >
      <View style={styles.centeredView}>
        <View style={styles.modalView}>
          <View style={styles.headerRow}>
            <Text style={styles.modalTitle}>Sync Routine Data</Text>
            <TouchableOpacity onPress={onClose} style={styles.closeIcon}>
              <Ionicons name="close" size={24} color="#555" />
            </TouchableOpacity>
          </View>
          
          <View style={styles.inputContainer}>
            <Text style={styles.label}>User ID:</Text>
            <TextInput
              style={styles.input}
              value={userId}
              onChangeText={setUserId}
              placeholder="Enter user ID"
              placeholderTextColor="#aaa"
            />
          </View>
          
          {statusMessage.message ? (
            <View style={[
              styles.statusContainer, 
              statusMessage.type === 'error' ? styles.errorStatus : styles.successStatus
            ]}>
              <Ionicons 
                name={statusMessage.type === 'error' ? 'alert-circle' : 'checkmark-circle'} 
                size={20} 
                color={statusMessage.type === 'error' ? '#fff' : '#fff'} 
              />
              <Text style={styles.statusText}>{statusMessage.message}</Text>
            </View>
          ) : null}
          
          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={[styles.button, styles.importButton, loading && styles.disabledButton]}
              onPress={handleImport}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator color="#fff" size="small" />
              ) : (
                <>
                  <Ionicons name="cloud-download" size={20} color="#fff" style={styles.buttonIcon} />
                  <Text style={styles.buttonText}>Import</Text>
                </>
              )}
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[styles.button, styles.exportButton, loading && styles.disabledButton]}
              onPress={handleExport}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator color="#fff" size="small" />
              ) : (
                <>
                  <Ionicons name="cloud-upload" size={20} color="#fff" style={styles.buttonIcon} />
                  <Text style={styles.buttonText}>Export</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  centeredView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalView: {
    width: '85%',
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },
  closeIcon: {
    padding: 4,
  },
  inputContainer: {
    width: '100%',
    marginBottom: 16,
  },
  label: {
    fontSize: 15,
    marginBottom: 8,
    color: '#444',
  },
  input: {
    width: '100%',
    height: 48,
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    fontSize: 16,
    backgroundColor: '#f9f9f9',
  },
  statusContainer: {
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
    flexDirection: 'row',
    alignItems: 'center',
  },
  errorStatus: {
    backgroundColor: '#ff5252',
  },
  successStatus: {
    backgroundColor: '#4caf50',
  },
  statusText: {
    color: '#fff',
    marginLeft: 8,
    fontSize: 14,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  button: {
    width: '48%',
    height: 45,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
  },
  buttonIcon: {
    marginRight: 8,
  },
  importButton: {
    backgroundColor: '#3498db',
  },
  exportButton: {
    backgroundColor: '#2ecc71',
  },
  disabledButton: {
    opacity: 0.6,
  },
  buttonText: {
    color: 'white',
    fontSize: 15,
    fontWeight: '600',
  },
});

export default ImportExportRoutineDialog;
--- END OF FILE app/components/routine/ImportExportRoutineDialog.jsx ---

--- START OF FILE app/components/routine/ProgressModal.jsx ---
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, Modal } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import Slider from '@react-native-community/slider';

const ProgressModal = ({ isOpen, onClose, task, onSave }) => {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    if (task) {
      setProgress(task.manualProgress || 0);
    }
  }, []);

  if (!isOpen || !task) return null;

  const formatTimeToAmPm = (timeString) => {
    if (!timeString) return '';
    const [hours, minutes] = timeString.split(':');
    const date = new Date();
    date.setHours(parseInt(hours), parseInt(minutes));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  const calculateEndTime = () => {
    const [hours, minutes] = task.time.split(':');
    const date = new Date();
    date.setHours(parseInt(hours), parseInt(minutes));
    date.setMinutes(date.getMinutes() + parseInt(task.duration));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  const handleSave = () => {
    onSave(progress);
    onClose();
  };

  return (
    <Modal
      visible={isOpen}
      animationType="slide"
      transparent={true}
    >
      <View className="flex-1 justify-center items-center bg-black/50">
        <View className="bg-white rounded-lg p-6 w-11/12 max-w-md">
          {/* Header */}
          <View className="flex-row justify-between items-center mb-4">
            <Text className="text-xl font-bold text-gray-800">Update Progress</Text>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color="black" />
            </TouchableOpacity>
          </View>

          {/* Body */}
          <View className="space-y-4">
            <Text className="text-gray-600 text-center">
              {formatTimeToAmPm(task.time)} - {calculateEndTime()}
            </Text>
            
            <View className="items-center space-y-2">
              <Slider
                style={{ width: '100%', height: 40 }}
                minimumValue={0}
                maximumValue={100}
                value={task.manualProgress}
                step={1}
                onValueChange={(value) => setProgress(value)}
                minimumTrackTintColor="#3B82F6"
                maximumTrackTintColor="#D1D5DB"
                thumbTintColor="#3B82F6"
              />
              <Text className="text-2xl font-semibold text-blue-500">
                {parseInt(progress)}%
              </Text>
            </View>
          </View>

          {/* Footer */}
          <View className="mt-6">
            <TouchableOpacity
              className="bg-blue-500 py-2 rounded-lg"
              onPress={handleSave}
            >
              <Text className="text-white text-center font-medium">Save Progress</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

export default ProgressModal;
--- END OF FILE app/components/routine/ProgressModal.jsx ---

--- START OF FILE app/components/routine/ProgressOverview.jsx ---
import React from 'react';
import { View, Text } from 'react-native';

const ProgressOverview = ({ schedule, calculateProgress }) => {
  const calculateOverallProgress = () => {
    if (schedule.length === 0) return { time: 0, real: 0, total: 0 };

    const totals = schedule.reduce((acc, task) => {
      const progress = calculateProgress(task);
      return {
        time: acc.time + progress.time,
        real: acc.real + progress.real,
        total: acc.total + progress.total
      };
    }, { time: 0, real: 0, total: 0 });

    return {
      time: Math.round(totals.time / schedule.length),
      real: Math.round(totals.real / schedule.length),
      total: Math.round(totals.total / schedule.length)
    };
  };

  const progress = calculateOverallProgress();

  return (
    <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
      <View className="flex-row justify-between items-center mb-2">
        <Text className="text-lg font-semibold text-gray-800">Overall Progress</Text>
        <Text className="text-xl font-bold text-blue-500">{progress.total}%</Text>
      </View>
      
      <View className="h-2 bg-gray-200 rounded-full overflow-hidden mb-2">
        <View 
          className="h-full bg-blue-300 absolute"
          style={{ width: `${progress.time}%` }}
        />
        <View 
          className="h-full bg-blue-500 absolute"
          style={{ width: `${progress.real}%` }}
        />
      </View>
      
      <View className="flex-row justify-between">
        <Text className="text-sm text-gray-600">
          Time: <Text className="font-medium">{progress.time}%</Text>
        </Text>
        <Text className="text-sm text-gray-600">
          Real: <Text className="font-medium">{progress.real}%</Text>
        </Text>
      </View>
    </View>
  );
};

export default ProgressOverview;
--- END OF FILE app/components/routine/ProgressOverview.jsx ---

--- START OF FILE app/components/routine/ScheduleList.jsx ---
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, FlatList } from 'react-native';
import { Ionicons, MaterialIcons } from '@expo/vector-icons';

const ScheduleList = ({
  schedule,
  calculateProgress,
  onEditTask,
  onDeleteTask,
  onOpenProgressModal,
  onOpenSubtasksModal,
  handleCloudSync
}) => {
  const [currentTaskIndex, setCurrentTaskIndex] = useState(-1);

  useEffect(() => {
    const updateCurrentTask = () => {
      if (schedule.length === 0) {
        setCurrentTaskIndex(-1);
        return;
      }

      const now = new Date();
      const currentIndex = schedule.findIndex(task => {
        const [hours, minutes] = task.time.split(':');
        let scheduleStart = new Date();
        scheduleStart.setHours(parseInt(hours), parseInt(minutes), 0);
        const scheduleEnd = new Date(scheduleStart.getTime() + task.duration * 60000);
        return now >= scheduleStart && now <= scheduleEnd;
      });
      setCurrentTaskIndex(currentIndex);
    };

    updateCurrentTask(); // Initial check
    const interval = setInterval(updateCurrentTask, 60000); // Update every 60 seconds (1 minute)

    return () => clearInterval(interval); // Cleanup interval on unmount
  }, [schedule]);

  const formatTimeToAmPm = (timeString) => {
    if (!timeString) return '';
    const [hours, minutes] = timeString.split(':');
    const date = new Date();
    date.setHours(parseInt(hours), parseInt(minutes));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  const calculateEndTime = (startTime, durationMinutes) => {
    if (!startTime || !durationMinutes) return '';
    const [hours, minutes] = startTime.split(':');
    const date = new Date();
    date.setHours(parseInt(hours), parseInt(minutes));
    date.setMinutes(date.getMinutes() + parseInt(durationMinutes));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  // Sort schedule by time and completion status
  const sortedSchedule = [...schedule].sort((a, b) => {
    const now = new Date();
    const [aHours, aMinutes] = a.time.split(':');
    const [bHours, bMinutes] = b.time.split(':');

    const aStart = new Date().setHours(parseInt(aHours), parseInt(aMinutes), 0);
    const bStart = new Date().setHours(parseInt(bHours), parseInt(bMinutes), 0);
    const aEnd = aStart + a.duration * 60000;
    const bEnd = bStart + b.duration * 60000;

    const aProgress = calculateProgress(a);
    const bProgress = calculateProgress(b);

    // Completed tasks (100% progress) go to bottom
    if (aProgress.real === 100 && bProgress.real !== 100) return 1;
    if (bProgress.real === 100 && aProgress.real !== 100) return -1;
    if (aProgress.real === 100 && bProgress.real === 100) {
      return aStart - bStart; // Among completed, sort by start time
    }

    // Current task (if any) should be near top
    const aIsCurrent = now >= aStart && now <= aEnd;
    const bIsCurrent = now >= bStart && now <= bEnd;
    if (aIsCurrent && !bIsCurrent) return -1;
    if (bIsCurrent && !aIsCurrent) return 1;

    // Sort remaining tasks by start time
    return aStart - bStart;
  });

  const renderItem = ({ item, index }) => {
    const progress = calculateProgress(item); // Recalculate progress on each render
    const endTime = calculateEndTime(item.time, item.duration);
    const isCurrent = sortedSchedule.findIndex(t => t.id === item.id) === currentTaskIndex && currentTaskIndex !== -1;

    return (
      <View className={`bg-white rounded-lg p-4 mb-2 shadow-sm ${index === 0 ? 'border-l-4 border-blue-500' : ''}`}>
        <View className="flex-row justify-between items-center">
          <View className="flex-1">
            <View className="flex-row items-center mb-1">
              <Ionicons name="time-outline" size={16} color="gray" className="mr-2" />
              <Text className="text-gray-600">
                {formatTimeToAmPm(item.time)} - {endTime}
              </Text>
            </View>
            <Text className="text-gray-800 font-medium">{item.activity}</Text>
          </View>
          <Text className="text-blue-500 font-semibold">{Math.round(progress.real)}%</Text>
        </View>

        <View className="h-2 bg-gray-200 rounded-full overflow-hidden my-2">
          <View
            className="h-full bg-blue-300 absolute"
            style={{ width: `${progress.time}%` }}
          />
          <View
            className="h-full bg-blue-500 absolute"
            style={{ width: `${progress.real}%` }}
          />
        </View>

        <View className="flex-row justify-end space-x-2">
          <TouchableOpacity onPress={() => onEditTask(item.id)}>
            <MaterialIcons name="edit" size={20} color="gray" />
          </TouchableOpacity>
          <TouchableOpacity
            onPress={() => item.progressType === 'manual'
              ? onOpenProgressModal(item.id)
              : onOpenSubtasksModal(item.id)}
          >
            <MaterialIcons
              name={item.progressType === 'manual' ? 'percent' : 'task'}
              size={20}
              color="gray"
            />
          </TouchableOpacity>
          <TouchableOpacity onPress={() => onDeleteTask(item.id)}>
            <MaterialIcons name="delete" size={20} color="gray" />
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  return (
    <View className="flex-1">
      <View className="flex-row items-center mb-4">
        <Text className="text-xl font-bold text-gray-800">Today's Tasks</Text>
        <TouchableOpacity
          onPress={handleCloudSync}
          className='bg-blue-500 h-10 items-center justify-center px-2 rounded ml-auto'
        >
          <Ionicons name="cloud" size={20} color="#fff" />
        </TouchableOpacity>
        <TouchableOpacity
          className="bg-blue-500 px-3 h-10 items-center justify-center rounded ml-1"
          onPress={() => onEditTask(null)}
        >
          <Text className="text-white">Add Task</Text>
        </TouchableOpacity>
      </View>

      {sortedSchedule.length === 0 ? (
        <View className="flex-1 justify-center items-center">
          <Text className="text-gray-500">
            No tasks scheduled. Click "Add Task" to get started.
          </Text>
        </View>
      ) : (
        <FlatList
          data={sortedSchedule}
          renderItem={renderItem}
          keyExtractor={item => item.id.toString()}
          showsVerticalScrollIndicator={false}
        />
      )}
    </View>
  );
};

export default ScheduleList;
--- END OF FILE app/components/routine/ScheduleList.jsx ---

--- START OF FILE app/components/routine/SubtasksModal.jsx ---
import React, { useState } from 'react';
import { 
  View, 
  Text, 
  TextInput, 
  TouchableOpacity, 
  FlatList, 
  Modal,
  Pressable
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const SubtasksModal = ({ isOpen, onClose, task, onUpdateSubtasks }) => {
  const [newSubtask, setNewSubtask] = useState('');

  if (!isOpen || !task) return null;

  const formatTimeToAmPm = (timeString) => {
    if (!timeString) return '';
    const [hours, minutes] = timeString.split(':');
    const date = new Date();
    date.setHours(parseInt(hours), parseInt(minutes));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  const calculateEndTime = () => {
    const [hours, minutes] = task.time.split(':');
    const date = new Date();
    date.setHours(parseInt(hours), parseInt(minutes));
    date.setMinutes(date.getMinutes() + parseInt(task.duration));
    return date.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(/\s/g, '');
  };

  const handleAddSubtask = () => {
    if (!newSubtask.trim()) return;
    
    const updatedSubtasks = [
      ...(task.subtasks || []),
      { text: newSubtask.trim(), completed: false }
    ];
    onUpdateSubtasks(updatedSubtasks);
    setNewSubtask('');
  };

  const handleToggleSubtask = (index) => {
    const updatedSubtasks = task.subtasks.map((subtask, i) => 
      i === index ? { ...subtask, completed: !subtask.completed } : subtask
    );
    onUpdateSubtasks(updatedSubtasks);
  };

  const handleDeleteSubtask = (index) => {
    const updatedSubtasks = task.subtasks.filter((_, i) => i !== index);
    onUpdateSubtasks(updatedSubtasks);
  };

  const renderSubtask = ({ item, index }) => (
    <View className="flex-row items-center bg-gray-100 rounded p-3 mb-2">
      <Pressable
        onPress={() => handleToggleSubtask(index)}
        className="w-5 h-5 border border-gray-400 rounded mr-3 flex items-center justify-center"
      >
        {item.completed && (
          <Ionicons name="checkmark" size={16} color="green" />
        )}
      </Pressable>
      <Text className={`flex-1 text-gray-800 ${item.completed ? 'line-through text-gray-500' : ''}`}>
        {item.text}
      </Text>
      <TouchableOpacity onPress={() => handleDeleteSubtask(index)}>
        <Ionicons name="trash-outline" size={20} color="red" />
      </TouchableOpacity>
    </View>
  );

  return (
    <Modal
      visible={isOpen}
      animationType="slide"
      transparent={true}
    >
      <View className="flex-1 justify-center items-center bg-black/50">
        <View className="bg-white rounded-lg p-5 w-11/12 max-w-md">
          {/* Header */}
          <View className="flex-row justify-between items-center mb-4">
            <Text className="text-xl font-semibold text-gray-800">Subtasks</Text>
            <TouchableOpacity onPress={onClose}>
              <Ionicons name="close" size={24} color="gray" />
            </TouchableOpacity>
          </View>

          {/* Time Info */}
          <Text className="text-gray-600 text-center mb-4">
            {formatTimeToAmPm(task.time)} - {calculateEndTime()}
          </Text>

          {/* Subtasks List */}
          <FlatList
            data={task.subtasks || []}
            renderItem={renderSubtask}
            keyExtractor={(_, index) => index.toString()}
            className="max-h-64 mb-4"
            showsVerticalScrollIndicator={false}
          />

          {/* Add Subtask Input */}
          <View className="flex-row items-center gap-2">
            <TextInput
              value={newSubtask}
              onChangeText={setNewSubtask}
              onSubmitEditing={handleAddSubtask}
              placeholder="New subtask"
              className="flex-1 border border-gray-300 rounded p-2"
            />
            <TouchableOpacity
              onPress={handleAddSubtask}
              className="bg-blue-500 p-2 rounded"
            >
              <Ionicons name="add" size={24} color="white" />
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};

export default SubtasksModal;
--- END OF FILE app/components/routine/SubtasksModal.jsx ---

--- START OF FILE app/notes/[...path].js ---
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TextInput, TouchableOpacity, StatusBar, ActivityIndicator, SafeAreaView, ScrollView, KeyboardAvoidingView, Platform, Modal, Switch, Alert } from 'react-native';
import { WebView } from 'react-native-webview';
import * as FileSystem from 'expo-file-system';
import { useLocalSearchParams } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import * as SecureStore from 'expo-secure-store';
import { initializeApp } from 'firebase/app';
import { getDatabase, ref, set, get, child, remove, query, orderByChild, equalTo, limitToFirst } from 'firebase/database';

// Markdown placeholder for template
const MARKDOWN_PLACEHOLDER = "%MARKDOWN_CONTENT%";

const firebaseConfig = {
  apiKey: "AIzaSyAnjWWep4dtxvn1YKtmdU7A002X2NAvlX0",
  authDomain: "data-science-ef878.firebaseapp.com",
  databaseURL: "https://data-science-ef878-default-rtdb.firebaseio.com",
  projectId: "data-science-ef878",
  storageBucket: "data-science-ef878.firebasestorage.app",
  messagingSenderId: "1010841233830",
  appId: "1:1010841233830:web:e7aa0b516ace71c1720767",
  measurementId: "G-FL7XZR6X7Q"
};

const app = initializeApp(firebaseConfig);
const database = getDatabase(app);

const sanitizePath = (path) => {
  return path
    .replace(/#/g, '%23')    // Replace # with %23
    .replace(/\./g, '%2E')    // Replace . with %2E
    .replace(/\$/g, '%24')    // Replace $ with %24
    .replace(/\[/g, '%5B')    // Replace [ with %5B
    .replace(/\]/g, '%5D')    // Replace ] with %5D
    .replace(/%/g, '%25');    // Replace % with %25 (to handle already encoded characters)
};

const INDEX_HTML_CONTENT_TEMPLATE = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>Notes Preview</title>
    <!-- GitHub Markdown CSS -->
    <link rel="stylesheet" href="github-markdown.min.css"
        integrity="sha512-H5FUvsR2W84sZ09/w6oFuncsnL1edP8HkvL8B2FZdT1TcXzw1MpL#1EdU0jN17xHxaqBZv4iSaS5S0Zd7l3F1lg" crossorigin="anonymous">
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="katex.min.css"
        integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
    <!-- Showdown -->
    <script src="showdown.min.js"></script>
    <!-- KaTeX JS (deferred for performance) -->
    <script defer src="katex.min.js"
        integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
    <!-- KaTeX Auto-Render (deferred) -->
    <script defer src="contrib/auto-render.min.js"
        integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="tryRenderMath()"></script>
    <!-- MathJax (async for optional math rendering) -->
    <script id="MathJax-script" async src="mathjax.min.js"></script>
    <!-- Highlight.js for Code Syntax Highlighting -->
    <link rel="stylesheet" href="github.min.css">
    <script src="highlight.min.js"></script>
    <style>
    body {
        background: #ffffff;
        padding: 30px;
        margin: 0;
        display: flex;
        width: 100vw;
        font-family:arial;
        color: #000000;
    }
    .markdown-body {
        font-size:14pt;
        max-width: 100%;
        padding-top:30px;
        background: #ffffff;
    }
    </style>
    <script>
        function sendToRN(type, message) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({ type, message }));
            }
        }
        function reportLoadError(resource) {
            sendToRN('error', \`Failed to load resource: \${resource}\`);
        }
        window.onerror = function(message, source, lineno, colno, error) {
            sendToRN('error', \`Script error: \${message} at \${source}:\${lineno}:\${colno}\`);
        };
        window.onload = function() {
            if (!document.getElementById('content')) {
                sendToRN('error', 'HTML loading failed: Content element not found');
            } else {
                sendToRN('log', 'HTML content loaded successfully');
                processMarkdown();
            }
            document.body.style.zoom = '90%';
        };
        setTimeout(function() {
            if (!window.showdown || !window.hljs || !window.katex) {
                sendToRN('error', 'HTML loading timeout: Essential libraries not loaded');
            }
        }, 5000);
        function tryRenderMath() {
            if (typeof renderMathInElement === 'function') {
                sendToRN('log', 'renderMathInElement is defined');
                const mathElements = document.body.getElementsByTagName('*');
                let mathCount = 0;
                for (let el of mathElements) {
                    if (el.textContent.match(/[$\\[\]()]/)) {
                        mathCount++;
                    }
                }
                sendToRN('log', \`Found \${mathCount} potential math elements\`);
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                    ],
                    throwOnError: false
                });
                sendToRN('log', 'renderMathInElement called');
            } else {
                sendToRN('error', 'renderMathInElement is not defined');
            }
        }
        function processMarkdown() {
            try {
                const md = ${MARKDOWN_PLACEHOLDER}
                let converter = new showdown.Converter({
                    tables: true,
                    ghCodeBlocks: true,
                    tasklists: true,
                    literalMidWordUnderscores: true,
                    extensions: []
                });
                document.getElementById("content").innerHTML = converter.makeHtml(md);
                document.querySelectorAll("pre code").forEach(block => hljs.highlightElement(block));
                tryRenderMath();
                sendToRN('log', 'Markdown processed successfully');
            } catch (e) {
                sendToRN('error', \`Markdown processing error: \${e.message}\`);
            }
        }
    </script>
</head>
<body>
    <article id="content" class="markdown-body"></article>
</body>
</html>
`;

const DEPENDENCIES = {
  'github-markdown.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown.min.css',
  'katex.min.css': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css',
  'showdown.min.js': 'https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js',
  'katex.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js',
  'contrib/auto-render.min.js': 'https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js',
  'mathjax.min.js': 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',
  'github.min.css': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css',
  'highlight.min.js': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js',
};

const NotesPage = () => {
  const basepath = useLocalSearchParams()?.path;
  const path = Array.isArray(basepath) ? basepath.join('/') : (basepath || 'default.md');

  if (path.endsWith('.html') || path.endsWith('/')) {
    return (
      <SafeAreaView className="flex-1 bg-white">
        <StatusBar barStyle="light-content" backgroundColor="#fff" />
        <WebView
          className="mt-10"
          originWhitelist={['*']}
          source={{ uri: `https://ihjas-ahammed.github.io/${path}` }}
          javaScriptEnabled={true}
          domStorageEnabled={true}
        />
      </SafeAreaView>
    );
  }

  const sanitizedPath = sanitizePath(path);
  const webViewRef = useRef(null);
  const [localHtmlPath, setLocalHtmlPath] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [progress, setProgress] = useState(0);
  const [markdown, setMarkdown] = useState('');
  const [isEditing, setIsEditing] = useState(false);
  const [error, setError] = useState(null);
  const [markdownLoaded, setMarkdownLoaded] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState("Preparing...");
  const [showChannelModal, setShowChannelModal] = useState(false);
  const [channels, setChannels] = useState([]);
  const [selectedChannel, setSelectedChannel] = useState('default');
  const [userId, setUserId] = useState('');
  const [pin, setPin] = useState('');
  const [isPublic, setIsPublic] = useState(true);
  const [showUploadModal, setShowUploadModal] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false);

  useEffect(() => {
    const loadCredentials = async () => {
      const storedUserId = await SecureStore.getItemAsync('userId');
      const storedPin = await SecureStore.getItemAsync('pin');
      if (storedUserId && storedPin) {
        setUserId(storedUserId);
        setPin(storedPin);
        await fetchChannels();
      }
    };
    loadCredentials();
  }, []);

  const ensureDirectoryExists = async (dirPath) => {
    const info = await FileSystem.getInfoAsync(dirPath);
    if (!info.exists) {
      await FileSystem.makeDirectoryAsync(dirPath, { intermediates: true });
    }
  };

  const safeDownloadFile = async (url, filePath, onProgress) => {
    try {
      const info = await FileSystem.getInfoAsync(filePath);
      if (info.exists) {
        onProgress(100);
        return;
      }
      setLoadingMessage(`Downloading: ${url.split('/').pop()}`);
      const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
      await ensureDirectoryExists(dirPath);
      const downloadResumable = FileSystem.createDownloadResumable(
        url,
        filePath,
        {},
        (downloadProgress) => {
          const percent = (downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite) * 100;
          onProgress(percent);
        }
      );
      const { status } = await downloadResumable.downloadAsync();
      if (status < 200 || status >= 300) {
        throw new Error(`Download failed with status code: ${status}`);
      }
      console.log(`Successfully downloaded ${url} to ${filePath}`);
    } catch (err) {
      console.error(`Failed to download ${url} to ${filePath}:`, err);
      throw err;
    }
  };

  const handleDeleteChannel = async (channelId) => {
    if (!userId || !pin) {
      setError('Please log in to delete notes');
      setShowLoginModal(true);
      return;
    }

    try {
      const dbRef = ref(database, `notes/${sanitizedPath}/${channelId}`);
      const snapshot = await get(dbRef);

      if (!snapshot.exists()) {
        setError('Note not found');
        return;
      }

      const channelData = snapshot.val();

      if (channelData.name !== userId || channelData.pin !== pin) {
        setError('You can only delete your own notes');
        return;
      }

      Alert.alert(
        "Confirm Delete",
        "Are you sure you want to delete this note?",
        [
          { text: "Cancel", style: "cancel" },
          {
            text: "Delete",
            style: "destructive",
            onPress: async () => {
              setIsLoading(true);
              try {
                await remove(dbRef);
                await fetchChannels();
                if (selectedChannel === channelId) {
                  setMarkdown('');
                  const dataDir = `${FileSystem.documentDirectory}notes`;
                  const htmlPath = `${dataDir}/index.html`;
                  const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, JSON.stringify(''));
                  await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
                  setLocalHtmlPath(htmlPath);
                  webViewRef.current?.reload();
                }
              } catch (err) {
                setError(`Failed to delete note: ${err.message}`);
              } finally {
                setIsLoading(false);
              }
            }
          }
        ]
      );
    } catch (err) {
      setError(`Error verifying note ownership: ${err.message}`);
    }
  };

  const fetchChannels = async () => {
    try {
      const dbRef = ref(database);
      const snapshot = await get(child(dbRef, `notes/${sanitizedPath}`));
      
      const storedUserId = await SecureStore.getItemAsync('userId');
      const storedPin = await SecureStore.getItemAsync('pin');

      if (snapshot.exists()) {
        const data = snapshot.val();
        const channelList = Object.entries(data).map(([key, value]) => ({
          id: key,
          ...value,
          visible: value.type === 'public' || (userId && value.name === userId && value.pin === pin),
          canDelete: storedUserId && value.name === storedUserId && value.pin === storedPin
        })).filter(channel => channel.visible);
        setChannels(channelList);
      } else {
        setChannels([]);
      }
    } catch (err) {
      setError(`Failed to fetch channels: ${err.message}`);
    }
  };

  const handleLogin = async () => {
    if (!userId || !pin) {
      setError('Please enter both User ID and PIN');
      return;
    }
    setIsLoading(true);
    try {
      await SecureStore.setItemAsync('userId', userId);
      await SecureStore.setItemAsync('pin', pin);
      await fetchChannels();
      setShowLoginModal(false);
    } catch (err) {
      setError(`Login failed: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleUpload = async () => {
    if (!userId || !pin) {
      setShowLoginModal(true);
      return;
    }

    setIsLoading(true);
    try {
      const userNotesQuery = query(
        ref(database, `notes/${sanitizedPath}`),
        equalTo(userId),
        limitToFirst(1)
      );

      const snapshot = await get(userNotesQuery);
      let existingChannelId = null;

      if (snapshot.exists()) {
        const data = snapshot.val();
        existingChannelId = Object.keys(data)[0];
        const existingNote = Object.values(data)[0];
        if (existingNote.pin !== pin) {
          setError('PIN does not match existing note');
          setIsLoading(false);
          return;
        }
      }

      const channelId = existingChannelId || `${sanitizePath(userId)}`;
      const channelData = {
        name: userId,
        pin: pin,
        note: markdown,
        type: isPublic ? 'public' : 'private'
      };

      await set(ref(database, `notes/${sanitizedPath}/${channelId}`), channelData);
      await fetchChannels();
      setSelectedChannel(channelId);
      setShowUploadModal(false);
    } catch (err) {
      setError(`Upload failed: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleChannelSelect = async (channelId) => {
    setIsLoading(true);
    try {
      const mdUrl = `https://ihjas-ahammed.github.io/${path}`;
      const dataDir = `${FileSystem.documentDirectory}notes`;
      let mdFilePath = `${dataDir}/${path}`;
      if (!path.includes('.')) {
        mdFilePath = `${dataDir}/${path}/index.md`;
      }
      let mdc = '';
      if (channelId === 'default') {
        await FileSystem.deleteAsync(mdFilePath, { idempotent: true });
        await safeDownloadFile(mdUrl, mdFilePath, setProgress);
        mdc = await FileSystem.readAsStringAsync(mdFilePath, { encoding: FileSystem.EncodingType.UTF8 });
        setMarkdown(mdc);
      } else {
        const dbRef = ref(database);
        const snapshot = await get(child(dbRef, `notes/${sanitizedPath}/${channelId}`));
        if (snapshot.exists()) {
          mdc = snapshot.val().note;
          setMarkdown(mdc);
        }
      }
      const htmlPath = `${dataDir}/index.html`;
      const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, JSON.stringify(mdc));
      await FileSystem.deleteAsync(htmlPath, { idempotent: true });
      await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
      await FileSystem.writeAsStringAsync(mdFilePath, mdc, { encoding: FileSystem.EncodingType.UTF8 });
      setLocalHtmlPath(htmlPath);
      setSelectedChannel(channelId);
      webViewRef.current?.reload();
    } catch (err) {
      setError(`Failed to load channel: ${err.message}`);
    } finally {
      setIsLoading(false);
      setShowChannelModal(false);
    }
  };

  useEffect(() => {
    const setupFiles = async () => {
      setIsLoading(true);
      setError(null);
      setProgress(0);
      try {
        const dataDir = `${FileSystem.documentDirectory}notes`;
        const htmlPath = `${dataDir}/index.html`;
        let mdFilePath = `${dataDir}/${path}`;
        if (!path.includes('.')) {
          mdFilePath = `${dataDir}/${path}/index.md`;
        }
        const mdFileDir = mdFilePath.substring(0, mdFilePath.lastIndexOf('/'));
        await ensureDirectoryExists(dataDir);
        await ensureDirectoryExists(mdFileDir);

        let filesDownloaded = 0;
        const fontCount = 25; // Estimated number of fonts for KaTeX v0.16.21
        const totalFiles = Object.keys(DEPENDENCIES).length + 1 + fontCount;

        for (const [fileName, url] of Object.entries(DEPENDENCIES)) {
          const filePath = `${dataDir}/${fileName}`;
          await safeDownloadFile(url, filePath, (percent) => {
            setProgress(Math.min(((filesDownloaded + (percent / 100)) / totalFiles) * 100, 100));
          });
          filesDownloaded += 1;
          setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
        }

        let mdContent = '';
        const mdFileInfo = await FileSystem.getInfoAsync(mdFilePath);
        if (mdFileInfo.exists) {
          mdContent = await FileSystem.readAsStringAsync(mdFilePath, { encoding: FileSystem.EncodingType.UTF8 });
          filesDownloaded += 1;
          setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
        } else {
          try {
            await fetchChannels();
            const mdUrl = `https://ihjas-ahammed.github.io/${path}`;
            await safeDownloadFile(mdUrl, mdFilePath, (percent) => {
              setProgress(Math.min(((filesDownloaded + (percent / 100)) / totalFiles) * 100, 100));
            });
            mdContent = await FileSystem.readAsStringAsync(mdFilePath, { encoding: FileSystem.EncodingType.UTF8 });
            filesDownloaded += 1;
            setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
          } catch (err) {
            mdContent = `# ${path.split('/').pop().replace('.md', '')}\n\nStart writing...\n\nInline: $E = mc^2$\n\nDisplay:\n$$\\int_0^1 x^2 dx = \\frac{1}{3}$$\n\n\`\`\`javascript\nconsole.log("Hello");\n\`\`\``;
            await FileSystem.writeAsStringAsync(mdFilePath, mdContent, { encoding: FileSystem.EncodingType.UTF8 });
            filesDownloaded += 1;
            setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
          }
        }
        setMarkdown(mdContent);

        const fontDir = `${dataDir}/fonts`;
        await ensureDirectoryExists(fontDir);
        const katexCssPath = `${dataDir}/katex.min.css`;
        const cssContent = await FileSystem.readAsStringAsync(katexCssPath, { encoding: FileSystem.EncodingType.UTF8 });
        const fontUrls = new Set();
        const urlRegex = /url\(['"]?([^'")]+)['"]?\)/g;
        let match;
        while ((match = urlRegex.exec(cssContent)) !== null) {
          const relativeUrl = match[1];
          if (relativeUrl.startsWith('fonts/')) {
            fontUrls.add(relativeUrl);
          }
        }
        const katexBaseUrl = DEPENDENCIES['katex.min.css'].replace('katex.min.css', '');
        for (const relativeUrl of fontUrls) {
          const filename = relativeUrl.split('/').pop();
          const absoluteUrl = `${katexBaseUrl}${relativeUrl}`;
          const localFontPath = `${fontDir}/${filename}`;
          await safeDownloadFile(absoluteUrl, localFontPath, (percent) => {
            setProgress(Math.min(((filesDownloaded + (percent / 100)) / totalFiles) * 100, 100));
          });
          filesDownloaded += 1;
          setProgress(Math.min((filesDownloaded / totalFiles) * 100, 100));
        }
        console.log(`Total fonts downloaded: ${fontUrls.size}`);

        const jsonMarkdown = JSON.stringify(mdContent);
        const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, jsonMarkdown);
        await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
        setLocalHtmlPath(htmlPath);
      } catch (error) {
        console.error('Error setting up files:', error);
        setError(`Error: ${error.message}`);
      } finally {
        setIsLoading(false);
        await fetchChannels();
      }
    };
    setupFiles();
  }, [path]);

  const handleSave = async () => {
    setIsLoading(true);
    setLoadingMessage('Saving changes...');
    try {
      const dataDir = `${FileSystem.documentDirectory}notes`;
      let mdFilePath = `${dataDir}/${path}`;
      if (!path.includes('.')) {
        mdFilePath = `${dataDir}/${path}/index.md`;
      }
      const mdFileDir = mdFilePath.substring(0, mdFilePath.lastIndexOf('/'));
      await ensureDirectoryExists(mdFileDir);
      await FileSystem.writeAsStringAsync(mdFilePath, markdown, { encoding: FileSystem.EncodingType.UTF8 });
      const htmlPath = `${dataDir}/index.html`;
      const jsonMarkdown = JSON.stringify(markdown);
      const htmlContent = INDEX_HTML_CONTENT_TEMPLATE.replace(MARKDOWN_PLACEHOLDER, jsonMarkdown);
      await FileSystem.writeAsStringAsync(htmlPath, htmlContent, { encoding: FileSystem.EncodingType.UTF8 });
      setIsEditing(false);
    } catch (error) {
      setError(`Save error: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleMessage = (event) => {
    try {
      const data = JSON.parse(event.nativeEvent.data);
      if (data.type === 'log') {
        if (data.message === 'Markdown processed successfully') {
          setMarkdownLoaded(true);
        } else if (data.message === 'renderMathInElement is defined') {
          setMarkdownLoaded(false);
        }
        console.log('WebView Log:', data.message);
      } else if (data.type === 'error') {
        console.error('WebView Error:', data.message);
      }
    } catch (error) {
      console.error('Failed to parse WebView message:', error);
    }
  };

  if (isLoading) {
    return (
      <View className="flex-1 justify-center items-center bg-white">
        <ActivityIndicator size="large" color="#000000" />
        <Text className="text-black mt-2">{Math.min(progress, 100).toFixed(0)}%</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View className="flex-1 justify-center items-center p-5 bg-[#1E1E1E]">
        <Text className="text-[#FF5555] mb-5 text-center text-base">{error}</Text>
        <TouchableOpacity
          className="bg-[#2D5AF2] px-5 py-2.5 rounded"
          onPress={() => {
            setError(null);
            setIsLoading(true);
            setTimeout(() => setIsLoading(false), 100);
          }}
        >
          <Text className="text-white text-base">Retry</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <SafeAreaView className="flex-1 bg-white">
      <StatusBar barStyle="light-content" backgroundColor="#ffffff" />
      <View className="absolute top-2 right-0 flex-col items-center justify-end px-2.5 z-10">
        {isEditing ? (
          <>
            <TouchableOpacity className="p-2" onPress={handleSave}>
              <Ionicons name="sync" size={18} color="black" />
            </TouchableOpacity>
            <TouchableOpacity className="p-2" onPress={() => setIsEditing(false)}>
              <Ionicons name="close" size={18} color="black" />
            </TouchableOpacity>
          </>
        ) : (
          <>
            <TouchableOpacity className="p-2" onPress={() => setIsEditing(true)}>
              <Ionicons name="pencil" size={18} color="black" />
            </TouchableOpacity>
            <TouchableOpacity className="p-2" onPress={() => setShowChannelModal(true)}>
              <Ionicons name="cloud" size={18} color="black" />
            </TouchableOpacity>
            <TouchableOpacity className="p-2" onPress={() => setShowUploadModal(true)}>
              <Ionicons name="cloud-upload" size={18} color="black" />
            </TouchableOpacity>
            {userId && pin ? (
              <TouchableOpacity className="p-2" onPress={() => { setUserId(''); setPin(''); SecureStore.deleteItemAsync('userId'); SecureStore.deleteItemAsync('pin'); }}>
                <Ionicons name="log-out" size={18} color="black" />
              </TouchableOpacity>
            ) : (
              <TouchableOpacity className="p-2" onPress={() => setShowLoginModal(true)}>
                <Ionicons name="log-in" size={18} color="black" />
              </TouchableOpacity>
            )}
          </>
        )}
      </View>
      {isEditing ? (
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={{ flex: 1 }}
        >
          <TextInput
            className="p-[30px] text-black bg-white text-normal min-h-[200px]"
            multiline
            value={markdown}
            onChangeText={setMarkdown}
            autoCapitalize="none"
            autoCorrect={false}
            spellCheck={false}
            keyboardType="ascii-capable"
            textAlignVertical="top"
          />
        </KeyboardAvoidingView>
      ) : (
        <View style={{ flex: 1 }}>
          <WebView
            className="mt-10"
            ref={webViewRef}
            originWhitelist={['*']}
            source={{ uri: localHtmlPath }}
            baseUrl={`${FileSystem.documentDirectory}notes/`}
            allowFileAccess={true}
            mixedContentMode="always"
            onMessage={handleMessage}
            allowUniversalAccessFromFileURLs={true}
            allowFileAccessFromFileURLs={true}
            domStorageEnabled={true}
            javaScriptEnabled={true}
          />
          {!markdownLoaded ? (
            <View style={{
              position: 'absolute',
              top: 0, left: 0, right: 0, bottom: 0,
              justifyContent: 'center',
              alignItems: 'center',
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              zIndex: 10
            }}>
              <ActivityIndicator size="large" color="#000000" />
              <Text style={{ color: '#000', marginTop: 10 }}>Loading Markdown...</Text>
            </View>
          ) : null}
        </View>
      )}
      <Modal visible={showChannelModal} transparent animationType="slide">
        <View className="flex-1 justify-center items-center bg-black/50">
          <View className="bg-white p-5 rounded-lg w-3/4">
            <Text className="text-lg font-bold mb-4">Select Channel</Text>
            <TouchableOpacity
              className="p-2 border-b"
              onPress={() => handleChannelSelect('default')}
            >
              <Text>Default</Text>
            </TouchableOpacity>
            {channels.map(channel => (
              <View key={channel.id} className="p-2 border-b flex-row justify-between items-center">
                <TouchableOpacity
                  onPress={() => handleChannelSelect(channel.id)}
                  className="flex-1"
                >
                  <Text>{channel.name} ({channel.type})</Text>
                </TouchableOpacity>
                {channel.canDelete && (
                  <TouchableOpacity
                    className="p-2"
                    onPress={() => handleDeleteChannel(channel.id)}
                  >
                    <Ionicons name="trash" size={18} color="red" />
                  </TouchableOpacity>
                )}
              </View>
            ))}
            <TouchableOpacity
              className="p-2 mt-4 bg-gray-200 rounded"
              onPress={() => setShowChannelModal(false)}
            >
              <Text>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
      <Modal visible={showUploadModal} transparent animationType="slide">
        <View className="flex-1 justify-center items-center bg-black/50">
          <View className="bg-white p-5 rounded-lg w-3/4">
            <Text className="text-lg font-bold mb-4">Upload Note</Text>
            <Text className="mb-2">User: {userId}</Text>
            <View className="flex-row items-center mb-4">
              <Text className="mr-2">Public</Text>
              <Switch value={isPublic} onValueChange={setIsPublic} />
            </View>
            <TouchableOpacity
              className="p-2 bg-blue-500 rounded"
              onPress={handleUpload}
            >
              <Text className="text-white text-center">Upload</Text>
            </TouchableOpacity>
            <TouchableOpacity
              className="p-2 mt-2 bg-gray-200 rounded"
              onPress={() => setShowUploadModal(false)}
            >
              <Text className="text-center">Cancel</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
      <Modal visible={showLoginModal} transparent animationType="slide">
        <View className="flex-1 justify-center items-center bg-black/50">
          <View className="bg-white p-5 rounded-lg w-3/4">
            <Text className="text-lg font-bold mb-4">Login</Text>
            <TextInput
              className="border p-2 mb-2"
              placeholder="User ID"
              value={userId}
              onChangeText={setUserId}
            />
            <TextInput
              className="border p-2 mb-2"
              placeholder="PIN"
              value={pin}
              onChangeText={setPin}
              secureTextEntry
            />
            <TouchableOpacity
              className="p-2 bg-blue-500 rounded"
              onPress={handleLogin}
            >
              <Text className="text-white text-center">Login</Text>
            </TouchableOpacity>
            <TouchableOpacity
              className="p-2 mt-2 bg-gray-200 rounded"
              onPress={() => setShowLoginModal(false)}
            >
              <Text className="text-center">Cancel</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
};

export default NotesPage;
--- END OF FILE app/notes/[...path].js ---

--- START OF FILE app/pages/BusTracker.jsx ---
import React, { useState, useEffect } from 'react';
import { View, Text, ScrollView, TouchableOpacity, StatusBar, SafeAreaView, ImageBackground } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Ionicons } from '@expo/vector-icons';

// Bus schedule data
const busSchedules = {
  "S.S College": {
    "EDAVANNAPPARA": [
      "06:30 AM", "06:35 AM", "06:40 AM", "06:55 AM", "07:20 AM", "07:40 AM", "07:55 AM",
      "08:10 AM", "08:15 AM", "08:30 AM", "08:40 AM", "08:50 AM", "09:05 AM", "09:25 AM",
      "09:40 AM", "10:05 AM", "10:13 AM", "10:18 AM", "10:40 AM", "10:50 AM", "11:05 AM",
      "11:20 AM", "11:38 AM", "11:55 AM", "12:03 PM", "12:18 PM", "12:30 PM", "12:40 PM",
      "01:08 PM", "01:32 PM", "01:42 PM", "01:50 PM", "01:55 PM", "02:05 PM", "02:15 PM",
      "02:25 PM", "02:48 PM", "03:00 PM", "03:10 PM", "03:25 PM", "03:40 PM", "04:05 PM",
      "04:20 PM", "04:37 PM", "04:50 PM", "04:55 PM", "05:10 PM", "05:22 PM", "05:35 PM",
      "05:45 PM", "05:53 PM", "05:55 PM", "06:03 PM", "06:13 PM", "06:23 PM", "06:35 PM"
    ],
    "AREEKODE": [
      "07:06 AM", "07:28 AM", "07:43 AM", "07:53 AM", "08:03 AM", "08:20 AM", "08:35 AM", 
      "08:50 AM", "09:13 AM", "09:23 AM", "09:35 AM", "09:43 AM", "10:02 AM", "10:20 AM", 
      "10:31 AM", "10:35 AM", "10:53 AM", "11:03 AM", "11:20 AM", "11:30 AM", "11:38 AM", 
      "11:58 AM", "12:18 PM", "12:28 PM", "12:33 PM", "12:43 PM", "12:50 PM", "01:03 PM",
      "01:11 PM", "01:18 PM", "01:31 PM", "01:48 PM", "02:03 PM", "02:16 PM", "02:33 PM", 
      "02:48 PM", "03:10 PM", "03:38 PM", "03:48 PM", "03:58 PM", "04:08 PM", "04:16 PM", 
      "04:33 PM", "04:50 PM", "04:58 PM", "05:10 PM", "05:18 PM", "05:38 PM", "05:43 PM", 
      "06:01 PM", "06:10 PM", "06:18 PM", "06:23 PM", "06:38 PM", "06:48 PM", "07:08 PM"
    ]
  },
  "EDAVANNAPPARA": {
    "S.S College": [
      "08:00 AM", "08:15 AM", "08:35 AM", "08:55 AM", "09:15 AM", "09:30 AM", "09:45 AM",
      "10:05 AM", "10:20 AM", "10:35 AM", "10:50 AM", "11:10 AM", "11:25 AM", "11:40 AM",
      "12:00 PM", "12:15 PM", "12:30 PM", "12:45 PM", "01:00 PM", "01:15 PM", "01:30 PM",
      "01:45 PM", "02:00 PM", "02:15 PM", "02:30 PM", "02:45 PM", "03:00 PM", "03:15 PM",
      "03:30 PM", "03:45 PM", "04:00 PM", "04:15 PM", "04:30 PM", "04:45 PM", "05:00 PM",
      "05:15 PM", "05:30 PM", "05:45 PM", "06:00 PM", "06:15 PM", "06:30 PM"
    ],
    "AREEKODE": [] // Will be filled with calculated times
  },
  "AREEKODE": {
    "S.S College": [],
    "EDAVANNAPPARA": [] // Will be filled with calculated times
  }
};

// Calculate EDAVANNAPPARA to AREEKODE (18 + 2 = 20 minutes travel time)
busSchedules["EDAVANNAPPARA"]["AREEKODE"] = busSchedules["EDAVANNAPPARA"]["S.S College"].map(time => {
  return addMinutesToTime(time, 0);
});

// Calculate AREEKODE to S.S College (direct, approx 2 minutes)
busSchedules["AREEKODE"]["S.S College"] = busSchedules["S.S College"]["EDAVANNAPPARA"].map(time => {
  return addMinutesToTime(time, -2); // Adding 30 min for return journey
});

// Calculate AREEKODE to EDAVANNAPPARA (approx 18 minutes)
busSchedules["AREEKODE"]["EDAVANNAPPARA"] = busSchedules["S.S College"]["EDAVANNAPPARA"].map(time => {
  return addMinutesToTime(time, -2); // Adding 28 min for return journey
});

// Helper function to add minutes to a time string
function addMinutesToTime(timeStr, minutesToAdd) {
  const [time, period] = timeStr.split(' ');
  const [hours, minutes] = time.split(':').map(Number);
  
  let totalMinutes = hours * 60 + minutes;
  totalMinutes += minutesToAdd;
  
  let newHours = Math.floor(totalMinutes / 60);
  let newMinutes = totalMinutes % 60;
  
  let newPeriod = period;
  if (newHours > 12) {
    newHours -= 12;
    if (period === 'AM') newPeriod = 'PM';
  }
  
  if (newHours === 12 && period === 'AM') {
    newPeriod = 'PM';
  }
  
  return `${String(newHours).padStart(2, '0')}:${String(newMinutes).padStart(2, '0')} ${newPeriod}`;
}

// Convert time string to minutes since midnight for comparison
function timeToMinutes(timeStr) {
  const [time, period] = timeStr.split(' ');
  const [hours, minutes] = time.split(':').map(Number);
  
  let totalMinutes = hours * 60 + minutes;
  if (period === 'PM' && hours !== 12) {
    totalMinutes += 12 * 60;
  } else if (period === 'AM' && hours === 12) {
    totalMinutes -= 12 * 60;
  }
  
  return totalMinutes;
}

// Get current time in the format "HH:MM AM/PM"
function getCurrentTime() {
  const now = new Date();
  let hours = now.getHours();
  const minutes = now.getMinutes();
  const period = hours >= 12 ? 'PM' : 'AM';
  
  hours = hours % 12;
  hours = hours ? hours : 12; // Convert 0 to 12
  
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} ${period}`;
}

export default function BusScheduleApp() {
  const [origin, setOrigin] = useState("S.S College");
  const [destination, setDestination] = useState("EDAVANNAPPARA");
  const [currentTime, setCurrentTime] = useState(getCurrentTime());
  const [nextBus, setNextBus] = useState(null);
  
  const locations = ["S.S College", "EDAVANNAPPARA", "AREEKODE"];
  
  useEffect(() => {
    // Update current time every minute
    const timer = setInterval(() => {
      setCurrentTime(getCurrentTime());
    }, 60000);
    
    return () => clearInterval(timer);
  }, []);
  
  useEffect(() => {
    // Find next bus whenever origin/destination/time changes
    findNextBus();
  }, [origin, destination, currentTime]);
  
  const findNextBus = () => {
    if (!busSchedules[origin] || !busSchedules[origin][destination] || busSchedules[origin][destination].length === 0) {
      setNextBus(null);
      return;
    }
    
    const currentMinutes = timeToMinutes(currentTime);
    let closestBus = null;
    let smallestDifference = Infinity;
    
    for (const time of busSchedules[origin][destination]) {
      const busMinutes = timeToMinutes(time);
      const difference = busMinutes - currentMinutes;
      
      if (difference >= 0 && difference < smallestDifference) {
        smallestDifference = difference;
        closestBus = {
          time,
          minutes: difference
        };
      }
    }
    
    // If no bus found for today, get the first bus for tomorrow
    if (!closestBus && busSchedules[origin][destination].length > 0) {
      const firstBusTomorrow = busSchedules[origin][destination][0];
      const tomorrowMinutes = timeToMinutes(firstBusTomorrow) + 24 * 60;
      const difference = tomorrowMinutes - currentMinutes;
      
      closestBus = {
        time: firstBusTomorrow,
        minutes: difference,
        tomorrow: true
      };
    }
    
    setNextBus(closestBus);
  };
  
  const handleOriginChange = (newOrigin) => {
    if (newOrigin === destination) {
      // Swap origin and destination
      setOrigin(newOrigin);
      setDestination(origin);
    } else {
      setOrigin(newOrigin);
    }
  };
  
  const handleDestinationChange = (newDestination) => {
    if (newDestination === origin) {
      // Swap origin and destination
      setDestination(newDestination);
      setOrigin(destination);
    } else {
      setDestination(newDestination);
    }
  };
  
  const formatTimeRemaining = (minutes) => {
    if (minutes < 60) {
      return `${minutes} min`;
    } else {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${hours}h ${mins}m`;
    }
  };
  
  const getRouteInfo = () => {
    if (origin === "S.S College" && destination === "EDAVANNAPPARA") {
      return "Direct - 18 min";
    } else if (origin === "S.S College" && destination === "AREEKODE") {
      return "Direct - 2 min";
    } else if (origin === "EDAVANNAPPARA" && destination === "S.S College") {
      return "Direct - 18 min";
    } else if (origin === "EDAVANNAPPARA" && destination === "AREEKODE") {
      return "Direct - 20 min";
    } else if (origin === "AREEKODE" && destination === "S.S College") {
      return "Direct - 2 min";
    } else if (origin === "AREEKODE" && destination === "EDAVANNAPPARA") {
      return "Direct - 20 min";
    }
    return "Route info unavailable";
  };
  
  return (
    <SafeAreaView className="flex-1">
      <StatusBar barStyle="light-content" backgroundColor="#000" />
      <ImageBackground
        source={{ uri: 'https://images.unsplash.com/photo-1741016825495-1faf2afc19d6?q=80&w=1888&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D' }}
        className="flex-1"
      >
        <LinearGradient
          colors={['rgba(0,0,0,0.7)', 'rgba(20,20,40,0.9)']}
          className="flex-1 px-5 pt-5"
        >
          <View className="flex-row justify-between pb-5">
            <Text className="font-bold text-3xl text-white">BusTime</Text>
            <Text className="text-base text-white bg-black/30 px-3 py-1.5 rounded-16">{currentTime}</Text>
          </View>
          
          <View className="bg-white/5 rounded-lg p-4 mb-4">
            <View className="mb-3">
              <Text className="text-sm text-gray-400 mb-2">From</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {locations.map((loc) => (
                  <TouchableOpacity
                    key={`origin-${loc}`}
                    className={`px-4 py-2 mr-2 rounded-lg  ${origin === loc ? 'bg-[#3f51b5]' : 'bg-white/10'}`}
                    onPress={() => handleOriginChange(loc)}
                  >
                    <Text className={`text-white  ${origin === loc ? 'font-bold' : 'font-medium'}`}>
                      {loc}
                    </Text>
                  </TouchableOpacity>
                ))}
              </ScrollView>
            </View>
            
            <TouchableOpacity 
              className="self-center bg-white/10 rounded-lg w-10 h-10 justify-center items-center my-1.5"
              onPress={() => {
                const temp = origin;
                setOrigin(destination);
                setDestination(temp);
              }}
            >
              <Ionicons name="swap-vertical" size={24} color="#fff" />
            </TouchableOpacity>
            
            <View className="mb-3">
              <Text className="text-sm text-gray-400 mb-2">To</Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {locations.map((loc) => (
                  <TouchableOpacity
                    key={`dest-${loc}`}
                    className={`px-4 py-2 mr-2 rounded-lg  ${destination === loc ? 'bg-[#3f51b5]' : `${loc === origin ? 'bg-white/5' : 'bg-white/10'}`}`}
                    onPress={() => handleDestinationChange(loc)}
                    disabled={loc === origin}
                  >
                    <Text className={` ${destination === loc ? 'font-bold' : ' font-medium'} ${loc === origin ? 'text-white/30' : 'text-white'}`}>
                      {loc}
                    </Text>
                  </TouchableOpacity>
                ))}
              </ScrollView>
            </View>
          </View>
          
          <View className="bg-[#3f51b5]/30 rounded-lg p-4 mb-4">
            <Text className="text-base text-gray-400 mb-2">Next Bus</Text>
            {nextBus ? (
              <>
                <View className="flex-row items-baseline mb-3">
                  <Text className="text-[32px] font-bold text-white">{nextBus.time}</Text>
                  {nextBus.tomorrow && (
                    <Text className="text-xs text-orange-500 ml-2 px-2 py-0.5 bg-orange-500/20 rounded">Tomorrow</Text>
                  )}
                </View>
                
                <View className="flex-row justify-between bg-black/20 rounded-lg p-2">
                  <View className="flex-row items-center">
                    <Ionicons name="time-outline" size={20} color="#fff" />
                    <Text className="text-white ml-1">
                      {formatTimeRemaining(nextBus.minutes)} remaining
                    </Text>
                  </View>
                  
                  <View className="flex-row items-center">
                    <Ionicons name="git-network-outline" size={20} color="#fff" />
                    <Text className="text-white ml-1">{getRouteInfo()}</Text>
                  </View>
                </View>
              </>
            ) : (
              <Text className="text-white text-base text-center my-4">No bus schedule available for this route</Text>
            )}
          </View>
          
          <View className="flex-1 bg-white/5 rounded-lg p-4 mb-10">
            <Text className="text-base text-gray-400 mb-3">Today's Schedule</Text>
            {busSchedules[origin] && busSchedules[origin][destination] && busSchedules[origin][destination].length > 0 ? (
              <ScrollView className="flex-1">
                {busSchedules[origin][destination].map((time, index) => {
                  const isPassed = timeToMinutes(time) < timeToMinutes(currentTime);
                  const isNext = nextBus && time === nextBus.time;
                  
                  return (
                    <View 
                      key={index} 
                      className={`flex-row justify-between items-center py-2.5 border-b border-white/5 ${isPassed ? 'opacity-50' : ''} ${isNext ? 'bg-[#3f51b5]/20 rounded-lg px-2' : ''}`}
                    >
                      <Text className={`text-white text-base ${isPassed ? 'line-through' : ''} ${isNext ? 'font-bold' : ''}`}>
                        {time}
                      </Text>
                      
                      {isNext && (
                        <View className="bg-[#3f51b5] px-2 py-0.5 rounded">
                          <Text className="text-white text-xs font-bold">NEXT</Text>
                        </View>
                      )}
                    </View>
                  );
                })}
              </ScrollView>
            ) : (
              <Text className="text-white text-base text-center my-4">No schedule available for this route</Text>
            )}
          </View>
        </LinearGradient>
      </ImageBackground>
    </SafeAreaView>
  );
}
--- END OF FILE app/pages/BusTracker.jsx ---

--- START OF FILE app/pages/Home.jsx ---
import React, { useEffect, useState, useCallback, useMemo } from 'react';
import { View, Text, ScrollView, TouchableOpacity, ActivityIndicator, StyleSheet } from 'react-native';
import { useRouter } from 'expo-router';
import { Ionicons, MaterialIcons, MaterialCommunityIcons, Feather } from '@expo/vector-icons';
import * as FileSystem from 'expo-file-system';
import { SafeAreaView } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';

// Define initial course data (unchanged) - TRUNCATED FOR BREVITY
const initialCourseData = { /* ... same as before ... */ };

// --- Constants ---
const COURSE_DATA_FILE = `${FileSystem.documentDirectory}course.json`;
const PROGRESS_DATA_FILE = `${FileSystem.documentDirectory}progress.json`;
const PROFILE_DATA_FILE = `${FileSystem.documentDirectory}profile.json`;
const DATA_REFRESH_INTERVAL = 60 * 1000; // 1 minute
const XP_PER_VIEW = 5;
const XP_LEVEL_FACTOR = 100;

// --- Helper Functions ---

/**
 * Generates a consistent, serialised ID from course title and module text.
 * Converts to lowercase, replaces non-alphanumeric chars with underscores.
 * IMPORTANT: Relies on stable and unique title/text combinations.
 * @param {string} courseTitle
 * @param {string} moduleText
 * @returns {string} A generated module identifier
 */
const generateModuleId = (courseTitle, moduleText) => {
    if (!courseTitle || !moduleText) {
        console.warn("Cannot generate module ID without courseTitle and moduleText");
        return `invalid_module_${Date.now()}_${Math.random()}`;
    }
    const safeTitle = courseTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_');
    const safeText = moduleText.toLowerCase().replace(/[^a-z0-9]+/g, '_');
    return `course_${safeTitle}__module_${safeText}`;
};

const calculateLevelInfo = (totalXP) => {
    let level = 1;
    let xpForNextLevel = XP_LEVEL_FACTOR;
    let xpAtLevelStart = 0;
    while (totalXP >= xpAtLevelStart + xpForNextLevel) {
        xpAtLevelStart += xpForNextLevel;
        level++;
        // Example: Level 1 needs 100, Level 2 needs 2*2*100=400, Level 3 needs 3*3*100=900 etc.
        // You might want a simpler progression like level * XP_LEVEL_FACTOR
        xpForNextLevel = level * level * XP_LEVEL_FACTOR;
    }
    const xpInCurrentLevel = totalXP - xpAtLevelStart;
    return { level, xpInCurrentLevel, xpForNextLevel, totalXP };
};


// --- Data Management Hook ---
const useGamifiedData = () => {
    const [courseData, setCourseData] = useState(null);
    const [progressData, setProgressData] = useState({}); // { generatedModuleId: { views: number, completed: boolean } }
    const [profileData, setProfileData] = useState({ totalXP: 0 });
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);

    // --- File System Operations ---
    // saveData remains largely the same, but we won't await it directly in callbacks
    const saveData = useCallback(async (filePath, data) => {
        try {
            await FileSystem.writeAsStringAsync(filePath, JSON.stringify(data), { encoding: FileSystem.EncodingType.UTF8 });
            // console.log(`Data saved successfully to ${filePath}`); // Optional: for debugging
        } catch (err) {
            // Log error, could potentially add more robust error handling/reporting later
            console.error(`Error saving data to ${filePath}:`, err);
            // Maybe update an error state specific to saving? For now, just log.
        }
    }, []); // No dependencies needed

    // loadData remains the same
    const loadData = useCallback(async (filePath, defaultData) => {
        try {
            const info = await FileSystem.getInfoAsync(filePath);
            if (info.exists) {
                const fileContent = await FileSystem.readAsStringAsync(filePath, { encoding: FileSystem.EncodingType.UTF8 });
                // Add extra validation for parsed data
                try {
                    const parsedData = JSON.parse(fileContent);
                     // Ensure it's a non-null object before returning
                    if (typeof parsedData === 'object' && parsedData !== null) {
                         return parsedData;
                    } else {
                        console.warn(`Invalid data structure loaded from ${filePath}. Using default.`);
                        await saveData(filePath, defaultData); // Overwrite corrupted/invalid data
                        return defaultData;
                    }
                } catch (parseError) {
                    console.error(`Error parsing JSON from ${filePath}:`, parseError);
                    setError(`Failed to parse ${filePath.split('/').pop()}. Using defaults and overwriting.`);
                    await saveData(filePath, defaultData); // Overwrite corrupted data
                    return defaultData;
                }
            } else {
                // File doesn't exist, create it with default data
                await saveData(filePath, defaultData);
                return defaultData;
            }
        } catch (err) {
            console.error(`Error loading data from ${filePath}:`, err);
            setError(`Failed to load ${filePath.split('/').pop()}. Using defaults.`);
            return defaultData; // Return default data on error
        }
    }, [saveData]); // Add saveData as dependency for the overwrite case

    // downloadCourseData remains the same
     const downloadCourseData = useCallback(async (currentData) => {
        try {
            // Use cache-busting query param if needed
            const response = await fetch(`https://ihjas-ahammed.github.io/course.json?cb=${Date.now()}`);
            if (response.ok) {
                const downloadedData = await response.json();
                if (JSON.stringify(downloadedData) !== JSON.stringify(currentData)) {
                    console.log("Downloaded new course data.");
                    setCourseData(downloadedData);
                    // Save the new data in the background
                    saveData(COURSE_DATA_FILE, downloadedData);
                } else {
                    console.log("Course data is up-to-date.");
                }
            } else {
                 console.warn(`Failed to download course data: ${response.status}`);
                 // Optionally set an error state if download fails consistently
            }
        } catch (err) {
            console.log('No internet or failed to download course data:', err);
             // Optionally set an error state
        }
    }, [saveData]); // Add saveData dependency

    // useEffect for initialization and refresh remains the same structure
     useEffect(() => {
        let isMounted = true;
        const initializeData = async () => {
            setIsLoading(true);
            setError(null); // Reset error on load
            // Load all data concurrently
            const [loadedCourses, loadedProgress, loadedProfile] = await Promise.all([
                loadData(COURSE_DATA_FILE, initialCourseData),
                loadData(PROGRESS_DATA_FILE, {}),
                loadData(PROFILE_DATA_FILE, { totalXP: 0 }),
            ]);

            if (isMounted) {
                setCourseData(loadedCourses);
                setProgressData(loadedProgress);
                setProfileData(loadedProfile);
                setIsLoading(false);
                // Trigger background download after initial load
                downloadCourseData(loadedCourses);
            }
        };

        initializeData();

        // Set up interval for periodic refresh
        const intervalId = setInterval(() => {
             // Use functional update for setCourseData to get the latest state
             // if downloadCourseData relies on it, though here it receives `current` directly.
             setCourseData(current => {
                downloadCourseData(current); // Trigger background download
                return current; // Return current state, download will update it later if needed
             });
        }, DATA_REFRESH_INTERVAL);

        return () => {
            isMounted = false;
            clearInterval(intervalId); // Clear interval on unmount
        };
    }, [loadData, downloadCourseData]); // Add dependencies


    // --- Gamification Actions ---

    const incrementViewCount = useCallback((generatedModuleId) => {
        if (!generatedModuleId || generatedModuleId.startsWith('invalid_module')) {
            console.warn("incrementViewCount called with invalid generatedModuleId:", generatedModuleId);
            return;
        }

        // --- Optimistic UI Updates ---
        // Update progress state immediately
        const newProgressData = { ...progressData };
        const currentModuleProgress = newProgressData[generatedModuleId] || { views: 0, completed: false };
        newProgressData[generatedModuleId] = { ...currentModuleProgress, views: currentModuleProgress.views + 1 };
        setProgressData(newProgressData);

        // Update profile state immediately
        const newTotalXP = profileData.totalXP + XP_PER_VIEW;
        const newProfileData = { ...profileData, totalXP: newTotalXP };
        setProfileData(newProfileData);
        // --- End Optimistic Updates ---

        // --- Trigger Background Saves (Fire and Forget) ---
        // We don't await these promises. saveData handles errors internally.
        saveData(PROGRESS_DATA_FILE, newProgressData);
        saveData(PROFILE_DATA_FILE, newProfileData);
        // --- End Background Saves ---

        // console.log(`Module ${generatedModuleId} viewed (optimistic). Total XP: ${newTotalXP}`);

    }, [progressData, profileData, saveData]); // Include saveData dependency

    const toggleModuleCompletion = useCallback((generatedModuleId) => {
        if (!generatedModuleId || generatedModuleId.startsWith('invalid_module')) {
            console.warn("toggleModuleCompletion called with invalid generatedModuleId:", generatedModuleId);
            return;
        }

        // --- Optimistic UI Update ---
        const newProgressData = { ...progressData };
        const currentModuleProgress = newProgressData[generatedModuleId] || { views: 0, completed: false };
        const newModuleProgress = { ...currentModuleProgress, completed: !currentModuleProgress.completed };
        newProgressData[generatedModuleId] = newModuleProgress;
        setProgressData(newProgressData);
         // --- End Optimistic Update ---

        // --- Trigger Background Save (Fire and Forget) ---
        saveData(PROGRESS_DATA_FILE, newProgressData);
        // --- End Background Save ---

        // console.log(`Module ${generatedModuleId} completion toggled to: ${newModuleProgress.completed} (optimistic)`);

    }, [progressData, saveData]); // Include saveData dependency

    // levelInfo calculation remains the same
    const levelInfo = useMemo(() => calculateLevelInfo(profileData.totalXP), [profileData.totalXP]);

    return {
        courseData,
        progressData,
        profileData,
        levelInfo,
        isLoading,
        error,
        incrementViewCount, // Now performs background save
        toggleModuleCompletion, // Now performs background save
    };
};


// --- Gamified Components ---

// Module Button (No changes needed here)
const ModuleButton = ({ module, generatedModuleId, progress, onOpen, onToggleComplete, onQuiz, last }) => {
    const router = useRouter();
    const { text, path, webview, qa2 } = module;
    const { views = 0, completed = false } = progress || {};

    const handleOpenPress = () => {
        onOpen(generatedModuleId); // Calls incrementViewCount
        if (webview) router.push(`/webview${path}`); else router.push(`/notes${path}`);
    };

    const handleTogglePress = () => {
        onToggleComplete(generatedModuleId); // Calls toggleModuleCompletion
    };

    const handleQuizPress = () => {
        onQuiz(generatedModuleId);
    };

    return (
        <View className={`py-3 ${!last ? 'border-b border-gray-200 dark:border-gray-700' : ''} flex-row items-center justify-between space-x-2`}>
            {/* Checkbox */}
             <TouchableOpacity onPress={handleTogglePress} className="p-1" accessibilityLabel={`Mark ${text} as ${completed ? 'incomplete' : 'complete'}`}>
                {completed ? (
                    <MaterialCommunityIcons name="checkbox-marked" size={24} color="#10b981" />
                ) : (
                    <MaterialCommunityIcons name="checkbox-blank-outline" size={24} color="#6b7280" />
                )}
            </TouchableOpacity>

            {/* Text & Views */}
            <TouchableOpacity
                className="flex-1 flex-col"
                activeOpacity={0.7}
                onPress={handleOpenPress}
                accessibilityLabel={`Open module: ${text}, Viewed ${views} times`}
            >
                <Text className={`text-base font-medium ${completed ? 'text-gray-500 dark:text-gray-400 line-through' : 'text-gray-800 dark:text-gray-100'}`}>
                    {text}
                </Text>
                 {views > 0 && (
                    <Text className="text-xs text-indigo-600 dark:text-indigo-400 mt-1">
                        Viewed {views} {views === 1 ? 'time' : 'times'} (+{views * XP_PER_VIEW} XP)
                    </Text>
                )}
            </TouchableOpacity>

            {/* Quiz Button */}
             {qa2 && (
                <TouchableOpacity
                    className="p-2 rounded-full bg-indigo-50 dark:bg-indigo-900/50 ml-2"
                    activeOpacity={0.7}
                    onPress={handleQuizPress}
                    accessibilityLabel={`Take quiz for ${text}`}
                >
                    <MaterialIcons name="quiz" size={20} color="#6366f1" />
                </TouchableOpacity>
            )}
        </View>
    );
};

// XPProgressBar (No changes needed)
const XPProgressBar = ({ current, max, height = 8, backgroundColor = 'bg-gray-200 dark:bg-gray-600', fillColor = 'bg-amber-500' }) => {
    const progress = max > 0 ? Math.min(current / max, 1) : 0; // Ensure progress doesn't exceed 1
    return (
      <View className={`h-${height / 4} ${backgroundColor} rounded-full overflow-hidden`}>
        {/* Use inline style for width percentage */}
        <View style={[{ height: '100%', width: `${progress * 100}%` }, styles.progressBarFill]} className={fillColor} />
      </View>
    );
};


// Course Card (No changes needed here, relies on parent passing correct callbacks)
const CourseCard = ({ title, modules = [], progressData, onOpenModule, onToggleModuleComplete, onQuiz }) => {

    const completedModules = modules.filter(m => {
        const generatedId = generateModuleId(title, m.text);
        return progressData[generatedId]?.completed;
    }).length;
    const totalModules = modules.length;
    const progress = totalModules > 0 ? completedModules / totalModules : 0;
    const isMastered = progress === 1 && totalModules > 0;

    const handleQuiz = (generatedModuleId) => {
        const module = modules.find(m => generateModuleId(title, m.text) === generatedModuleId);
        if (module?.qa2) {
             const data = JSON.stringify({ title: module.text, qa: module.qa2 });
             onQuiz(data);
        } else {
            console.warn(`Quiz data not found for generated module ID: ${generatedModuleId}`);
        }
    };

    return (
        <View className="bg-white dark:bg-gray-800 rounded-xl overflow-hidden shadow-lg border border-gray-100 dark:border-gray-700 mb-5" accessibilityLabel={`Course: ${title}, ${completedModules} of ${totalModules} modules completed.`}>
             {/* Header */}
             <LinearGradient
                colors={isMastered ? ['#10b981', '#059669'] : ['#6366f1', '#4f46e5']}
                start={{ x: 0, y: 0 }} end={{ x: 1, y: 1 }}
                className="p-4 flex-row items-center justify-between"
            >
                <View className="flex-row items-center">
                    <MaterialIcons name="school" size={26} color="white" />
                    <Text className="text-xl font-bold text-white ml-3">{title}</Text>
                </View>
                {isMastered && (
                    <View className="bg-amber-400 p-1 rounded-full shadow-md" accessibilityLabel="Course Mastered">
                        <MaterialCommunityIcons name="trophy-award" size={24} color="#a16207" />
                    </View>
                )}
            </LinearGradient>

            {/* Content */}
            <View className="p-5">
                {/* Progress Section */}
                 <View className="mb-4">
                    <View className="flex-row justify-between items-center mb-1">
                        <Text className="text-sm font-medium text-gray-600 dark:text-gray-300">Mastery</Text>
                        <Text className="text-sm font-bold text-indigo-600 dark:text-indigo-400">
                            {completedModules} / {totalModules} Completed
                        </Text>
                    </View>
                    <View className="h-2 bg-gray-200 dark:bg-gray-600 rounded-full overflow-hidden">
                        <View
                        // Use inline style for width percentage
                        style={[{ height: '100%', width: `${progress * 100}%` }, styles.progressBarFill]}
                        className={isMastered ? "bg-emerald-500" : "bg-indigo-500"}
                        />
                    </View>
                </View>

                {/* Module List */}
                <View className="flex flex-col">
                    {modules.map((module, idx) => {
                         const generatedModuleId = generateModuleId(title, module.text);
                         return (
                            <ModuleButton
                                key={generatedModuleId}
                                module={module}
                                generatedModuleId={generatedModuleId}
                                progress={progressData[generatedModuleId]}
                                onOpen={onOpenModule}
                                onToggleComplete={onToggleModuleComplete}
                                onQuiz={handleQuiz}
                                last={idx === modules.length - 1}
                            />
                         );
                    })}
                </View>
            </View>
        </View>
    );
};

// --- Main Home Screen ---
// No changes needed here, uses the optimized hook
const Home = () => {
    const router = useRouter();
    const {
        courseData,
        progressData,
        levelInfo,
        isLoading,
        error,
        incrementViewCount,      // Now triggers background save
        toggleModuleCompletion,  // Now triggers background save
    } = useGamifiedData();

    const handleQuizNavigation = (stringifiedData) => {
         // Ensure data is properly encoded for URL
         router.push(`/cog?dt=${encodeURIComponent(stringifiedData)}`);
    }

    // Loading State
     if (isLoading) {
        return (
            <LinearGradient colors={['#f3f4f6', '#e5e7eb']} style={styles.containerCenter}>
                <ActivityIndicator size="large" color="#6366f1" />
                <Text className="mt-3 text-gray-600">Loading your learning journey...</Text>
            </LinearGradient>
        );
    }

    // Error State (Partial data might still be shown if courseData exists)
     if (error && !courseData) {
        return (
            <SafeAreaView style={styles.containerCenter} className="bg-red-100">
                <MaterialIcons name="error-outline" size={40} color="#dc2626" />
                <Text className="mt-3 text-red-700 text-center px-5">{error}</Text>
                <Text className="mt-2 text-red-500 text-center px-5">Could not load critical course data.</Text>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView className="flex-1 bg-gray-50 dark:bg-gray-900">
            {/* Header */}
            <View className="p-4 pt-2 border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm">
                <View className="flex-row justify-between items-center mb-1">
                     <Text className="text-lg font-bold text-amber-600 dark:text-amber-400" accessibilityLabel={`Current level: ${levelInfo.level}`}>Level {levelInfo.level}</Text>
                    <Text className="text-sm font-medium text-gray-700 dark:text-gray-200" accessibilityLabel={`Total experience points: ${levelInfo.totalXP}`}>Total XP: {levelInfo.totalXP}</Text>
                </View>
                 <XPProgressBar current={levelInfo.xpInCurrentLevel} max={levelInfo.xpForNextLevel} />
                <Text className="text-xs text-gray-500 dark:text-gray-400 text-right mt-1" accessibilityLabel={`${levelInfo.xpInCurrentLevel} of ${levelInfo.xpForNextLevel} experience points needed for next level`}>
                    {levelInfo.xpInCurrentLevel} / {levelInfo.xpForNextLevel} XP to Level {levelInfo.level + 1}
                </Text>
                {/* Display non-critical errors (like load errors where defaults were used) */}
                {error && <Text className="text-xs text-orange-500 mt-1 text-center" role="alert">{error}</Text>}
            </View>

            <ScrollView className="flex-1" contentContainerStyle={{ padding: 16 }}>
                {/* Render Course Cards */}
                {courseData?.semester2?.map((course, idx) => {
                     const courseKey = `course-${idx}-${generateModuleId(course.title, '')}`; // Use title in key for better stability
                     return (
                        <CourseCard
                            key={courseKey}
                            title={course.title}
                            modules={course.modules}
                            progressData={progressData}
                            onOpenModule={incrementViewCount}
                            onToggleModuleComplete={toggleModuleCompletion}
                            onQuiz={handleQuizNavigation}
                        />
                     );
                })}

                 {/* Empty State */}
                 {(!courseData || !courseData.semester2 || courseData.semester2.length === 0) && !isLoading && (
                    <View className="items-center justify-center mt-10 p-5 bg-white dark:bg-gray-800 rounded-lg shadow">
                        <MaterialCommunityIcons name="cloud-question" size={40} color="#9ca3af" />
                        <Text className="text-gray-500 dark:text-gray-400 mt-3 text-center">No courses available right now. Check back later!</Text>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    );
};

const styles = StyleSheet.create({
    containerCenter: { flex: 1, justifyContent: 'center', alignItems: 'center' },
    // Make sure progressBarFill style doesn't conflict with Tailwind classes
    progressBarFill: { borderRadius: 9999 },
});

export default Home;
--- END OF FILE app/pages/Home.jsx ---

--- START OF FILE app/pages/Learn.jsx ---
import { get, getDatabase, ref } from 'firebase/database';
import React, { useEffect, useState, useCallback } from 'react';
import { View, Text, FlatList, TouchableOpacity, ActivityIndicator, RefreshControl } from 'react-native';
import { AnimatedCircularProgress } from 'react-native-circular-progress';
import * as SecureStore from 'expo-secure-store';
import { Ionicons } from '@expo/vector-icons';
import { router, useNavigation, useFocusEffect } from 'expo-router';

const calculateLevel = (score, maxScore) => {
  let l = 1;
  let s = score;
  let m = score;

  while(s > 0) {
    s -= maxScore * Math.pow(2, l-1);
    if(m > maxScore * Math.pow(2, l-1)) m = s;
    if(s > 0) l++;
  }

  return { level: l, progress: m }; // Max level
};

const getLevelColor = (level, totalLevels = 15) => {
  // Make sure level is within bounds
  level = Math.max(1, Math.min(level, totalLevels));
  
  // Define base colors for interpolation
  const baseColors = [
    { r: 79, g: 70, b: 229 },   // Indigo (#4F46E5) - Starting color
    { r: 16, g: 185, b: 129 },  // Emerald (#10B981)
    { r: 245, g: 158, b: 11 },  // Amber (#F59E0B)
    { r: 239, g: 68, b: 68 },   // Red (#EF4444)
    { r: 139, g: 92, b: 246 }   // Purple (#8B5CF6) - Ending color
  ];
  
  // For dynamic levels, interpolate between base colors
  const segment = (baseColors.length - 1) / (totalLevels - 1);
  const segmentIndex = (level - 1) * segment;
  const lowerIndex = Math.floor(segmentIndex);
  const upperIndex = Math.ceil(segmentIndex);
  
  // If we're exactly on a base color, return it
  if (lowerIndex === upperIndex) {
    const { r, g, b } = baseColors[lowerIndex];
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  }
  
  // Otherwise interpolate between the two closest base colors
  const weight = segmentIndex - lowerIndex;
  const lowerColor = baseColors[lowerIndex];
  const upperColor = baseColors[upperIndex];
  
  const r = Math.round(lowerColor.r + (upperColor.r - lowerColor.r) * weight);
  const g = Math.round(lowerColor.g + (upperColor.g - lowerColor.g) * weight);
  const b = Math.round(lowerColor.b + (upperColor.b - lowerColor.b) * weight);
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
};

const Learn = ({ firebaseApp }) => {
  const [learn, setLearn] = useState([]);
  const [scores, setScores] = useState([]);
  const [levels, setLevels] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [isOnline, setIsOnline] = useState(false);

  const loadCachedData = async () => {
    try {
      const cachedLearnData = await SecureStore.getItemAsync('learn');
      if (cachedLearnData) {
        setLearn(JSON.parse(cachedLearnData));
      }
    } catch (e) {
      console.error('Error loading cached learn data:', e);
    }
  };

  const loadFirebaseData = async (forceOnline = false) => {
    try {
      if (forceOnline) setIsOnline(true);
      else if(!isOnline) return
      
      const db = getDatabase(firebaseApp);
      const learnRef = ref(db, 'learn');
      const snapshot = await get(learnRef);
      
      if (snapshot.exists()) {
        const learnData = snapshot.val();
        setLearn(learnData);
        
        // Cache the data for offline use
        await SecureStore.setItemAsync('learn', JSON.stringify(learnData));
      }
      
      setIsOnline(true);
    } catch (e) {
      console.error('Error loading Firebase data:', e);
      // If we can't connect to Firebase, use cached data
      if (forceOnline) {
        setIsOnline(false);
        await loadCachedData();
      }
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const loadData = async (forceOnline = false) => {
    setLoading(true);
    
    // First try to load cached data for immediate display
    if (!forceOnline) {
      await loadCachedData();
    }
    
    // Then try to load fresh data from Firebase
    await loadFirebaseData(forceOnline);
  };

  const loadScores = async () => {
    try {
      const newScores = [];
      const newLevels = [];
      
      for (let i = 0; i < learn.length; i++) {
        const score = await SecureStore.getItemAsync("score-" + i);
        const scoreValue = score ? parseInt(score) : 0;
        newScores[i] = scoreValue;
        
        const levelInfo = calculateLevel(scoreValue, learn[i].maxScore);
        newLevels[i] = levelInfo;
      }
      
      setScores(newScores);
      setLevels(newLevels);
    } catch (e) {
      console.error('Error loading scores:', e);
    }
  };

  // Initial load
  useEffect(() => {
    loadData();
  }, []);

  // Load scores whenever learn data changes
  useEffect(() => {
    if (learn.length > 0) loadScores();
  }, [learn]);

  // Refresh data when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      loadData();
      return () => {}; // Cleanup function
    }, [])
  );

  const onRefresh = useCallback(() => {
    setRefreshing(true);
    loadData(true); // Force online refresh
  }, []);

  const handleCardPress = (index) => {
    const exp = JSON.stringify({ 
      subject: learn[index],
      index,
      score: scores[index],
      level: levels[index]
    });

    router.push(`/sub?exp=${exp}`);
  };

  if (loading) {
    return (
      <View className="flex-1 justify-center items-center bg-gray-50">
        <ActivityIndicator size="large" color="#4F46E5" />
        <Text className="mt-4 text-base text-gray-600">Loading your courses...</Text>
      </View>
    );
  }

  if (learn.length === 0) {
    return (
      <View className="flex-1 justify-center items-center bg-gray-50 p-6">
        <Ionicons name="school-outline" size={64} color="#9CA3AF" />
        <Text className="mt-4 text-lg text-gray-500 text-center">No courses available yet</Text>
        <TouchableOpacity 
          className="mt-6 bg-indigo-600 py-3 px-6 rounded-full"
          onPress={onRefresh}
        >
          <Text className="text-white font-medium">Refresh</Text>
        </TouchableOpacity>
      </View>
    );
  }

  const renderItem = ({ item, index }) => {
    const levelInfo = levels[index] || { level: 1, progress: 0 };
    const levelColor = getLevelColor(levelInfo.level);
    if(!item) return (
      <View>
        
      </View>
    )
    
    return (
      <TouchableOpacity 
        className="bg-white rounded-2xl mb-4 p-4 shadow"
        onPress={() => handleCardPress(index)}
        activeOpacity={0.7}
      >
        <View className="flex-row items-center justify-between">
          <View className="flex-1 mr-4">
            <Text className="text-lg font-semibold text-gray-800 mb-1">{item.name}</Text>
            <Text className="text-sm text-gray-500">
              {levelInfo.progress || 0} / {(item.maxScore*Math.pow(2,levelInfo.level-1))} points
            </Text>
          </View>
          
          <View className="items-center justify-center">
            <AnimatedCircularProgress
              size={80}
              width={8}
              fill={levelInfo.progress*100/(item.maxScore*Math.pow(2,levelInfo.level-1))}
              tintColor={levelColor}
              backgroundColor="#E0E7FF"
              rotation={0}
              lineCap="round"
            >
              {() => (
                <View className="items-center justify-center">
                  <Text className="text-2xl font-bold text-gray-800">{levelInfo.level}</Text>
                  <Text className="text-xs text-gray-500 font-medium">LV</Text>
                </View>
              )}
            </AnimatedCircularProgress>
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  return (
    <View className="flex-1 p-4 bg-gray-50">
      <FlatList
        data={learn}
        renderItem={renderItem}
        keyExtractor={(_, index) => `learn-${index}`}
        contentContainerStyle={{ paddingBottom: 16 }}
        showsVerticalScrollIndicator={false}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={["#4F46E5"]}
            tintColor="#4F46E5"
          />
        }
      />
    </View>
  );
};

export default Learn;
--- END OF FILE app/pages/Learn.jsx ---

--- START OF FILE app/pages/Misc.jsx ---
import { View, Text, TouchableHighlight } from 'react-native'
import React, { useEffect, useState } from 'react'
import { Ionicons, MaterialIcons } from '@expo/vector-icons'
import { router } from 'expo-router'
import ApiKeyManager from '../components/cog/ApiKeyManager'
import * as SecureStore from 'expo-secure-store'

const Extras = () => {
    const [apiKeyModalVisible, setApiKeyModalVisible] = useState(false);
    const [savedApiKey, setSavedApiKey] = useState('');

    useEffect(()=>{
        const loadApiKey = async () => {
            const apiKey = await SecureStore.getItemAsync('google-api')
            if(apiKey) setSavedApiKey(apiKey)
        }

        loadApiKey()
    },[])


    return (
        <View className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow border border-indigo-100 dark:border-indigo-800">
            <View className="flex-column gap-2 items-center mb-3 p-2 rounded-lg">
                <TouchableHighlight
                    underlayColor="#E0E7FF"
                    onPress={() => router.push("pages/BusTracker")}
                    className="p-4 bg-indigo-50 dark:bg-gray-700 rounded-lg"
                >
                    <View className="flex-row justify-between items-center w-full">
                        <View>
                            <Text className="text-gray-800 dark:text-gray-200 font-semibold">
                                Bus Tracker
                            </Text>
                        </View>
                        <Ionicons name="location" size={24} color="#6366f1" />
                    </View>
                </TouchableHighlight>
                <TouchableHighlight
                    underlayColor="#E0E7FF"
                    onPress={() => setApiKeyModalVisible(true)}
                    className="p-4 bg-indigo-50 dark:bg-gray-700 rounded-lg"
                >
                    <View className="flex-row justify-between items-center w-full">
                        <View>
                            <Text className="text-gray-800 dark:text-gray-200 font-semibold">
                                Manage Google API for AI
                            </Text>
                        </View>
                        <Ionicons name="cog-outline" size={24} color="#6366f1" />
                    </View>
                </TouchableHighlight>
            </View>
            <ApiKeyManager
                isVisible={apiKeyModalVisible}
                onClose={() => setApiKeyModalVisible(false)}
                savedApiKey={savedApiKey}
                onApiKeySaved={(newKey) => setSavedApiKey(newKey)}
            />
        </View>
    )
}

export default Extras
--- END OF FILE app/pages/Misc.jsx ---

--- START OF FILE app/pages/Progress.jsx ---
import React, { useState, useEffect } from 'react';
import { View, ScrollView, TouchableOpacity, ActivityIndicator, Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import { getDatabase, ref, get } from 'firebase/database';
import { MaterialIcons } from '@expo/vector-icons';
import Toast from 'react-native-toast-message';
import { SafeAreaView } from 'react-native-safe-area-context';

import LearningCard from '../components/progress/LearningCard';
import TopicProgress from '../components/progress/TopicProgress';
import ProgressStats from '../components/progress/ProgressStats';
import EditDialog from '../components/progress/EditDialog';
import ImportExportDialog from '../components/progress/ImportExportDialog';
import RoutineModal from '../components/progress/RoutineModal';

const checkNetworkStatus = async () => {
    try {
        const response = await fetch("https://8.8.8.8", {
            method: "HEAD",
            timeout: 5000
        });
        return response.status >= 200 && response.status < 300;
    } catch (error) {
        return false;
    }
};

const Progress = ({ firebaseApp, setPage }) => {
    // State declarations
    const [data, setData] = useState([]);
    const [store, setStore] = useState([]);
    const [activeBook, setActiveBook] = useState(null);
    const [activeTopic, setActiveTopic] = useState(null);
    const [editDialog, setEditDialog] = useState(false);
    const [importExportDialog, setImportExportDialog] = useState(false);
    const [routineModal, setRoutineModal] = useState(false);
    const [currentModule, setCurrentModule] = useState([]);
    const [isOnline, setIsOnline] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    const defaultData = [
        // Your default data structure here
    ];

    // Data loading functions
    const loadData = async () => {
        try {
            const storedData = await SecureStore.getItemAsync('progressData');
            if (storedData) {
                setData(JSON.parse(storedData));
            } else {
                await SecureStore.setItemAsync('progressData', JSON.stringify(defaultData));
                setData(defaultData);
            }
        } catch (error) {
            console.error('Error loading progress data:', error);
        }
    };

    const loadStore = async () => {
        try {
            const db = getDatabase(firebaseApp);
            const storeRef = ref(db, 'store');
            const snapshot = await get(storeRef);
            if (snapshot.exists()) {
                setStore(snapshot.val());
            }
        } catch (error) {
            console.error('Error loading store data:', error);
        }
    };

    // Initial data loading and network checking
    useEffect(() => {
        const initializeData = async () => {
            setIsLoading(true);
            await Promise.all([loadData()]);
            setIsLoading(false);
        };

        initializeData();

        const intervalId = setInterval(async () => {
            setIsOnline(await checkNetworkStatus());
            await Promise.all([loadStore()]);
        }, 5000);

        const netStat = async () => {
            setIsOnline(await checkNetworkStatus());
            await Promise.all([loadStore()]);
        }

        try{
            netStat()
        }catch(e){

        }

        return () => clearInterval(intervalId);
    }, []);

    // Data manipulation functions
    const saveData = async (newData) => {
        try {
            await SecureStore.setItemAsync('progressData', JSON.stringify(newData));
            setData(newData);
        } catch (error) {
            console.error('Error saving progress data:', error);
        }
    };

    const handleImportData = async (importedData) => {
        await saveData(importedData);
    };

    const handleLevelChange = async (bookName, topicName, subtopicName, newValue) => {
        const newData = data.map(book => {
            if (book.name === bookName) {
                return {
                    ...book,
                    topics: book.topics.map(topic => {
                        if (topic.name === topicName) {
                            return {
                                ...topic,
                                subtopics: topic.subtopics.map(subtopic => {
                                    if (subtopic.name === subtopicName) {
                                        return { ...subtopic, level: newValue + 1 };
                                    }
                                    return subtopic;
                                }),
                            };
                        }
                        return topic;
                    }),
                };
            }
            return book;
        });
        await saveData(newData);
    };

    // Progress calculation functions
    const getColorByPercentage = (percentage) => {
        if (percentage < 0 || percentage > 100) return '#94A3B8'; // Slate color for invalid values
        
        // Create a color scale that avoids the indigo/purple spectrum used in backgrounds
        if (percentage < 25) {
            // Low progress - red
            return '#7bed9f'; // Tailwind red-500
        } else if (percentage < 50) {
            // Some progress - yellow/amber
            return '#2ed573'; // Tailwind amber-500
        } else if (percentage < 75) {
            // Good progress - teal (avoiding pure green which might be hard to read)
            return '#1e90ff'; // Tailwind teal-500
        } else {
            // Excellent progress - cyan (avoiding blue/indigo used in the UI)
            return '#6c5ce7'; // Tailwind cyan-500
        }
    };

    const calculateProgress = (items) => {
        if (!items || items.length === 0) return 0;
        const totalPossible = items.length * 6;
        const current = items.reduce((sum, item) => sum + (item.level - 1 || 0), 0);
        return (current / totalPossible) * 100;
    };

    const calculateStats = () => {
        const allTopics = data.flatMap(book => book.topics.flatMap(topic => topic.subtopics));
        const totalProgress = calculateProgress(allTopics);
        const stats = [{
            title: 'Overall Progress',
            value: Math.round(totalProgress),
            color: getColorByPercentage(Math.round(totalProgress)),
            description: 'Total learning progress',
        }];
        
        data.forEach(book => {
            const bookProgress = calculateProgress(book.topics.flatMap(t => t.subtopics));
            stats.push({
                title: book.name,
                value: parseInt(bookProgress),
                color: getColorByPercentage(parseInt(bookProgress)),
                description: '',
            });
        });
        return stats;
    };

    // Button handlers
    const handleCloudButtonClick = () => {
        if (!isOnline) {
            Toast.show({
                type: 'error',
                text1: 'Error',
                text2: 'No network available for import/export',
            });
            return;
        }
        setImportExportDialog(true);
    };

    return (
        <SafeAreaView className="flex-1 bg-white dark:bg-gray-800">
            <View className="h-[1px] bg-indigo-100 dark:bg-indigo-800" />
            <ScrollView contentContainerStyle={{ padding: 16 }}>
                {/* Header */}
                <View className="flex-row justify-end items-center mb-4">
                    <View className="flex-row space-x-3 gap-2">
                        <TouchableOpacity
                            onPress={handleCloudButtonClick}
                            className="bg-indigo-600 dark:bg-indigo-700 p-2 rounded-lg"
                        >
                            <MaterialIcons name="cloud" size={24} color="white" />
                        </TouchableOpacity>
                        <TouchableOpacity
                            onPress={() => isOnline ? setEditDialog(true) : alert('No network available')}
                            className="bg-indigo-600 dark:bg-indigo-700 p-2 rounded-lg"
                        >
                            <MaterialIcons name="edit" size={24} color="white" />
                        </TouchableOpacity>
                    </View>
                </View>

                {/* Progress Stats */}
                <ProgressStats 
                    stats={calculateStats()} 
                    onAddTask={(index) => {
                        setCurrentModule(data[index]);
                        setRoutineModal(true);
                    }}
                />

                {/* Learning Cards */}
                <View className="space-y-4 mt-4">
                    {data.map(book => (
                        <View key={book.name}>
                            <LearningCard
                                title={book.name}
                                progress={calculateProgress(book.topics.flatMap(t => t.subtopics))}
                                onClick={() => setActiveBook(activeBook === book.name ? null : book.name)}
                                isActive={activeBook === book.name}
                            />
                            {activeBook === book.name && (
                                <View className="ml-8 mt-4 space-y-4">
                                    {book.topics.map(topic => (
                                        <View key={topic.name}>
                                            <LearningCard
                                                title={topic.name}
                                                progress={calculateProgress(topic.subtopics)}
                                                onClick={() => setActiveTopic(activeTopic === topic.name ? null : topic.name)}
                                                isActive={activeTopic === topic.name}
                                            />
                                            {activeTopic === topic.name && (
                                                <View className="ml-8 mt-4 space-y-3">
                                                    {topic.subtopics.map(subtopic => (
                                                        <TopicProgress
                                                            key={subtopic.name}
                                                            topic={subtopic}
                                                            onLevelChange={(newValue) =>
                                                                handleLevelChange(book.name, topic.name, subtopic.name, newValue)
                                                            }
                                                        />
                                                    ))}
                                                </View>
                                            )}
                                        </View>
                                    ))}
                                </View>
                            )}
                        </View>
                    ))}
                </View>
            </ScrollView>

            {/* Dialogs and Modals */}
            <EditDialog
                open={editDialog}
                courses={store}
                onClose={() => setEditDialog(false)}
                data={data}
                onSave={async (dt) => {
                    if (isOnline) await saveData(dt);
                    else alert('Cannot save changes offline');
                }}
            />

            <ImportExportDialog
                open={importExportDialog}
                onClose={() => setImportExportDialog(false)}
                firebaseApp={firebaseApp}
                onImportData={handleImportData}
            />

            <RoutineModal
                visible={routineModal}
                courseData={currentModule}
                onClose={() => {
                    setRoutineModal(false);
                }}
                onSave={() => {
                    setRoutineModal(false);
                    setPage("Routine");
                }}
            />

            {/* Loading Overlay */}
            {isLoading && (
                <View 
                    className="absolute inset-0 flex justify-center items-center"
                    style={{ backgroundColor: 'rgba(255, 255, 255, 0.7)' }}
                >
                    <ActivityIndicator size="large" color="#6366f1" />
                </View>
            )}

            <Toast />
        </SafeAreaView>
    );
};

export default Progress;
--- END OF FILE app/pages/Progress.jsx ---

--- START OF FILE app/pages/Routine.jsx ---
import React, { useState, useEffect } from 'react';
import { View, ScrollView, Alert, FlatList, TouchableOpacity, ActivityIndicator } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import * as Notifications from 'expo-notifications';
import { Ionicons } from '@expo/vector-icons';
import { getFirestore } from 'firebase/firestore';
import ProgressOverview from '../components/routine/ProgressOverview';
import ScheduleList from '../components/routine/ScheduleList';
import AddTaskModal from '../components/routine/AddTaskModal';
import ProgressModal from '../components/routine/ProgressModal';
import SubtasksModal from '../components/routine/SubtasksModal';
import ImportExportRoutineDialog from '../components/routine/ImportExportRoutineDialog';

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});

const Routine = ({ firebaseApp }) => {
  const [schedule, setSchedule] = useState([]);
  const [username, setUsername] = useState('admin');
  const [editingTaskId, setEditingTaskId] = useState(null);
  const [currentTaskId, setCurrentTaskId] = useState(null);
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isProgressModalOpen, setIsProgressModalOpen] = useState(false);
  const [isSubtasksModalOpen, setIsSubtasksModalOpen] = useState(false);
  const [isImportExportModalOpen, setIsImportExportModalOpen] = useState(false);
  const [isOnline, setIsOnline] = useState(true);
  const [isLoading, setIsLoading] = useState(true); // New loading state

  // Check network status
  const checkNetworkStatus = async () => {
    try {
      const response = await fetch("https://8.8.8.8", {
        method: "HEAD",
        timeout: 5000
      });
      return response.status >= 200 && response.status < 300;
    } catch (error) {
      return false;
    }
  };

  // Load schedule from SecureStore
  useEffect(() => {
    const loadSchedule = async () => {
      setIsLoading(true); // Start loading
      if (username) {
        const storedSchedule = await SecureStore.getItemAsync(`routine-${username}`);
        if (storedSchedule) {
          const parsedSchedule = JSON.parse(storedSchedule);
          const sortedSchedule = parsedSchedule.sort((a, b) => {
            const timeA = new Date(`2000/01/01 ${a.time}`);
            const timeB = new Date(`2000/01/01 ${b.time}`);
            return timeA - timeB;
          });
          setSchedule(sortedSchedule);
          await scheduleNotifications(sortedSchedule);
        }
      }
      setIsLoading(false); // Stop loading
    };

    const initialize = async () => {
      await loadSchedule();
      
      // Check network status initially and periodically
      const status = await checkNetworkStatus();
      setIsOnline(status);
    };
    
    initialize();
    
    const intervalId = setInterval(async () => {
      const status = await checkNetworkStatus();
      setIsOnline(status);
    }, 10000);
    
    return () => clearInterval(intervalId);
  }, [username]);

  // Schedule push notifications
  const scheduleNotifications = async (tasks) => {
    await Notifications.cancelAllScheduledNotificationsAsync();
    
    tasks.forEach(task => {
      const [hours, minutes] = task.time.split(':');
      const trigger = new Date();
      trigger.setHours(parseInt(hours));
      trigger.setMinutes(parseInt(minutes));
      trigger.setSeconds(0);

      Notifications.scheduleNotificationAsync({
        content: {
          title: `${task.activity} session started`,
          body: `It will end in ${task.duration} minutes!`,
        },
        trigger,
      });
    });
  };

  // Calculate task progress
  const calculateProgress = (task) => {
    const now = new Date();
    const [hours, minutes] = task.time.split(':');

    let scheduleStart = new Date();
    scheduleStart.setHours(parseInt(hours), parseInt(minutes), 0);
    const scheduleEnd = new Date(scheduleStart.getTime() + task.duration * 60000);

    let timeProgress = 0;
    if (now < scheduleStart) {
      timeProgress = 0;
    } else if (now > scheduleEnd) {
      timeProgress = 100;
    } else {
      const totalDuration = scheduleEnd.getTime() - scheduleStart.getTime();
      const elapsedTime = now.getTime() - scheduleStart.getTime();
      timeProgress = Math.min(100, Math.max(0, (elapsedTime / totalDuration) * 100));
    }

    let realProgress = 0;
    if (task.progressType === 'manual') {
      realProgress = task.manualProgress || 0;
    } else {
      realProgress = task.subtasks && task.subtasks.length > 0
        ? (task.subtasks.filter(st => st.completed).length / task.subtasks.length) * 100
        : 0;
    }

    return {
      time: timeProgress,
      real: realProgress,
      total: (timeProgress + realProgress) / 2
    };
  };

  // Save to SecureStore
  const saveToStore = async (newSchedule) => {
    await SecureStore.setItemAsync(`routine-${username}`, JSON.stringify(newSchedule));
    await scheduleNotifications(newSchedule);
  };

  // Task management functions
  const addTask = async (taskData) => {
    const newTask = {
      id: Date.now(),
      ...taskData,
      subtasks: [],
      manualProgress: 0
    };

    const updatedSchedule = [...schedule, newTask].sort((a, b) => {
      const timeA = new Date(`2000/01/01 ${a.time}`);
      const timeB = new Date(`2000/01/01 ${b.time}`);
      return timeA - timeB;
    });

    setSchedule(updatedSchedule);
    await saveToStore(updatedSchedule);
  };

  const updateTask = async (taskId, taskData) => {
    const updatedSchedule = schedule.map(task =>
      task.id === taskId ? { ...task, ...taskData } : task
    );
    setSchedule(updatedSchedule);
    await saveToStore(updatedSchedule);
  };

  const deleteTask = async (taskId) => {
    Alert.alert(
      'Confirm Delete',
      'Are you sure you want to delete this task?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          onPress: async () => {
            const updatedSchedule = schedule.filter(task => task.id !== taskId);
            setSchedule(updatedSchedule);
            await saveToStore(updatedSchedule);
          },
          style: 'destructive'
        }
      ]
    );
  };

  // Handle imported data
  const handleImportData = (importedData) => {
    const sortedSchedule = importedData.sort((a, b) => {
      const timeA = new Date(`2000/01/01 ${a.time}`);
      const timeB = new Date(`2000/01/01 ${b.time}`);
      return timeA - timeB;
    });
    setSchedule(sortedSchedule);
    scheduleNotifications(sortedSchedule);
  };

  // Handle cloud sync button click
  const handleCloudSyncPress = () => {
    if (!isOnline) {
      Alert.alert(
        "Network Unavailable",
        "You need an internet connection to sync your routine data.",
        [{ text: "OK" }]
      );
      return;
    }
    setIsImportExportModalOpen(true);
  };

  const renderContent = () => (
    <>
      <ProgressOverview
        schedule={schedule}
        calculateProgress={calculateProgress}
      />
      <View style={{ flexDirection: 'row', justifyContent: 'flex-end', marginBottom: 10 }}>
        {/* You can add additional buttons here if needed */}
      </View>
      <ScheduleList
        schedule={schedule}
        calculateProgress={calculateProgress}
        handleCloudSync={handleCloudSyncPress}
        onEditTask={(id) => {
          setEditingTaskId(id);
          setIsAddModalOpen(true);
        }}
        onDeleteTask={deleteTask}
        onOpenProgressModal={(id) => {
          setCurrentTaskId(id);
          setIsProgressModalOpen(true);
        }}
        onOpenSubtasksModal={(id) => {
          setCurrentTaskId(id);
          setIsSubtasksModalOpen(true);
        }}
      />
    </>
  );

  return (
    <View className="flex-1 bg-gray-100">
      <FlatList
        data={[1]}
        renderItem={() => (
          <View className="px-4 pt-4">
            <View className="bg-white rounded-lg shadow-lg p-4 mb-4">
              {renderContent()}
            </View>
          </View>
        )}
        keyExtractor={() => 'routine-content'}
        ListFooterComponent={<View className="h-4" />}
        showsVerticalScrollIndicator={false}
      />

      <AddTaskModal
        isOpen={isAddModalOpen}
        onClose={() => {
          setIsAddModalOpen(false);
          setEditingTaskId(null);
        }}
        onSave={editingTaskId ? updateTask : addTask}
        editingTask={editingTaskId ? schedule.find(t => t.id === editingTaskId) : null}
      />

      <ProgressModal
        isOpen={isProgressModalOpen}
        onClose={() => setIsProgressModalOpen(false)}
        task={schedule.find(t => t.id === currentTaskId)}
        onSave={(progress) => updateTask(currentTaskId, { manualProgress: progress })}
      />

      <SubtasksModal
        isOpen={isSubtasksModalOpen}
        onClose={() => setIsSubtasksModalOpen(false)}
        task={schedule.find(t => t.id === currentTaskId)}
        onUpdateSubtasks={(subtasks) => updateTask(currentTaskId, { subtasks })}
      />

      <ImportExportRoutineDialog
        isOpen={isImportExportModalOpen}
        onClose={() => setIsImportExportModalOpen(false)}
        firebaseApp={firebaseApp}
        username={username}
        onImportData={handleImportData}
      />

      {/* Loading Overlay */}
      {isLoading && (
        <View 
          className="absolute inset-0 flex justify-center items-center"
          style={{ backgroundColor: 'rgba(255, 255, 255, 0.7)' }}
        >
          <ActivityIndicator size="large" color="#000000" />
        </View>
      )}
    </View>
  );
};

export default Routine;
--- END OF FILE app/pages/Routine.jsx ---

--- START OF FILE app/tools/arabic-fib.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, ActivityIndicator, Alert } from 'react-native'
import { Ionicons, FontAwesome5 } from '@expo/vector-icons'
import React, { useState, useEffect } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import * as SecureStore from 'expo-secure-store'
import axios from 'axios'
import { GoogleGenerativeAI } from '@google/generative-ai'
import ReaderSelector from './components/ReaderSelector'

const ArabicFillBlanks = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const [loading, setLoading] = useState(true)
    const [gameData, setGameData] = useState(null)
    const [processStatus, setProcessStatus] = useState('Initializing...')
    const [processingProgress, setProcessingProgress] = useState(0)
    const [forceRegenerate, setForceRegenerate] = useState(false)

    // Game state variables
    const [currentSectionIndex, setCurrentSectionIndex] = useState(0)
    const [currentPuzzleIndex, setCurrentPuzzleIndex] = useState(0)
    const [selectedWords, setSelectedWords] = useState([])
    const [correctAnswers, setCorrectAnswers] = useState(0)
    const [totalAttempts, setTotalAttempts] = useState(0)
    const [points, setPoints] = useState(0)
    const [showResults, setShowResults] = useState(false)
    const [isComplete, setIsComplete] = useState(false)

    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    // Fetch and process data
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true)
                setProcessStatus('Checking cached data...')
                const storageKey = `arabic-blanks-${subInt}-${index}`
                let storedData = await SecureStore.getItemAsync(storageKey)
                console.log(storedData)

                if (storedData && !forceRegenerate) {
                    console.log('Using stored game data')
                    setProcessStatus('Using cached data...')
                    setProcessingProgress(0.9)
                    setGameData(JSON.parse(storedData))
                    setLoading(false)
                    return
                }

                setProcessStatus('Downloading Arabic text...')
                setProcessingProgress(0.1)
                let textData;
                if (!lesson.text) {
                    const response = await axios.get(dataUrl)
                    textData = response.data
                } else {
                    textData = lesson.text
                }

                setProcessingProgress(0.2)

                const apiKey = await SecureStore.getItemAsync('google-api')
                if (!apiKey) {
                    console.error('Google API key not found in secure storage')
                    setProcessStatus('Error: API key not found, Set API Key in Tools')
                    return
                }

                const processedData = await processArabicTextForBlanks(textData, apiKey)
                await SecureStore.setItemAsync(storageKey, JSON.stringify(processedData))
                setGameData(processedData)
            } catch (error) {
                console.error('Error fetching data:', error)
                setProcessStatus(`Error: ${error.message}`)
            } finally {
                setForceRegenerate(false)
                setLoading(false)
            }
        }

        fetchData()
    }, [forceRegenerate])

    // Reset indices and game state when gameData changes
    useEffect(() => {
        if (gameData) {
            setCurrentSectionIndex(0)
            setCurrentPuzzleIndex(0)
            setSelectedWords([])
            setCorrectAnswers(0)
            setTotalAttempts(0)
            setPoints(0)
            setShowResults(false)
            setIsComplete(false)
        }
    }, [gameData])

    // Process Arabic text for blanks game
    const processArabicTextForBlanks = async (arabicText, apiKey) => {
        try {
            setProcessStatus('Extracting text structure...')
            setProcessingProgress(0.3)
            console.log('Processing text for fill-in-the-blanks game')

            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const blanksPuzzlePrompt = `
            Create a fill-in-the-blanks game from this Arabic text. Focus on important vocabulary words:
            
            Text: ${arabicText}
            
            Return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "name": "Section name in Arabic",
                "puzzles": [
                  {
                    "sentence": "Original Arabic sentence with ________ for blanks",
                    "options": ["word1", "word2", "word3", "word4", "word5", "word6"],
                    "blanks": [
                      {
                        "index": 0,
                        "word": "correct word 1"
                      },
                      {
                        "index": 1,
                        "word": "correct word 2"
                      }
                    ],
                    "translation": "English translation of the full sentence"
                  }
                ]
              }
            ]
            
            Create about 3-5 puzzles per section. Each puzzle should:
            1. Replace 1-2 important vocabulary words with blanks
            2. Provide 6 options to choose from (include the correct answers plus distractors)
            3. Blanks should represent key vocabulary words, not just common words
            4. Keep diacritical marks (harakat) in all Arabic text
            `;

            setProcessStatus('Creating fill-in-the-blanks exercises...')
            setProcessingProgress(0.5)

            const gameResult = await model.generateContent(blanksPuzzlePrompt)
            const gameResponse = gameResult.response.text()
            const jsonMatch = gameResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : gameResponse
            const gameData = JSON.parse(jsonString)

            console.log('Fill-in-the-blanks game created:', gameData.length, 'sections')
            setProcessingProgress(1)
            return gameData
        } catch (error) {
            console.error('Error creating blanks game:', error)
            return [{
                name: "Error Section",
                puzzles: [{
                    sentence: "Error processing text ____ blanks game.",
                    options: ["for", "with", "into", "as", "from", "by"],
                    blanks: [{ index: 0, word: "for" }],
                    translation: "Error processing text for blanks game."
                }]
            }]
        }
    }

    // Handle regeneration
    const handleRegenerate = () => {
        Alert.alert(
            "Regenerate Content",
            "This will reset your progress. Regenerate the content?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Regenerate",
                    onPress: async () => {
                        setLoading(true)
                        setProcessStatus('Regenerating content...')
                        const storageKey = `arabic-blanks-${subInt}-${index}`
                        await SecureStore.deleteItemAsync(storageKey)
                        setForceRegenerate(true)
                    }
                }
            ]
        )
    }

    const handleSectionChange = (sectionIndex) => {
        setCurrentSectionIndex(sectionIndex)
        setCurrentPuzzleIndex(0)
        setSelectedWords([])
        setShowResults(false)
    }

    // Select a word from options
    const handleSelectWord = (word, index) => {
        // If word is already selected, do nothing
        if (selectedWords.includes(word)) return

        const currentPuzzle = gameData[currentSectionIndex].puzzles[currentPuzzleIndex]
        const newSelectedWords = [...selectedWords, word]
        setSelectedWords(newSelectedWords)

        // Check if all blanks have been filled
        if (newSelectedWords.length === currentPuzzle.blanks.length) {
            let correct = 0
            newSelectedWords.forEach((selected, idx) => {
                if (selected === currentPuzzle.blanks[idx].word) {
                    correct++
                }
            })

            setTotalAttempts(totalAttempts + 1)
            setCorrectAnswers(correctAnswers + (correct === currentPuzzle.blanks.length ? 1 : 0))

            // Add points based on correctness
            const earnedPoints = correct === currentPuzzle.blanks.length ? 10 : Math.max(0, correct * 2)
            setPoints(points + earnedPoints)

            // Show results before moving to next puzzle
            setShowResults(true)
        }
    }

    // Move to next puzzle
    const handleNextPuzzle = () => {
        const currentSection = gameData[currentSectionIndex]

        // Check if we're at the end of all puzzles in all sections
        if (currentSectionIndex === gameData.length - 1 &&
            currentPuzzleIndex === currentSection.puzzles.length - 1) {
            setIsComplete(true)
            return
        }

        // Move to next puzzle or section
        if (currentPuzzleIndex < currentSection.puzzles.length - 1) {
            setCurrentPuzzleIndex(currentPuzzleIndex + 1)
        } else if (currentSectionIndex < gameData.length - 1) {
            setCurrentSectionIndex(currentSectionIndex + 1)
            setCurrentPuzzleIndex(0)
        }

        setSelectedWords([])
        setShowResults(false)
    }

    // Progress bar component
    const ProgressBar = ({ progress, width, height = 6, color = '#5c6bc0', backgroundColor = '#e0e0e0' }) => {
        return (
            <View style={{ height, width: width || '100%', backgroundColor, borderRadius: height / 2, overflow: 'hidden' }}>
                <View style={{ height: '100%', width: `${Math.min(100, Math.max(0, progress * 100))}%`, backgroundColor: color, borderRadius: height / 2 }} />
            </View>
        )
    }

    // Handle game completion
    const handleComplete = async () => {
        try {
            let oldScore = parseInt(await SecureStore.getItemAsync("score-" + subInt)) || 0

            // Calculate score based on correct answers
            const accuracy = correctAnswers / totalAttempts
            let pointsToAdd = 0

            for (let i = 0; i < lesson.tools.length; i++) {
                if (lesson.tools[i].name === "arabic-fib") {
                    pointsToAdd += Math.round(lesson.tools[i].score * accuracy)
                }
            }

            const newScore = oldScore + pointsToAdd
            await SecureStore.setItemAsync('score-' + subInt, newScore.toString())

            Alert.alert(
                "Congratulations!",
                `You've completed the exercise!\n\nScore: ${points}\nAccuracy: ${Math.round(accuracy * 100)}%\nPoints Added: +${pointsToAdd}`,
                [{ text: "Continue", onPress: () => router.back() }]
            )
        } catch (error) {
            console.error('Error saving score:', error)
            Alert.alert("Error", "Could not save your score.")
            router.back()
        }
    }

    // Render current puzzle
    const renderCurrentPuzzle = () => {
        if (!gameData || gameData.length === 0) return null

        const currentSection = gameData[currentSectionIndex]
        const currentPuzzle = currentSection.puzzles[currentPuzzleIndex]
        if (!currentPuzzle) return null

        // Split sentence by blanks
        const sentenceParts = currentPuzzle.sentence.split('________')


        return (
            <View className="bg-white rounded-xl p-4 shadow-sm mb-4">
                <View className="flex-row justify-between items-center mb-3">
                    <Text className="text-indigo-700 font-medium">
                        Puzzle {currentPuzzleIndex + 1}/{currentSection.puzzles.length}
                    </Text>
                    <View className="bg-indigo-100 px-3 py-1 rounded-full">
                        <Text className="text-indigo-700 font-bold">{points} pts</Text>
                    </View>
                </View>

                {/* The sentence with blanks */}
                <View className="bg-gray-50 p-3 rounded-lg mb-4">
                    <Text className="text-right text-lg leading-7 mb-2">
                        {sentenceParts.map((part, index) => (
                            <React.Fragment key={index}>
                                {part}
                                {index < sentenceParts.length - 1 && (
                                    <View className="inline mx-1 px-2 py-1 bg-indigo-100 rounded">
                                        <Text className="text-indigo-700 font-bold">
                                            {selectedWords[index] || "_______"}
                                        </Text>
                                    </View>
                                )}
                            </React.Fragment>
                        ))}
                    </Text>
                    <Text className="text-gray-600">{currentPuzzle.translation}</Text>
                </View>

                {/* Word options */}
                {!showResults && (
                    <View className="flex-row flex-wrap justify-center my-2">
                        {currentPuzzle.options.map((word, index) => (
                            <TouchableOpacity
                                key={index}
                                onPress={() => handleSelectWord(word, index)}
                                className={`m-1 px-3 py-2 rounded-lg ${selectedWords.includes(word)
                                        ? 'bg-gray-300 opacity-50'
                                        : 'bg-indigo-600'
                                    }`}
                                disabled={selectedWords.includes(word)}
                            >
                                <Text className={`text-lg ${selectedWords.includes(word)
                                        ? 'text-gray-700'
                                        : 'text-white'
                                    }`}>
                                    {word}
                                </Text>
                            </TouchableOpacity>
                        ))}
                    </View>
                )}

                {/* Results feedback */}
                {showResults && (
                    <View className="bg-gray-50 p-3 rounded-lg mb-3">
                        <Text className="text-lg font-bold mb-2 text-center">
                            {selectedWords.every((word, idx) =>
                                word === currentPuzzle.blanks[idx].word)
                                ? "Correct! 🎉"
                                : "Not quite right 🤔"
                            }
                        </Text>

                        {currentPuzzle.blanks.map((blank, idx) => (
                            <View key={idx} className="flex-row justify-between mb-1">
                                <Text>Blank {idx + 1}:</Text>
                                <View className="flex-row">
                                    <Text className={
                                        selectedWords[idx] === blank.word
                                            ? "text-green-600 font-bold"
                                            : "text-red-600"
                                    }>
                                        {selectedWords[idx] || ""}
                                    </Text>
                                    {selectedWords[idx] !== blank.word && (
                                        <Text className="text-green-600 ml-2">
                                            → {blank.word}
                                        </Text>
                                    )}
                                </View>
                            </View>
                        ))}

                        <TouchableOpacity
                            onPress={handleNextPuzzle}
                            className="bg-indigo-600 py-2 px-4 rounded-lg mt-3 items-center"
                        >
                            <Text className="text-white font-medium">
                                {isComplete ? "See Results" : "Next Puzzle"}
                            </Text>
                        </TouchableOpacity>
                    </View>
                )}
            </View>
        )
    }

    // Loading screen
    if (loading) {
        return (
            <SafeAreaView className="flex-1 bg-blue-50">
                <StatusBar barStyle="dark-content" />
                <View className="flex-1 justify-center items-center p-5">
                    <View className="bg-white rounded-2xl p-6 w-full items-center shadow-md">
                        <FontAwesome5 name="puzzle-piece" size={60} color="#5c6bc0" className="mb-5" />
                        <Text className="text-xl font-bold text-gray-800 mb-3">Creating Your Puzzle</Text>
                        <Text className="text-base text-gray-600 text-center mb-6">{processStatus}</Text>
                        <ProgressBar progress={processingProgress} height={8} />
                        <View className="flex-row items-center mt-5">
                            <ActivityIndicator size="small" color="#5c6bc0" />
                            <Text className="ml-2 text-indigo-600 font-medium">
                                {Math.round(processingProgress * 100)}% Complete
                            </Text>
                        </View>
                    </View>
                </View>
            </SafeAreaView>
        )
    }

    // Main render
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" />

            {/* Header */}
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                    <Text className="ml-2 text-gray-800">Back</Text>
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800">{lesson.title || 'Fill in the Blanks'}</Text>
                <View className="flex-row items-center">
                    <TouchableOpacity onPress={handleRegenerate} disabled={loading} className="mr-2">
                        <FontAwesome5 name="sync" size={20} color="#333" />
                    </TouchableOpacity>
                    <View className="bg-green-100 px-2 py-1 rounded-full flex-row items-center">
                        <FontAwesome5 name="star" size={14} color="#4caf50" />
                        <Text className="ml-1 text-green-600 font-bold">{points}</Text>
                    </View>
                </View>
            </View>

            {gameData && gameData.length > 0 && (
                <ReaderSelector
                    sections={gameData}
                    currentSectionIndex={currentSectionIndex}
                    onSelectSection={handleSectionChange}
                    className="mx-4 mt-4"
                />
            )}



            {/* Progress bar */}
            <View className="px-6 my-3">
                <ProgressBar
                    progress={(currentPuzzleIndex + 1) / gameData[currentSectionIndex].puzzles.length}
                />
            </View>
            {/* Main content */}
            <ScrollView className="flex-1 px-4">
                {renderCurrentPuzzle()}

                {isComplete && (
                    <View className="bg-white rounded-xl p-5 shadow-sm mb-4">
                        <Text className="text-xl font-bold text-center mb-3">Game Complete! 🎉</Text>
                        <View className="bg-indigo-50 p-4 rounded-lg mb-4">
                            <Text className="text-lg text-center mb-2">Your Results</Text>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Total Points:</Text>
                                <Text className="font-bold">{points}</Text>
                            </View>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Correct Answers:</Text>
                                <Text className="font-bold">{correctAnswers}/{totalAttempts}</Text>
                            </View>
                            <View className="flex-row justify-between">
                                <Text className="text-gray-700">Accuracy:</Text>
                                <Text className="font-bold">
                                    {totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0}%
                                </Text>
                            </View>
                        </View>
                        <TouchableOpacity
                            onPress={handleComplete}
                            className="bg-green-600 py-3 rounded-lg items-center"
                        >
                            <Text className="text-white font-bold text-lg">Finish & Save Score</Text>
                        </TouchableOpacity>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    )
}

export default ArabicFillBlanks
--- END OF FILE app/tools/arabic-fib.jsx ---

--- START OF FILE app/tools/arabic-qna.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, ActivityIndicator, Alert } from 'react-native'
import { Ionicons, FontAwesome5 } from '@expo/vector-icons'
import React, { useState, useEffect } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import * as SecureStore from 'expo-secure-store'
import axios from 'axios'
import { GoogleGenerativeAI } from '@google/generative-ai'
import ReaderSelector from './components/ReaderSelector'

const ArabicQnA = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const [loading, setLoading] = useState(true)
    const [gameData, setGameData] = useState(null)
    const [processStatus, setProcessStatus] = useState('Initializing...')
    const [processingProgress, setProcessingProgress] = useState(0)
    const [forceRegenerate, setForceRegenerate] = useState(false)

    // Game state variables
    const [currentSectionIndex, setCurrentSectionIndex] = useState(0)
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0)
    const [selectedAnswer, setSelectedAnswer] = useState(null)
    const [correctAnswers, setCorrectAnswers] = useState(0)
    const [totalAttempts, setTotalAttempts] = useState(0)
    const [points, setPoints] = useState(0)
    const [showResults, setShowResults] = useState(false)
    const [isComplete, setIsComplete] = useState(false)

    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    // Fetch and process data
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true)
                setProcessStatus('Checking cached data...')
                const storageKey = `arabic-qna-${subInt}-${index}`
                let storedData = await SecureStore.getItemAsync(storageKey)
                console.log(storedData)

                if (storedData && !forceRegenerate) {
                    console.log('Using stored game data')
                    setProcessStatus('Using cached data...')
                    setProcessingProgress(0.9)
                    setGameData(JSON.parse(storedData))
                    setLoading(false)
                    return
                }

                setProcessStatus('Downloading Arabic text...')
                setProcessingProgress(0.1)
                let textData;
                if (!lesson.text) {
                    const response = await axios.get(dataUrl)
                    textData = response.data
                } else {
                    textData = lesson.text
                }

                setProcessingProgress(0.2)

                const apiKey = await SecureStore.getItemAsync('google-api')
                if (!apiKey) {
                    console.error('Google API key not found in secure storage')
                    setProcessStatus('Error: API key not found, Set API Key in Tools')
                    return
                }

                const processedData = await processArabicTextForQnA(textData, apiKey)
                await SecureStore.setItemAsync(storageKey, JSON.stringify(processedData))
                setGameData(processedData)
            } catch (error) {
                console.error('Error fetching data:', error)
                setProcessStatus(`Error: ${error.message}`)
            } finally {
                setForceRegenerate(false)
                setLoading(false)
            }
        }

        fetchData()
    }, [forceRegenerate])

    // Reset indices and game state when gameData changes
    useEffect(() => {
        if (gameData) {
            setCurrentSectionIndex(0)
            setCurrentQuestionIndex(0)
            setSelectedAnswer(null)
            setCorrectAnswers(0)
            setTotalAttempts(0)
            setPoints(0)
            setShowResults(false)
            setIsComplete(false)
        }
    }, [gameData])

    // Process Arabic text for Q&A
    const processArabicTextForQnA = async (arabicText, apiKey) => {
        try {
            setProcessStatus('Extracting text structure...')
            setProcessingProgress(0.3)
            console.log('Processing text for question and answer exercise')

            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const qnaPrompt = `
            Create a question and answer exercise from this Arabic text:
            
            Text: ${arabicText}
            
            Return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "name": "Section name in Arabic",
                "questions": [
                  {
                    "question": "Question in Arabic",
                    "options": ["option1", "option2", "option3", "option4"],
                    "correctAnswer": "option1",
                    "translation": {
                      "question": "English translation of the question",
                      "answer": "English translation of the correct answer"
                    }
                  }
                ]
              }
            ]
            
            Create about 3-5 questions per section. Each question should:
            1. Be directly related to the content of the text
            2. Have 4 different options to choose from
            3. Include both vocabulary and comprehension questions
            4. Keep diacritical marks (harakat) in all Arabic text
            5. Include meaningful translations for both the question and correct answer
            `;

            setProcessStatus('Creating question and answer exercises...')
            setProcessingProgress(0.5)

            const gameResult = await model.generateContent(qnaPrompt)
            const gameResponse = gameResult.response.text()
            const jsonMatch = gameResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : gameResponse
            const gameData = JSON.parse(jsonString)

            console.log('Q&A exercise created:', gameData.length, 'sections')
            setProcessingProgress(1)
            return gameData
        } catch (error) {
            console.error('Error creating Q&A exercise:', error)
            return [{
                name: "Error Section",
                questions: [{
                    question: "Error processing text for Q&A exercise",
                    options: ["Try again", "Check API key", "Verify text", "Contact support"],
                    correctAnswer: "Try again",
                    translation: {
                        question: "Error processing text for Q&A exercise",
                        answer: "Try again"
                    }
                }]
            }]
        }
    }

    // Handle regeneration
    const handleRegenerate = () => {
        Alert.alert(
            "Regenerate Content",
            "This will reset your progress. Regenerate the content?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Regenerate",
                    onPress: async () => {
                        setLoading(true)
                        setProcessStatus('Regenerating content...')
                        const storageKey = `arabic-qna-${subInt}-${index}`
                        await SecureStore.deleteItemAsync(storageKey)
                        setForceRegenerate(true)
                    }
                }
            ]
        )
    }

    const handleSectionChange = (sectionIndex) => {
        setCurrentSectionIndex(sectionIndex)
        setCurrentQuestionIndex(0)
        setSelectedAnswer(null)
        setShowResults(false)
    }

    // Select an answer
    const handleSelectAnswer = (answer) => {
        setSelectedAnswer(answer)
        const currentQuestion = gameData[currentSectionIndex].questions[currentQuestionIndex]

        setTotalAttempts(totalAttempts + 1)
        const isCorrect = answer === currentQuestion.correctAnswer

        if (isCorrect) {
            setCorrectAnswers(correctAnswers + 1)
            setPoints(points + 10)
        }

        setShowResults(true)
    }

    // Move to next question
    const handleNextQuestion = () => {
        const currentSection = gameData[currentSectionIndex]

        // Check if we're at the end of all questions in all sections
        if (currentSectionIndex === gameData.length - 1 &&
            currentQuestionIndex === currentSection.questions.length - 1) {
            setIsComplete(true)
            return
        }

        // Move to next question or section
        if (currentQuestionIndex < currentSection.questions.length - 1) {
            setCurrentQuestionIndex(currentQuestionIndex + 1)
        } else if (currentSectionIndex < gameData.length - 1) {
            setCurrentSectionIndex(currentSectionIndex + 1)
            setCurrentQuestionIndex(0)
        }

        setSelectedAnswer(null)
        setShowResults(false)
    }

    // Progress bar component
    const ProgressBar = ({ progress, width, height = 6, color = '#5c6bc0', backgroundColor = '#e0e0e0' }) => {
        return (
            <View style={{ height, width: width || '100%', backgroundColor, borderRadius: height / 2, overflow: 'hidden' }}>
                <View style={{ height: '100%', width: `${Math.min(100, Math.max(0, progress * 100))}%`, backgroundColor: color, borderRadius: height / 2 }} />
            </View>
        )
    }

    // Handle game completion
    const handleComplete = async () => {
        try {
            let oldScore = parseInt(await SecureStore.getItemAsync("score-" + subInt)) || 0

            // Calculate score based on correct answers
            const accuracy = correctAnswers / totalAttempts
            let pointsToAdd = 0

            for (let i = 0; i < lesson.tools.length; i++) {
                if (lesson.tools[i].name === "arabic-qna") {
                    pointsToAdd += Math.round(lesson.tools[i].score * accuracy)
                }
            }

            const newScore = oldScore + pointsToAdd
            await SecureStore.setItemAsync('score-' + subInt, newScore.toString())

            Alert.alert(
                "Congratulations!",
                `You've completed the exercise!\n\nScore: ${points}\nAccuracy: ${Math.round(accuracy * 100)}%\nPoints Added: +${pointsToAdd}`,
                [{ text: "Continue", onPress: () => router.back() }]
            )
        } catch (error) {
            console.error('Error saving score:', error)
            Alert.alert("Error", "Could not save your score.")
            router.back()
        }
    }

    // Render current question
    const renderCurrentQuestion = () => {
        if (!gameData || gameData.length === 0) return null

        const currentSection = gameData[currentSectionIndex]
        const currentQuestion = currentSection.questions[currentQuestionIndex]
        if (!currentQuestion) return null

        return (
            <View className="bg-white rounded-xl p-4 shadow-sm mb-4">
                <View className="flex-row justify-between items-center mb-3">
                    <Text className="text-indigo-700 font-medium">
                        Question {currentQuestionIndex + 1}/{currentSection.questions.length}
                    </Text>
                    <View className="bg-indigo-100 px-3 py-1 rounded-full">
                        <Text className="text-indigo-700 font-bold">{points} pts</Text>
                    </View>
                </View>

                {/* The question */}
                <View className="bg-gray-50 p-3 rounded-lg mb-4">
                    <Text className="text-right text-lg leading-7 mb-2">
                        {currentQuestion.question}
                    </Text>
                    <Text className="text-gray-600">{currentQuestion.translation.question}</Text>
                </View>

                {/* Answer options */}
                {!showResults && (
                    <View className="my-2">
                        {currentQuestion.options.map((option, index) => (
                            <TouchableOpacity
                                key={index}
                                onPress={() => handleSelectAnswer(option)}
                                className={`mb-2 p-3 rounded-lg ${selectedAnswer === option
                                        ? 'bg-indigo-200 border border-indigo-400'
                                        : 'bg-gray-100 border border-gray-200'
                                    }`}
                            >
                                <Text className="text-right text-lg">{option}</Text>
                            </TouchableOpacity>
                        ))}
                    </View>
                )}

                {/* Results feedback */}
                {showResults && (
                    <View className="bg-gray-50 p-3 rounded-lg mb-3">
                        <Text className="text-lg font-bold mb-2 text-center">
                            {selectedAnswer === currentQuestion.correctAnswer
                                ? "Correct! 🎉"
                                : "Not quite right 🤔"
                            }
                        </Text>

                        <View className="mb-3">
                            <Text className="font-bold mb-1">Your answer:</Text>
                            <View className={`p-2 rounded-lg ${selectedAnswer === currentQuestion.correctAnswer
                                    ? 'bg-green-100 border border-green-300'
                                    : 'bg-red-100 border border-red-300'
                                }`}>
                                <Text className="text-right text-lg">{selectedAnswer}</Text>
                            </View>
                        </View>

                        {selectedAnswer !== currentQuestion.correctAnswer && (
                            <View className="mb-3">
                                <Text className="font-bold mb-1">Correct answer:</Text>
                                <View className="p-2 rounded-lg bg-green-100 border border-green-300">
                                    <Text className="text-right text-lg">{currentQuestion.correctAnswer}</Text>
                                </View>
                                <Text className="text-gray-600 mt-1">{currentQuestion.translation.answer}</Text>
                            </View>
                        )}

                        <TouchableOpacity
                            onPress={handleNextQuestion}
                            className="bg-indigo-600 py-2 px-4 rounded-lg mt-3 items-center"
                        >
                            <Text className="text-white font-medium">
                                {isComplete ? "See Results" : "Next Question"}
                            </Text>
                        </TouchableOpacity>
                    </View>
                )}
            </View>
        )
    }

    // Loading screen
    // Loading screen
    if (loading) {
        return (
            <SafeAreaView className="flex-1 bg-blue-50">
                <StatusBar barStyle="dark-content" />
                <View className="flex-1 justify-center items-center p-5">
                    <View className="bg-white rounded-2xl p-6 w-full items-center shadow-md">
                        <FontAwesome5 name="question-circle" size={60} color="#5c6bc0" className="mb-5" />
                        <Text className="text-xl font-bold text-gray-800 mb-3">Creating Your Quiz</Text>
                        <Text className="text-base text-gray-600 text-center mb-6">{processStatus}</Text>
                        <ProgressBar progress={processingProgress} height={8} />
                        <View className="flex-row items-center mt-5">
                            <ActivityIndicator size="small" color="#5c6bc0" />
                            <Text className="ml-2 text-indigo-600 font-medium">
                                {Math.round(processingProgress * 100)}% Complete
                            </Text>
                        </View>
                    </View>
                </View>
            </SafeAreaView>
        )
    }

    // Main render
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" />

            {/* Header */}
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                    <Text className="ml-2 text-gray-800">Back</Text>
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800">{lesson.title || 'Questions & Answers'}</Text>
                <View className="flex-row items-center">
                    <TouchableOpacity onPress={handleRegenerate} disabled={loading} className="mr-2">
                        <FontAwesome5 name="sync" size={20} color="#333" />
                    </TouchableOpacity>
                    <View className="bg-green-100 px-2 py-1 rounded-full flex-row items-center">
                        <FontAwesome5 name="star" size={14} color="#4caf50" />
                        <Text className="ml-1 text-green-600 font-bold">{points}</Text>
                    </View>
                </View>
            </View>

            {gameData && gameData.length > 0 && (
                <ReaderSelector
                    sections={gameData}
                    currentSectionIndex={currentSectionIndex}
                    onSelectSection={handleSectionChange}
                    className="mx-4 mt-4"
                />
            )}

            {/* Progress bar */}
            <View className="px-6 my-3">
                <ProgressBar
                    progress={(currentQuestionIndex + 1) / gameData[currentSectionIndex].questions.length}
                />
            </View>

            {/* Main content */}
            <ScrollView className="flex-1 px-4">
                {renderCurrentQuestion()}

                {isComplete && (
                    <View className="bg-white rounded-xl p-5 shadow-sm mb-4">
                        <Text className="text-xl font-bold text-center mb-3">Quiz Complete! 🎉</Text>
                        <View className="bg-indigo-50 p-4 rounded-lg mb-4">
                            <Text className="text-lg text-center mb-2">Your Results</Text>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Total Points:</Text>
                                <Text className="font-bold">{points}</Text>
                            </View>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Correct Answers:</Text>
                                <Text className="font-bold">{correctAnswers}/{totalAttempts}</Text>
                            </View>
                            <View className="flex-row justify-between">
                                <Text className="text-gray-700">Accuracy:</Text>
                                <Text className="font-bold">
                                    {totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0}%
                                </Text>
                            </View>
                        </View>
                        <TouchableOpacity
                            onPress={handleComplete}
                            className="bg-green-600 py-3 rounded-lg items-center"
                        >
                            <Text className="text-white font-bold text-lg">Finish & Save Score</Text>
                        </TouchableOpacity>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    )
}

export default ArabicQnA
--- END OF FILE app/tools/arabic-qna.jsx ---

--- START OF FILE app/tools/arabic-reader.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, ActivityIndicator, Animated, Modal, Alert } from 'react-native'
import { Ionicons, MaterialIcons, FontAwesome5, MaterialCommunityIcons } from '@expo/vector-icons'
import React, { useState, useEffect, useRef } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import * as SecureStore from 'expo-secure-store'
import axios from 'axios'
import { GoogleGenerativeAI } from '@google/generative-ai'
import ReaderSelector from './components/ReaderSelector'

const ArabicReader = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const [loading, setLoading] = useState(true)
    const [readerData, setReaderData] = useState(null)
    const [sentence, setSentence] = useState('')
    const [processStatus, setProcessStatus] = useState('Initializing...')
    const [processingProgress, setProcessingProgress] = useState(0)
    const [forceRegenerate, setForceRegenerate] = useState(false) // New state for regeneration

    // Game UI state variables
    const [currentSectionIndex, setCurrentSectionIndex] = useState(0)
    const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0)
    const [showFullSentence, setShowFullSentence] = useState(true)
    const [wordRevealIndex, setWordRevealIndex] = useState(-1)
    const [points, setPoints] = useState(0)
    const [streak, setStreak] = useState(0)

    const [showCompletionModal, setShowCompletionModal] = useState(false)
    const [scoreAdded, setScoreAdded] = useState(0)
    const [totalScore, setTotalScore] = useState(0)
    const confettiAnim = useRef(new Animated.Value(0)).current
    const scoreAnim = useRef(new Animated.Value(0)).current

    // Animation refs
    const fadeAnim = useRef(new Animated.Value(0)).current
    const slideAnim = useRef(new Animated.Value(50)).current

    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    // Constants for batch processing
    const BATCH_SIZE = 5 // Process 5 sentences at once
    const MAX_TOKENS = 5000 // Target token limit for each request

    // Fetch and process data, with regeneration support
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true)
                
                const apiKey = await SecureStore.getItemAsync('google-api')
                

                if (!apiKey) {
                    console.error('Google API key not found in secure storage')
                    router.back()
                    alert("Please set API Key in tools at home")
                    return
                }

                setProcessStatus('Checking cached data...')
                const storageKey = `arabic-reader-${subInt}-${index}`
                let storedData = await SecureStore.getItemAsync(storageKey)

                if (storedData && !forceRegenerate) {
                    console.log('Using stored reader data')
                    setProcessStatus('Using cached data...')
                    setProcessingProgress(0.9)
                    setReaderData(JSON.parse(storedData))
                    setLoading(false)
                    return
                }

                setProcessStatus('Downloading Arabic text...')
                setProcessingProgress(0.1)
                let sentenceData;
                if (!lesson.text) {
                    const response = await axios.get(dataUrl)
                    sentenceData = response.data
                } else {
                    sentenceData = lesson.text
                }
                setSentence(sentenceData)
                setProcessingProgress(0.2)


                const processedData = await processArabicTextInBatches(sentenceData, apiKey)
                await SecureStore.setItemAsync(storageKey, JSON.stringify(processedData))
                setReaderData(processedData)
            } catch (error) {
                console.error('Error fetching data:', error)
                setProcessStatus(`Error: ${error.message}`)
            } finally {
                setForceRegenerate(false) // Reset regeneration flag
                setLoading(false)
            }
        }

        fetchData()
    }, [forceRegenerate]) // Depend on forceRegenerate to trigger reprocessing

    // Reset indices and game state when readerData changes
    useEffect(() => {
        if (readerData) {
            setCurrentSectionIndex(0)
            setCurrentSentenceIndex(0)
            setWordRevealIndex(-1)
            setShowFullSentence(true)
            setPoints(0)
            setStreak(0)
        }
    }, [readerData])

    // Animation for game UI
    useEffect(() => {
        if (!loading && readerData) {
            fadeAnim.setValue(0)
            slideAnim.setValue(50)
            Animated.parallel([
                Animated.timing(fadeAnim, { toValue: 1, duration: 500, useNativeDriver: true }),
                Animated.timing(slideAnim, { toValue: 0, duration: 500, useNativeDriver: true })
            ]).start()
        }
    }, [currentSentenceIndex, currentSectionIndex, loading])

    // Handle regeneration
    const handleRegenerate = () => {
        Alert.alert(
            "Regenerate Content",
            "Warning: This will reset your progress in this lesson and may take some time. Are you sure you want to regenerate the content?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Regenerate",
                    onPress: async () => {
                        setLoading(true)
                        setProcessStatus('Regenerating content...')
                        const storageKey = `arabic-reader-${subInt}-${index}`
                        await SecureStore.deleteItemAsync(storageKey)
                        setForceRegenerate(true)
                    }
                }
            ]
        )
    }

    // Extract text structure (unchanged)
    const extractTextStructure = async (arabicText, apiKey) => {
        try {
            setProcessStatus('Extracting text structure...')
            setProcessingProgress(0.25)
            console.log('Extracting text structure')

            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const structurePrompt = `
            I have an Arabic text that needs to be divided into sections and small sentences (no more than a few words) for processing.
            
            Text: ${arabicText}
            
            Please return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "name": "Section name in Arabic",
                "sentences": ["sentence1", "sentence2", ...]
              }
            ]
            
            Split the text naturally into sections if appropriate (like different stories, paragraphs about different topics, or information about a poet separate from their work). 
            If it's just one continuous text, use a single section.
            Ignore elements like unit names, poet name title (which should be given as section title)
            For each section, split the text small logicallly meaningful sentences with 7-12 words
            Do not include any translations or additional information - ONLY the original Arabic text structure.
            add clear presentation of signs like fathah, kasrah, and shaddah, which are crucial for pronunciation
            all sections must have a name
            `;

            const structureResult = await model.generateContent(structurePrompt)
            const structureResponse = structureResult.response.text()
            const jsonMatch = structureResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : structureResponse
            const structure = JSON.parse(jsonString)

            console.log('Text structure extracted:', structure)
            setProcessingProgress(0.3)
            return structure
        } catch (error) {
            console.error('Error extracting text structure:', error)
            return [{
                name: "النص الأصلي",
                sentences: [arabicText]
            }]
        }
    }

    // Process sentence batch (unchanged)
    const processSentenceBatch = async (sentences, apiKey) => {
        try {
            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const batchPrompt = `
            Analyze these Arabic sentences for a language learning app:
            
            Sentences: ${JSON.stringify(sentences)}
            
            Return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "sentence": "original Arabic sentence",
                "meaning": "english translation",
                "words": [
                  {"word": "arabic-word", "meaning": "english-word"}
                ]
              }
            ]
            
            Process each sentence in the array and provide a detailed analysis for each one.
            Ignore commonly used words for meaning and also names also connecting wors like to, from, he, she etc
            Make sure to keep the exact same order as in the input array.
            keep clear presentation of signs like fathah, kasrah, and shaddah, which are crucial for pronunciation
            `;

            const result = await model.generateContent(batchPrompt)
            const textResponse = result.response.text()
            const jsonMatch = textResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : textResponse
            return JSON.parse(jsonString)
        } catch (error) {
            console.error('Error processing sentence batch:', error, sentences)
            return sentences.map(sentence => ({
                sentence,
                meaning: "Translation unavailable",
                words: []
            }))
        }
    }

    // Estimate tokens (unchanged)
    const estimateTokens = (text) => {
        const wordCount = text.split(/\s+/).length
        return wordCount * 2
    }

    // Create optimized batches (unchanged)
    const createOptimizedBatches = (sentences) => {
        const batches = []
        let currentBatch = []
        let currentTokenCount = 0

        for (const sentence of sentences) {
            const sentenceTokens = estimateTokens(sentence)
            if ((currentTokenCount + sentenceTokens > MAX_TOKENS - 1000) || currentBatch.length >= BATCH_SIZE) {
                if (currentBatch.length > 0) {
                    batches.push([...currentBatch])
                    currentBatch = []
                    currentTokenCount = 0
                }
            }
            currentBatch.push(sentence)
            currentTokenCount += sentenceTokens
        }
        if (currentBatch.length > 0) batches.push(currentBatch)
        return batches
    }

    // Process Arabic text in batches (unchanged)
    const processArabicTextInBatches = async (arabicText, apiKey) => {
        try {
            const textStructure = await extractTextStructure(arabicText, apiKey)
            const processedData = []
            const totalSections = textStructure.length
            let overallProgress = 0.3

            for (let i = 0; i < totalSections; i++) {
                const section = textStructure[i]
                const sectionProgressWeight = 0.7 / totalSections
                setProcessStatus(`Processing section ${i + 1}/${totalSections}...`)
                console.log(`Processing section ${i + 1}/${totalSections}: ${section.name}`)

                const processedSection = { name: section.name, sentences: [] }
                const sentenceBatches = createOptimizedBatches(section.sentences)
                const batchProgressIncrement = sectionProgressWeight / sentenceBatches.length

                for (let j = 0; j < sentenceBatches.length; j++) {
                    const batch = sentenceBatches[j]
                    setProcessStatus(`Processing section ${i + 1}, batch ${j + 1}/${sentenceBatches.length} (${batch.length} sentences)...`)
                    console.log(`Processing batch ${j + 1}/${sentenceBatches.length} with ${batch.length} sentences`)

                    const processedBatch = await processSentenceBatch(batch, apiKey)
                    processedSection.sentences.push(...processedBatch)
                    overallProgress += batchProgressIncrement
                    setProcessingProgress(overallProgress)
                }
                processedData.push(processedSection)
            }

            console.log('All processing complete!')
            setProcessStatus('Processing complete')
            setProcessingProgress(1)
            return processedData
        } catch (error) {
            console.error('Error in batch processing:', error)
            setProcessStatus(`Error in processing: ${error.message}`)
            return [{
                name: "Error Section",
                sentences: [{
                    sentence: arabicText,
                    meaning: "Processing error occurred",
                    words: []
                }]
            }]
        }
    }

    const handleSectionChange = (sectionIndex) => {
        setCurrentSectionIndex(sectionIndex)
        setCurrentSentenceIndex(0)
        setWordRevealIndex(-1)
        setShowFullSentence(true)
    }

    // Game UI handlers (unchanged)
    const handleNextSentence = () => {
        if (!readerData) return
        const currentSection = readerData[currentSectionIndex]
        if (currentSentenceIndex < currentSection.sentences.length - 1) {
            setCurrentSentenceIndex(currentSentenceIndex + 1)
        } else if (currentSectionIndex < readerData.length - 1) {
            setCurrentSectionIndex(currentSectionIndex + 1)
            setCurrentSentenceIndex(0)
        }
        setWordRevealIndex(-1)
        setShowFullSentence(true)
        setPoints(points + 10)
        setStreak(streak + 1)
    }

    const handlePrevSentence = () => {
        if (!readerData) return
        if (currentSentenceIndex > 0) {
            setCurrentSentenceIndex(currentSentenceIndex - 1)
        } else if (currentSectionIndex > 0) {
            setCurrentSectionIndex(currentSectionIndex - 1)
            const prevSection = readerData[currentSectionIndex - 1]
            setCurrentSentenceIndex(prevSection.sentences.length - 1)
        }
        setWordRevealIndex(-1)
        setShowFullSentence(true)
    }

    
    // Progress bar component (unchanged)
    const ProgressBar = ({ progress, width, height = 6, color = '#5c6bc0', backgroundColor = '#e0e0e0' }) => {
        return (
            <View style={{ height, width: width || '100%', backgroundColor, borderRadius: height / 2, overflow: 'hidden' }}>
                <View style={{ height: '100%', width: `${Math.min(100, Math.max(0, progress * 100))}%`, backgroundColor: color, borderRadius: height / 2 }} />
            </View>
        )
    }

    // Render current sentence (unchanged)
    const renderCurrentSentence = () => {
        if (!readerData || readerData.length === 0) return null
        const currentSection = readerData[currentSectionIndex]
        const currentSentence = currentSection.sentences[currentSentenceIndex]
        if (!currentSentence) return null

        return (
            <Animated.View style={{ opacity: fadeAnim, transform: [{ translateY: slideAnim }], backgroundColor: '#f8f8ff', borderRadius: 16, padding: 16, marginVertical: 0, elevation: 4, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1, shadowRadius: 4 }}>
                <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 12 }}>
                    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                        <FontAwesome5 name="book-reader" size={18} color="#5c6bc0" />
                        <Text style={{ marginLeft: 8, fontSize: 16, color: '#5c6bc0', fontWeight: '500' }}>
                            Sentence {currentSentenceIndex + 1}/{currentSection.sentences.length}
                        </Text>
                    </View>
                </View>
                <View>
                    <View>
                        <Text style={{ fontSize: 24, textAlign: 'right', marginBottom: 12, lineHeight: 36 }}>{currentSentence.sentence}</Text>
                        <Text style={{ fontSize: 18, color: '#555', marginBottom: 16 }}>{currentSentence.meaning}</Text>
                    </View>
                    <View>
                        {currentSentence.words.map((word, index) => (
                            <TouchableOpacity key={index} style={{ flexDirection: 'row', justifyContent: 'space-between', backgroundColor: index <= wordRevealIndex ? '#e8f5e9' : '#f5f5f5', padding: 12, borderRadius: 8, marginBottom: 8, opacity: index <= wordRevealIndex ? 1 : 0.7 }} onPress={() => {
                                if (wordRevealIndex < currentSentence.words.length - 1) {
                                    setWordRevealIndex(index)
                                    setPoints(points + 2)
                                }
                            }}>
                                <Text style={{ fontSize: 16, color: index <= wordRevealIndex ? '#2e7d32' : '#aaa' }}>{index <= wordRevealIndex ? word.meaning : '? ? ?'}</Text>
                                <Text style={{ fontSize: 18, fontWeight: '500' }}>{word.word}</Text>
                            </TouchableOpacity>
                        ))}
                    </View>
                </View>
            </Animated.View>
        )
    }

    // Loading screen (unchanged)
    if (loading) {
        return (
            <SafeAreaView style={{ flex: 1, backgroundColor: '#f0f8ff' }}>
                <StatusBar barStyle="dark-content" />
                <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 }}>
                    <View style={{ backgroundColor: 'white', borderRadius: 20, padding: 24, width: '100%', alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.1, shadowRadius: 10, elevation: 5 }}>
                        <FontAwesome5 name="bolt" size={60} color="#5c6bc0" style={{ marginBottom: 20 }} />
                        <Text style={{ fontSize: 22, fontWeight: 'bold', color: '#333', marginBottom: 12 }}>Processing with AI</Text>
                        <Text style={{ fontSize: 16, color: '#666', textAlign: 'center', marginBottom: 24 }}>{processStatus}</Text>
                        <ProgressBar progress={processingProgress} height={8} color="#5c6bc0" backgroundColor="#e0e0e0" />
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 20 }}>
                            <ActivityIndicator size="small" color="#5c6bc0" />
                            <Text style={{ marginLeft: 10, color: '#5c6bc0', fontWeight: '500' }}>{Math.round(processingProgress * 100)}% Complete</Text>
                        </View>
                        <Text style={{ fontSize: 14, color: '#999', marginTop: 24, textAlign: 'center' }}>We're analyzing the Arabic text to create{'\n'}an interactive learning experience for you, this will only happen once</Text>
                    </View>
                </View>
            </SafeAreaView>
        )
    }

    // Main render
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" />
            {/* Header with regenerate button */}
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                    <Text className="ml-2 text-base text-gray-800">Back</Text>
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800">{lesson.title || 'Arabic Reader'}</Text>
                <View className="flex-row items-center">
                    <TouchableOpacity onPress={handleRegenerate} disabled={loading} className={`mr-2 ${loading ? 'opacity-50' : ''}`}>
                        <FontAwesome5 name="sync" size={20} color="#333" />
                    </TouchableOpacity>
                    <View className="bg-green-100 px-2 py-1 rounded-full flex-row items-center">
                        <FontAwesome5 name="star" size={14} color="#4caf50" />
                        <Text className="ml-1 text-green-600 font-bold">{points}</Text>
                    </View>
                    <View className="bg-orange-100 px-2 py-1 rounded-full flex-row items-center ml-2">
                        <FontAwesome5 name="fire" size={14} color="#ff9800" />
                        <Text className="ml-1 text-orange-600 font-bold">{streak}</Text>
                    </View>
                </View>
            </View>

            {/* Section selector */}
            {readerData && readerData.length > 0 && (
                <ReaderSelector sections={readerData} currentSectionIndex={currentSectionIndex} onSelectSection={handleSectionChange} className="mx-4 mt-4" />
            )}

            <View className="px-6">
                <ProgressBar progress={(currentSentenceIndex + 1) / (readerData[currentSectionIndex].sentences.length)} height={8} color="#5c6bc0" backgroundColor="#e0e0e0" />
            </View>

            {/* Main content */}
            <ScrollView style={{ flex: 1, padding: 16 }}>{renderCurrentSentence()}</ScrollView>

            {/* Navigation controls */}
            <View className="flex-row justify-between p-4 border-t border-gray-200 bg-white">
                <TouchableOpacity onPress={handlePrevSentence} className={`bg-gray-100 p-3 rounded-lg flex-row items-center justify-center w-5/12 ${(currentSectionIndex === 0 && currentSentenceIndex === 0) ? 'opacity-50' : ''}`} disabled={currentSectionIndex === 0 && currentSentenceIndex === 0}>
                    <Ionicons name="arrow-back" size={20} color="#666" />
                    <Text className="ml-2 text-gray-600 font-medium">Previous</Text>
                </TouchableOpacity>
                {(currentSectionIndex === readerData.length - 1 && currentSentenceIndex === readerData[currentSectionIndex].sentences.length - 1) ? (
                    <TouchableOpacity onPress={async () => {
                        let oldScore = parseInt(await SecureStore.getItemAsync("score-" + subInt)) || 0
                        let score = oldScore
                        let pointsToAdd = 0
                        for (let i = 0; i < lesson.tools.length; i++) {
                            if (lesson.tools[i].name === "arabic-reader") pointsToAdd += lesson.tools[i].score
                        }
                        score += pointsToAdd
                        setScoreAdded(pointsToAdd)
                        setTotalScore(score)
                        setShowCompletionModal(true)
                        scoreAnim.setValue(0)
                        Animated.timing(scoreAnim, { toValue: 1, duration: 1500, useNativeDriver: false }).start()
                        await SecureStore.setItemAsync('score-' + subInt, score + "")
                    }} className="bg-green-600 p-3 rounded-lg flex-row items-center justify-center w-5/12">
                        <Text className="mr-2 text-white font-medium">Complete</Text>
                        <Ionicons name="checkmark-outline" size={20} color="white" />
                    </TouchableOpacity>
                ) : (
                    <TouchableOpacity onPress={handleNextSentence} className="bg-indigo-600 p-3 rounded-lg flex-row items-center justify-center w-5/12">
                        <Text className="mr-2 text-white font-medium">Next</Text>
                        <Ionicons name="arrow-forward" size={20} color="white" />
                    </TouchableOpacity>
                )}
            </View>

            {/* Completion modal (unchanged) */}
            <Modal visible={showCompletionModal} transparent={true} animationType="fade">
                <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center', padding: 20 }}>
                    <View style={{ backgroundColor: 'white', borderRadius: 20, padding: 24, width: '90%', alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 10, elevation: 10 }}>
                        <View style={{ backgroundColor: '#FFF9C4', borderRadius: 50, width: 100, height: 100, justifyContent: 'center', alignItems: 'center', marginBottom: 20 }}>
                            <MaterialCommunityIcons name="trophy-award" size={60} color="#FFC107" />
                        </View>
                        <Text style={{ fontSize: 24, fontWeight: 'bold', color: '#333', marginBottom: 8 }}>Lesson Complete!</Text>
                        <Text style={{ fontSize: 16, color: '#666', textAlign: 'center', marginBottom: 24 }}>Great job! You've finished this reading exercise.</Text>
                        <View style={{ backgroundColor: '#E8F5E9', borderRadius: 12, padding: 16, width: '100%', alignItems: 'center', marginBottom: 20 }}>
                            <Text style={{ fontSize: 16, color: '#388E3C', marginBottom: 8 }}>Points Earned:</Text>
                            <Animated.Text style={{ fontSize: 36, fontWeight: 'bold', color: '#2E7D32', transform: [{ scale: scoreAnim.interpolate({ inputRange: [0, 0.5, 1], outputRange: [1, 1.3, 1] }) }] }}>
                                +{parseInt(scoreAdded)}
                            </Animated.Text>
                        </View>
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 24 }}>
                            <FontAwesome5 name="star" size={20} color="#FFC107" />
                            <Text style={{ marginLeft: 8, fontSize: 16, color: '#555' }}>Total Score: {totalScore}</Text>
                        </View>
                        <TouchableOpacity onPress={() => { setShowCompletionModal(false); router.back() }} style={{ backgroundColor: '#5c6bc0', paddingVertical: 12, paddingHorizontal: 24, borderRadius: 8, width: '100%', alignItems: 'center' }}>
                            <Text style={{ color: 'white', fontSize: 16, fontWeight: '500' }}>Continue</Text>
                        </TouchableOpacity>
                    </View>
                </View>
            </Modal>
        </SafeAreaView>
    )
}

export default ArabicReader
--- END OF FILE app/tools/arabic-reader.jsx ---

--- START OF FILE app/tools/hindi-reader.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, ActivityIndicator, Animated, Modal, Alert } from 'react-native'
import { Ionicons, MaterialIcons, FontAwesome5, MaterialCommunityIcons } from '@expo/vector-icons'
import React, { useState, useEffect, useRef } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import * as SecureStore from 'expo-secure-store'
import axios from 'axios'
import { GoogleGenerativeAI } from '@google/generative-ai'
import ReaderSelector from './components/ReaderSelector'

const HindiReader = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const [loading, setLoading] = useState(true)
    const [readerData, setReaderData] = useState(null)
    const [sentence, setSentence] = useState('')
    const [processStatus, setProcessStatus] = useState('Initializing...')
    const [processingProgress, setProcessingProgress] = useState(0)
    const [forceRegenerate, setForceRegenerate] = useState(false) // New state for regeneration

    // Game UI state variables
    const [currentSectionIndex, setCurrentSectionIndex] = useState(0)
    const [currentSentenceIndex, setCurrentSentenceIndex] = useState(0)
    const [showFullSentence, setShowFullSentence] = useState(true)
    const [wordRevealIndex, setWordRevealIndex] = useState(-1)
    const [points, setPoints] = useState(0)
    const [streak, setStreak] = useState(0)

    const [showCompletionModal, setShowCompletionModal] = useState(false)
    const [scoreAdded, setScoreAdded] = useState(0)
    const [totalScore, setTotalScore] = useState(0)
    const confettiAnim = useRef(new Animated.Value(0)).current
    const scoreAnim = useRef(new Animated.Value(0)).current

    // Animation refs
    const fadeAnim = useRef(new Animated.Value(0)).current
    const slideAnim = useRef(new Animated.Value(50)).current

    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    // Constants for batch processing
    const BATCH_SIZE = 5 // Process 5 sentences at once
    const MAX_TOKENS = 5000 // Target token limit for each request

    // Fetch and process data, with regeneration support
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true)
                
                const apiKey = await SecureStore.getItemAsync('google-api')
                
                if (!apiKey) {
                    console.error('Google API key not found in secure storage')
                    router.back()
                    alert("Please set API Key in tools at home")
                    return
                }

                setProcessStatus('Checking cached data...')
                const storageKey = `hindi-reader-${subInt}-${index}`
                let storedData = await SecureStore.getItemAsync(storageKey)

                if (storedData && !forceRegenerate) {
                    console.log('Using stored reader data')
                    setProcessStatus('Using cached data...')
                    setProcessingProgress(0.9)
                    setReaderData(JSON.parse(storedData))
                    setLoading(false)
                    return
                }

                setProcessStatus('Downloading Hindi text...')
                setProcessingProgress(0.1)
                let sentenceData;
                if (!lesson.text) {
                    const response = await axios.get(dataUrl)
                    sentenceData = response.data
                } else {
                    sentenceData = lesson.text
                }
                setSentence(sentenceData)
                setProcessingProgress(0.2)

                const processedData = await processHindiTextInBatches(sentenceData, apiKey)
                await SecureStore.setItemAsync(storageKey, JSON.stringify(processedData))
                setReaderData(processedData)
            } catch (error) {
                console.error('Error fetching data:', error)
                setProcessStatus(`Error: ${error.message}`)
            } finally {
                setForceRegenerate(false) // Reset regeneration flag
                setLoading(false)
            }
        }

        fetchData()
    }, [forceRegenerate]) // Depend on forceRegenerate to trigger reprocessing

    // Reset indices and game state when readerData changes
    useEffect(() => {
        if (readerData) {
            setCurrentSectionIndex(0)
            setCurrentSentenceIndex(0)
            setWordRevealIndex(-1)
            setShowFullSentence(true)
            setPoints(0)
            setStreak(0)
        }
    }, [readerData])

    // Animation for game UI
    useEffect(() => {
        if (!loading && readerData) {
            fadeAnim.setValue(0)
            slideAnim.setValue(50)
            Animated.parallel([
                Animated.timing(fadeAnim, { toValue: 1, duration: 500, useNativeDriver: true }),
                Animated.timing(slideAnim, { toValue: 0, duration: 500, useNativeDriver: true })
            ]).start()
        }
    }, [currentSentenceIndex, currentSectionIndex, loading])

    // Handle regeneration
    const handleRegenerate = () => {
        Alert.alert(
            "Regenerate Content",
            "Warning: This will reset your progress in this lesson and may take some time. Are you sure you want to regenerate the content?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Regenerate",
                    onPress: async () => {
                        setLoading(true)
                        setProcessStatus('Regenerating content...')
                        const storageKey = `hindi-reader-${subInt}-${index}`
                        await SecureStore.deleteItemAsync(storageKey)
                        setForceRegenerate(true)
                    }
                }
            ]
        )
    }

    // Extract text structure
    const extractTextStructure = async (hindiText, apiKey) => {
        try {
            setProcessStatus('Extracting text structure...')
            setProcessingProgress(0.25)
            console.log('Extracting text structure')

            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const structurePrompt = `
            I have a Hindi text that needs to be divided into sections and small sentences (no more than a few words) for processing.
            
            Text: ${hindiText}
            
            Please return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "name": "Section name in Hindi",
                "sentences": ["sentence1", "sentence2", ...]
              }
            ]
            
            Split the text naturally into sections if appropriate (like different stories, paragraphs about different topics, or information about a poet separate from their work). 
            If it's just one continuous text, use a single section.
            Ignore elements like unit names, poet name title (which should be given as section title)
            For each section, split the text into small logically meaningful sentences with 7-12 words
            Do not include any translations or additional information - ONLY the original Hindi text structure.
            Ensure proper representation of Hindi characters and diacritics (matras, etc.) for accurate pronunciation.
            All sections must have a name.
            `;

            const structureResult = await model.generateContent(structurePrompt)
            const structureResponse = structureResult.response.text()
            const jsonMatch = structureResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : structureResponse
            const structure = JSON.parse(jsonString)

            console.log('Text structure extracted:', structure)
            setProcessingProgress(0.3)
            return structure
        } catch (error) {
            console.error('Error extracting text structure:', error)
            return [{
                name: "मूल पाठ",
                sentences: [hindiText]
            }]
        }
    }

    // Process sentence batch
    const processSentenceBatch = async (sentences, apiKey) => {
        try {
            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const batchPrompt = `
            Analyze these Hindi sentences for a language learning app:
            
            Sentences: ${JSON.stringify(sentences)}
            
            Return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "sentence": "original Hindi sentence",
                "meaning": "English translation",
                "words": [
                  {"word": "hindi-word", "meaning": "english-word"}
                ]
              }
            ]
            
            Process each sentence in the array and provide a detailed analysis for each one.
            Ignore commonly used words for meaning and also names, as well as connecting words like to, from, he, she, etc.
            Make sure to keep the exact same order as in the input array.
            Ensure proper representation of Hindi characters and diacritics (matras, etc.) for accurate pronunciation.
            `;

            const result = await model.generateContent(batchPrompt)
            const textResponse = result.response.text()
            const jsonMatch = textResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : textResponse
            return JSON.parse(jsonString)
        } catch (error) {
            console.error('Error processing sentence batch:', error, sentences)
            return sentences.map(sentence => ({
                sentence,
                meaning: "Translation unavailable",
                words: []
            }))
        }
    }

    // Estimate tokens
    const estimateTokens = (text) => {
        const wordCount = text.split(/\s+/).length
        return wordCount * 2
    }

    // Create optimized batches
    const createOptimizedBatches = (sentences) => {
        const batches = []
        let currentBatch = []
        let currentTokenCount = 0

        for (const sentence of sentences) {
            const sentenceTokens = estimateTokens(sentence)
            if ((currentTokenCount + sentenceTokens > MAX_TOKENS - 1000) || currentBatch.length >= BATCH_SIZE) {
                if (currentBatch.length > 0) {
                    batches.push([...currentBatch])
                    currentBatch = []
                    currentTokenCount = 0
                }
            }
            currentBatch.push(sentence)
            currentTokenCount += sentenceTokens
        }
        if (currentBatch.length > 0) batches.push(currentBatch)
        return batches
    }

    // Process Hindi text in batches
    const processHindiTextInBatches = async (hindiText, apiKey) => {
        try {
            const textStructure = await extractTextStructure(hindiText, apiKey)
            const processedData = []
            const totalSections = textStructure.length
            let overallProgress = 0.3

            for (let i = 0; i < totalSections; i++) {
                const section = textStructure[i]
                const sectionProgressWeight = 0.7 / totalSections
                setProcessStatus(`Processing section ${i + 1}/${totalSections}...`)
                console.log(`Processing section ${i + 1}/${totalSections}: ${section.name}`)

                const processedSection = { name: section.name, sentences: [] }
                const sentenceBatches = createOptimizedBatches(section.sentences)
                const batchProgressIncrement = sectionProgressWeight / sentenceBatches.length

                for (let j = 0; j < sentenceBatches.length; j++) {
                    const batch = sentenceBatches[j]
                    setProcessStatus(`Processing section ${i + 1}, batch ${j + 1}/${sentenceBatches.length} (${batch.length} sentences)...`)
                    console.log(`Processing batch ${j + 1}/${sentenceBatches.length} with ${batch.length} sentences`)

                    const processedBatch = await processSentenceBatch(batch, apiKey)
                    processedSection.sentences.push(...processedBatch)
                    overallProgress += batchProgressIncrement
                    setProcessingProgress(overallProgress)
                }
                processedData.push(processedSection)
            }

            console.log('All processing complete!')
            setProcessStatus('Processing complete')
            setProcessingProgress(1)
            return processedData
        } catch (error) {
            console.error('Error in batch processing:', error)
            setProcessStatus(`Error in processing: ${error.message}`)
            return [{
                name: "त्रुटि अनुभाग",
                sentences: [{
                    sentence: hindiText,
                    meaning: "Processing error occurred",
                    words: []
                }]
            }]
        }
    }

    const handleSectionChange = (sectionIndex) => {
        setCurrentSectionIndex(sectionIndex)
        setCurrentSentenceIndex(0)
        setWordRevealIndex(-1)
        setShowFullSentence(true)
    }

    // Game UI handlers
    const handleNextSentence = () => {
        if (!readerData) return
        const currentSection = readerData[currentSectionIndex]
        if (currentSentenceIndex < currentSection.sentences.length - 1) {
            setCurrentSentenceIndex(currentSentenceIndex + 1)
        } else if (currentSectionIndex < readerData.length - 1) {
            setCurrentSectionIndex(currentSectionIndex + 1)
            setCurrentSentenceIndex(0)
        }
        setWordRevealIndex(-1)
        setShowFullSentence(true)
        setPoints(points + 10)
        setStreak(streak + 1)
    }

    const handlePrevSentence = () => {
        if (!readerData) return
        if (currentSentenceIndex > 0) {
            setCurrentSentenceIndex(currentSentenceIndex - 1)
        } else if (currentSectionIndex > 0) {
            setCurrentSectionIndex(currentSectionIndex - 1)
            const prevSection = readerData[currentSectionIndex - 1]
            setCurrentSentenceIndex(prevSection.sentences.length - 1)
        }
        setWordRevealIndex(-1)
        setShowFullSentence(true)
    }

    // Progress bar component
    const ProgressBar = ({ progress, width, height = 6, color = '#5c6bc0', backgroundColor = '#e0e0e0' }) => {
        return (
            <View style={{ height, width: width || '100%', backgroundColor, borderRadius: height / 2, overflow: 'hidden' }}>
                <View style={{ height: '100%', width: `${Math.min(100, Math.max(0, progress * 100))}%`, backgroundColor: color, borderRadius: height / 2 }} />
            </View>
        )
    }

    // Render current sentence
    const renderCurrentSentence = () => {
        if (!readerData || readerData.length === 0) return null
        const currentSection = readerData[currentSectionIndex]
        const currentSentence = currentSection.sentences[currentSentenceIndex]
        if (!currentSentence) return null

        return (
            <Animated.View style={{ opacity: fadeAnim, transform: [{ translateY: slideAnim }], backgroundColor: '#f8f8ff', borderRadius: 16, padding: 16, marginVertical: 0, elevation: 4, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1, shadowRadius: 4 }}>
                <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 12 }}>
                    <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                        <FontAwesome5 name="book-reader" size={18} color="#5c6bc0" />
                        <Text style={{ marginLeft: 8, fontSize: 16, color: '#5c6bc0', fontWeight: '500' }}>
                            Sentence {currentSentenceIndex + 1}/{currentSection.sentences.length}
                        </Text>
                    </View>
                </View>
                <View>
                    <View>
                        <Text style={{ fontSize: 24, textAlign: 'right', marginBottom: 12, lineHeight: 36 }}>{currentSentence.sentence}</Text>
                        <Text style={{ fontSize: 18, color: '#555', marginBottom: 16 }}>{currentSentence.meaning}</Text>
                    </View>
                    <View>
                        {currentSentence.words.map((word, index) => (
                            <TouchableOpacity key={index} style={{ flexDirection: 'row', justifyContent: 'space-between', backgroundColor: index <= wordRevealIndex ? '#e8f5e9' : '#f5f5f5', padding: 12, borderRadius: 8, marginBottom: 8, opacity: index <= wordRevealIndex ? 1 : 0.7 }} onPress={() => {
                                if (wordRevealIndex < currentSentence.words.length - 1) {
                                    setWordRevealIndex(index)
                                    setPoints(points + 2)
                                }
                            }}>
                                <Text style={{ fontSize: 16, color: index <= wordRevealIndex ? '#2e7d32' : '#aaa' }}>{index <= wordRevealIndex ? word.meaning : '? ? ?'}</Text>
                                <Text style={{ fontSize: 18, fontWeight: '500' }}>{word.word}</Text>
                            </TouchableOpacity>
                        ))}
                    </View>
                </View>
            </Animated.View>
        )
    }

    // Loading screen
    if (loading) {
        return (
            <SafeAreaView style={{ flex: 1, backgroundColor: '#f0f8ff' }}>
                <StatusBar barStyle="dark-content" />
                <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 }}>
                    <View style={{ backgroundColor: 'white', borderRadius: 20, padding: 24, width: '100%', alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.1, shadowRadius: 10, elevation: 5 }}>
                        <FontAwesome5 name="bolt" size={60} color="#5c6bc0" style={{ marginBottom: 20 }} />
                        <Text style={{ fontSize: 22, fontWeight: 'bold', color: '#333', marginBottom: 12 }}>Processing with AI</Text>
                        <Text style={{ fontSize: 16, color: '#666', textAlign: 'center', marginBottom: 24 }}>{processStatus}</Text>
                        <ProgressBar progress={processingProgress} height={8} color="#5c6bc0" backgroundColor="#e0e0e0" />
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 20 }}>
                            <ActivityIndicator size="small" color="#5c6bc0" />
                            <Text style={{ marginLeft: 10, color: '#5c6bc0', fontWeight: '500' }}>{Math.round(processingProgress * 100)}% Complete</Text>
                        </View>
                        <Text style={{ fontSize: 14, color: '#999', marginTop: 24, textAlign: 'center' }}>We're analyzing the Hindi text to create{'\n'}an interactive learning experience for you, this will only happen once</Text>
                    </View>
                </View>
            </SafeAreaView>
        )
    }

    // Main render
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" />
            {/* Header with regenerate button */}
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                    <Text className="ml-2 text-base text-gray-800">Back</Text>
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800">{lesson.title || 'Hindi Reader'}</Text>
                <View className="flex-row items-center">
                    <TouchableOpacity onPress={handleRegenerate} disabled={loading} className={`mr-2 ${loading ? 'opacity-50' : ''}`}>
                        <FontAwesome5 name="sync" size={20} color="#333" />
                    </TouchableOpacity>
                    <View className="bg-green-100 px-2 py-1 rounded-full flex-row items-center">
                        <FontAwesome5 name="star" size={14} color="#4caf50" />
                        <Text className="ml-1 text-green-600 font-bold">{points}</Text>
                    </View>
                    <View className="bg-orange-100 px-2 py-1 rounded-full flex-row items-center ml-2">
                        <FontAwesome5 name="fire" size={14} color="#ff9800" />
                        <Text className="ml-1 text-orange-600 font-bold">{streak}</Text>
                    </View>
                </View>
            </View>

            {/* Section selector */}
            {readerData && readerData.length > 0 && (
                <ReaderSelector sections={readerData} currentSectionIndex={currentSectionIndex} onSelectSection={handleSectionChange} className="mx-4 mt-4" />
            )}

            <View className="px-6">
                <ProgressBar progress={(currentSentenceIndex + 1) / (readerData[currentSectionIndex].sentences.length)} height={8} color="#5c6bc0" backgroundColor="#e0e0e0" />
            </View>

            {/* Main content */}
            <ScrollView style={{ flex: 1, padding: 16 }}>{renderCurrentSentence()}</ScrollView>

            {/* Navigation controls */}
            <View className="flex-row justify-between p-4 border-t border-gray-200 bg-white">
                <TouchableOpacity onPress={handlePrevSentence} className={`bg-gray-100 p-3 rounded-lg flex-row items-center justify-center w-5/12 ${(currentSectionIndex === 0 && currentSentenceIndex === 0) ? 'opacity-50' : ''}`} disabled={currentSectionIndex === 0 && currentSentenceIndex === 0}>
                    <Ionicons name="arrow-back" size={20} color="#666" />
                    <Text className="ml-2 text-gray-600 font-medium">Previous</Text>
                </TouchableOpacity>
                {(currentSectionIndex === readerData.length - 1 && currentSentenceIndex === readerData[currentSectionIndex].sentences.length - 1) ? (
                    <TouchableOpacity onPress={async () => {
                        let oldScore = parseInt(await SecureStore.getItemAsync("score-" + subInt)) || 0
                        let score = oldScore
                        let pointsToAdd = 0
                        for (let i = 0; i < lesson.tools.length; i++) {
                            if (lesson.tools[i].name === "hindi-reader") pointsToAdd += lesson.tools[i].score
                        }
                        score += pointsToAdd
                        setScoreAdded(pointsToAdd)
                        setTotalScore(score)
                        setShowCompletionModal(true)
                        scoreAnim.setValue(0)
                        Animated.timing(scoreAnim, { toValue: 1, duration: 1500, useNativeDriver: false }).start()
                        await SecureStore.setItemAsync('score-' + subInt, score + "")
                    }} className="bg-green-600 p-3 rounded-lg flex-row items-center justify-center w-5/12">
                        <Text className="mr-2 text-white font-medium">Complete</Text>
                        <Ionicons name="checkmark-outline" size={20} color="white" />
                    </TouchableOpacity>
                ) : (
                    <TouchableOpacity onPress={handleNextSentence} className="bg-indigo-600 p-3 rounded-lg flex-row items-center justify-center w-5/12">
                        <Text className="mr-2 text-white font-medium">Next</Text>
                        <Ionicons name="arrow-forward" size={20} color="white" />
                    </TouchableOpacity>
                )}
            </View>

            {/* Completion modal */}
            <Modal visible={showCompletionModal} transparent={true} animationType="fade">
                <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'center', alignItems: 'center', padding: 20 }}>
                    <View style={{ backgroundColor: 'white', borderRadius: 20, padding: 24, width: '90%', alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 4 }, shadowOpacity: 0.3, shadowRadius: 10, elevation: 10 }}>
                        <View style={{ backgroundColor: '#FFF9C4', borderRadius: 50, width: 100, height: 100, justifyContent: 'center', alignItems: 'center', marginBottom: 20 }}>
                            <MaterialCommunityIcons name="trophy-award" size={60} color="#FFC107" />
                        </View>
                        <Text style={{ fontSize: 24, fontWeight: 'bold', color: '#333', marginBottom: 8 }}>Lesson Complete!</Text>
                        <Text style={{ fontSize: 16, color: '#666', textAlign: 'center', marginBottom: 24 }}>Great job! You've finished this reading exercise.</Text>
                        <View style={{ backgroundColor: '#E8F5E9', borderRadius: 12, padding: 16, width: '100%', alignItems: 'center', marginBottom: 20 }}>
                            <Text style={{ fontSize: 16, color: '#388E3C', marginBottom: 8 }}>Points Earned:</Text>
                            <Animated.Text style={{ fontSize: 36, fontWeight: 'bold', color: '#2E7D32', transform: [{ scale: scoreAnim.interpolate({ inputRange: [0, 0.5, 1], outputRange: [1, 1.3, 1] }) }] }}>
                                +{parseInt(scoreAdded)}
                            </Animated.Text>
                        </View>
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 24 }}>
                            <FontAwesome5 name="star" size={20} color="#FFC107" />
                            <Text style={{ marginLeft: 8, fontSize: 16, color: '#555' }}>Total Score: {totalScore}</Text>
                        </View>
                        <TouchableOpacity onPress={() => { setShowCompletionModal(false); router.back() }} style={{ backgroundColor: '#5c6bc0', paddingVertical: 12, paddingHorizontal: 24, borderRadius: 8, width: '100%', alignItems: 'center' }}>
                            <Text style={{ color: 'white', fontSize: 16, fontWeight: '500' }}>Continue</Text>
                        </TouchableOpacity>
                    </View>
                </View>
            </Modal>
        </SafeAreaView>
    )
}

export default HindiReader
--- END OF FILE app/tools/hindi-reader.jsx ---

--- START OF FILE app/tools/html.jsx ---
import { View, Text, TouchableOpacity, SafeAreaView, StatusBar, ActivityIndicator, Modal } from 'react-native'
import { Ionicons } from '@expo/vector-icons'
import React, { useEffect, useState, useRef } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import { getItemAsync, setItemAsync } from 'expo-secure-store'
import * as FileSystem from 'expo-file-system'
import { WebView } from 'react-native-webview'

const HtmlTool = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const { subject, index, subInt, lesson, toolInt } = JSON.parse(exp)
    const dataUrl = lesson.data

    const tool = lesson.tools[toolInt];
    
    const toolName = tool.name
    
    const [score, setScore] = useState(0)
    const [accuracy, setAccuracy] = useState(0)
    const [isLoading, setIsLoading] = useState(true)
    const [webpageContent, setWebpageContent] = useState('')
    const [showGameOver, setShowGameOver] = useState(false)
    const webViewRef = useRef(null)

    const localFilePath = `${FileSystem.cacheDirectory}${subInt}${lesson.name}${tool.webpage.split('/').pop()}`
    
    const loadScore = async () => {
        let storedScore = await getItemAsync('score-'+subInt)
        if(storedScore) setScore(parseInt(storedScore))
        else await setItemAsync("score-"+subInt, "0")
    }

    const loadWebpage = async () => {
        try {
            const fileInfo = await FileSystem.getInfoAsync(localFilePath)
            
            if (fileInfo.exists) {
                // Load from local storage
                const content = await FileSystem.readAsStringAsync(localFilePath)
                setWebpageContent(content)
                console.log("It didn't die!")
            } else {
                // Download and save
                try {
                    const downloadResult = await FileSystem.downloadAsync(
                        tool.webpage,
                        localFilePath
                    )
                    
                    if (downloadResult.status === 200) {
                        const content = await FileSystem.readAsStringAsync(localFilePath)
                        setWebpageContent(content)
                        console.log("Oh good")
                    } else {
                        // Use template if download fails
                        setWebpageContent(getTemplateHtml())
                        
                        console.log("Oh good")
                    }
                } catch (err) {
                    console.error("Download error:", err)
                    setWebpageContent(getTemplateHtml())
                }
            }
        } catch (error) {
            console.error("Error loading webpage:", error)
            setWebpageContent(getTemplateHtml())
        } finally {
            setIsLoading(false)
        }
    }

    useEffect(() => {
        
        loadScore()
        loadWebpage()
    }, [])

    const getTemplateHtml = () => {
        return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Interactive Learning</title>
        </head>
        <body>
            <div class="container">
                <h1>Interactive Quiz</h1>
                <div class="quiz-container" id="quiz">
                    <!-- Questions will be dynamically loaded here -->
                </div>
                <div class="result" id="result"></div>
                <button id="submit-btn" style="display:none;">Submit Answers</button>
            </div>

            <script>
                // Sample quiz questions
                const quizQuestions = [
                    {
                        question: "What is the capital of France?",
                        options: ["London", "Berlin", "Paris", "Madrid"],
                        answer: 2
                    },
                    {
                        question: "Which planet is known as the Red Planet?",
                        options: ["Earth", "Mars", "Jupiter", "Venus"],
                        answer: 1
                    },
                    {
                        question: "What is 2 + 2?",
                        options: ["3", "4", "5", "6"],
                        answer: 1
                    }
                ];

                let correctAnswers = 0;
                let totalQuestions = quizQuestions.length;
                let userAnswers = [];
                let quizCompleted = false;

                // Load questions
                function loadQuiz() {
                    const quizContainer = document.getElementById('quiz');
                    quizContainer.innerHTML = '';
                    
                    quizQuestions.forEach((q, qIndex) => {
                        const questionDiv = document.createElement('div');
                        questionDiv.className = 'question-block';
                        
                        const questionText = document.createElement('div');
                        questionText.className = 'question';
                        questionText.textContent = \`\${qIndex + 1}. \${q.question}\`;
                        questionDiv.appendChild(questionText);
                        
                        const optionsDiv = document.createElement('div');
                        optionsDiv.className = 'options';
                        
                        q.options.forEach((opt, optIndex) => {
                            const optionBtn = document.createElement('div');
                            optionBtn.className = 'option-btn';
                            optionBtn.textContent = opt;
                            optionBtn.dataset.qIndex = qIndex;
                            optionBtn.dataset.optIndex = optIndex;
                            
                            optionBtn.addEventListener('click', function() {
                                if (!quizCompleted) {
                                    // Remove selection from other options in this question
                                    const optionBtns = optionsDiv.querySelectorAll('.option-btn');
                                    optionBtns.forEach(btn => {
                                        btn.style.backgroundColor = '#f1f1f1';
                                        btn.style.fontWeight = 'normal';
                                    });
                                    
                                    // Highlight selected option
                                    this.style.backgroundColor = '#b3e5fc';
                                    this.style.fontWeight = 'bold';
                                    
                                    // Save user's answer
                                    userAnswers[qIndex] = parseInt(this.dataset.optIndex);
                                    
                                    // Show submit button if all questions are answered
                                    if (userAnswers.filter(a => a !== undefined).length === totalQuestions) {
                                        document.getElementById('submit-btn').style.display = 'block';
                                    }
                                }
                            });
                            
                            optionsDiv.appendChild(optionBtn);
                        });
                        
                        questionDiv.appendChild(optionsDiv);
                        quizContainer.appendChild(questionDiv);
                    });
                    
                    // Add event listener to submit button
                    document.getElementById('submit-btn').addEventListener('click', checkAnswers);
                }

                // Check answers and display results
                function checkAnswers() {
                    if (quizCompleted) return;
                    
                    quizCompleted = true;
                    correctAnswers = 0;
                    
                    quizQuestions.forEach((q, qIndex) => {
                        const userAnswer = userAnswers[qIndex];
                        const correctAnswer = q.answer;
                        
                        const options = document.querySelectorAll(\`[data-q-index="\${qIndex}"]\`);
                        
                        options.forEach((opt, optIndex) => {
                            if (optIndex === correctAnswer) {
                                opt.classList.add('correct');
                            } else if (optIndex === userAnswer) {
                                opt.classList.add('incorrect');
                            }
                        });
                        
                        if (userAnswer === correctAnswer) {
                            correctAnswers++;
                        }
                    });
                    
                    const accuracy = correctAnswers / totalQuestions;
                    const resultText = \`You got \${correctAnswers} out of \${totalQuestions} correct. Accuracy: \${(accuracy * 100).toFixed(0)}%\`;
                    document.getElementById('result').textContent = resultText;
                    
                    // Hide submit button and show complete button
                    document.getElementById('submit-btn').style.display = 'none';
                    
                    // Send accuracy data to React Native
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        type: 'setAccuracy',
                        accuracy: accuracy
                    }));
                    
                    // Add game over button
                    const gameOverBtn = document.createElement('button');
                    gameOverBtn.textContent = 'Complete Quiz';
                    gameOverBtn.addEventListener('click', function() {
                        window.ReactNativeWebView.postMessage(JSON.stringify({
                            type: 'gameOver'
                        }));
                    });
                    document.getElementById('result').appendChild(document.createElement('br'));
                    document.getElementById('result').appendChild(gameOverBtn);
                }

                // Initialize the quiz
                window.onload = loadQuiz;
            </script>
        </body>
        </html>
        `;
    }

    const gameOver = async () => {
        let addScore = Math.round(accuracy * tool.score);
        const newScore = score + addScore;
        setScore(newScore);
        await setItemAsync("score-" + subInt, newScore.toString());
        setShowGameOver(true);
    }

    const handleRetry = () => {
        setShowGameOver(false);
        setAccuracy(0);
        if (webViewRef.current) {
            webViewRef.current.reload();
        }
    }

    const handleWebViewMessage = (event) => {
        try {
            const data = JSON.parse(event.nativeEvent.data);
            if (data.type === 'setAccuracy') {
                setAccuracy(data.accuracy);
            } else if (data.type === 'gameOver') {
                gameOver();
            }
        } catch (error) {
            console.error('Error parsing WebView message:', error);
        }
    }

    const handleRefresh = async () =>{
        setIsLoading(true)
        try{
            const fileInfo = await FileSystem.getInfoAsync(localFilePath)
            
            if (fileInfo.exists) await FileSystem.deleteAsync(localFilePath)
            console.log("Reloading")
            await loadWebpage()
        }catch(e){
            console.log(e)
        }

        setIsLoading(false)
    }

    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" backgroundColor="#fff"/>
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800 mr-auto ml-auto">{tool.label}</Text>
                <TouchableOpacity onPress={handleRefresh} className="flex-row items-center">
                    <Ionicons name="refresh" size={24} color="#333" />
                </TouchableOpacity>
            </View>
            
            {isLoading ? (
                <View className="flex-1 justify-center items-center">
                    <ActivityIndicator size="large" color="#0000ff" />
                    <Text className="mt-4 text-gray-600">Loading content...</Text>
                </View>
            ) : (
                <View className="flex-1">
                    <WebView
                        ref={webViewRef}
                        originWhitelist={['*']}
                        source={{ html: webpageContent }}
                        onMessage={handleWebViewMessage}
                        javaScriptEnabled={true}
                        domStorageEnabled={true}
                        startInLoadingState={true}
                        renderLoading={() => (
                            <View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, justifyContent: 'center', alignItems: 'center' }}>
                                <ActivityIndicator size="large" color="#0000ff" />
                            </View>
                        )}
                    />
                </View>
            )}
            
            {/* Game Over Modal */}
            <Modal
                animationType="slide"
                transparent={true}
                visible={showGameOver}
                onRequestClose={() => setShowGameOver(false)}
            >
                <View className="flex-1 justify-center items-center bg-black bg-opacity-50">
                    <View className="bg-white p-6 rounded-xl w-4/5 items-center shadow-lg">
                        <View className="w-20 h-20 rounded-full bg-green-100 justify-center items-center mb-4">
                            <Ionicons name="checkmark-circle" size={50} color="#4CAF50" />
                        </View>
                        <Text className="text-2xl font-bold text-gray-800 mb-2">Task Complete!</Text>
                        <Text className="text-lg text-gray-600 mb-1">Accuracy: {(accuracy * 100).toFixed(0)}%</Text>
                        <Text className="text-lg text-gray-600 mb-4">Points earned: {Math.round(accuracy * tool.score)}</Text>
                        <Text className="text-lg text-gray-600 mb-6">Total score: {score}</Text>
                        
                        <View className="flex-row justify-around w-full">
                            <TouchableOpacity 
                                onPress={handleRetry} 
                                className="bg-blue-500 py-3 px-6 rounded-lg"
                            >
                                <Text className="text-white font-bold">Try Again</Text>
                            </TouchableOpacity>
                            <TouchableOpacity 
                                onPress={() => router.back()} 
                                className="bg-gray-500 py-3 px-6 rounded-lg"
                            >
                                <Text className="text-white font-bold">Go Back</Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                </View>
            </Modal>
        </SafeAreaView>
    )
}

export default HtmlTool
--- END OF FILE app/tools/html.jsx ---

--- START OF FILE app/tools/py-memory.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, ActivityIndicator, Alert, TextInput } from 'react-native'
import { Ionicons, FontAwesome5, MaterialIcons } from '@expo/vector-icons'
import React, { useState, useEffect, useRef } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import * as SecureStore from 'expo-secure-store'
import axios from 'axios'
import { GoogleGenerativeAI } from '@google/generative-ai'
import ReaderSelector from './components/ReaderSelector'

const PythonMemoryTest = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const [loading, setLoading] = useState(true)
    const [gameData, setGameData] = useState(null)
    const [processStatus, setProcessStatus] = useState('Initializing...')
    const [processingProgress, setProcessingProgress] = useState(0)
    const [forceRegenerate, setForceRegenerate] = useState(false)

    // Game state variables
    const [currentSectionIndex, setCurrentSectionIndex] = useState(0)
    const [currentLineIndex, setCurrentLineIndex] = useState(0)
    const [userInput, setUserInput] = useState('')
    const [showHint, setShowHint] = useState(false)
    const [showAnswer, setShowAnswer] = useState(false)
    const [correctAnswers, setCorrectAnswers] = useState(0)
    const [totalAttempts, setTotalAttempts] = useState(0)
    const [points, setPoints] = useState(0)
    const [isComplete, setIsComplete] = useState(false)
    const [difficultyLevel, setDifficultyLevel] = useState(1) // 1-3, higher is more difficult
    const [studyMode, setStudyMode] = useState(true) // Start in study mode to allow initial code review
    
    const inputRef = useRef(null)

    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    // Fetch and process data
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true)
                setProcessStatus('Checking cached data...')
                const storageKey = `python-memory-${subInt}-${index}`
                let storedData = await SecureStore.getItemAsync(storageKey)

                if (storedData && !forceRegenerate) {
                    console.log('Using stored game data')
                    setProcessStatus('Using cached data...')
                    setProcessingProgress(0.9)
                    setGameData(JSON.parse(storedData))
                    setLoading(false)
                    return
                }

                setProcessStatus('Downloading Python code...')
                setProcessingProgress(0.1)
                let codeData;
                if (!lesson.text) {
                    const response = await axios.get(dataUrl)
                    codeData = response.data
                } else {
                    codeData = lesson.text
                }

                setProcessingProgress(0.2)

                const apiKey = await SecureStore.getItemAsync('google-api')
                if (!apiKey) {
                    console.error('Google API key not found in secure storage')
                    setProcessStatus('Error: API key not found, Set API Key in Tools')
                    return
                }

                const processedData = await processPythonCodeForMemory(codeData, apiKey)
                await SecureStore.setItemAsync(storageKey, JSON.stringify(processedData))
                setGameData(processedData)
            } catch (error) {
                console.error('Error fetching data:', error)
                setProcessStatus(`Error: ${error.message}`)
            } finally {
                setForceRegenerate(false)
                setLoading(false)
            }
        }

        fetchData()
    }, [forceRegenerate])

    // Reset indices and game state when gameData changes
    useEffect(() => {
        if (gameData) {
            setCurrentSectionIndex(0)
            setCurrentLineIndex(0)
            setUserInput('')
            setShowHint(false)
            setShowAnswer(false)
            setCorrectAnswers(0)
            setTotalAttempts(0)
            setPoints(0)
            setIsComplete(false)
            setStudyMode(true) // Start in study mode
        }
    }, [gameData])

    // Process Python code for memory game
    const processPythonCodeForMemory = async (pythonCode, apiKey) => {
        try {
            setProcessStatus('Analyzing Python code...')
            setProcessingProgress(0.3)
            console.log('Processing Python code for memory game')

            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.1 }
            })

            const memoryPrompt = `
            Create a Python code memory game from this code. Divide the code into logical sections and prepare each line for memorization practice:
            
            Python Code: ${pythonCode}
            
            Return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "name": "Section name (e.g. 'Functions', 'Classes', 'Main Loop')",
                "description": "Brief description of what this section does",
                "lines": [
                  {
                    "code": "The full line of code",
                    "indentation": "The leading whitespace/indentation",
                    "hint": "A hint about this line's purpose without revealing the exact syntax",
                    "difficulty": 1-3 (1 for easy lines like comments, 3 for complex expressions)
                  }
                ]
              }
            ]
            
            Guidelines:
            1. Break the code into 3-5 logical sections
            2. Include EVERY line of the original code, including blank lines, comments, etc.
            3. For blank lines, use an empty string for 'code' and 'indentation'
            4. For comments and easy syntax, set difficulty to 1
            5. For basic code (variable assignments, simple function calls), set difficulty to 2
            6. For complex expressions, function definitions, class methods, set difficulty to 3
            7. Hints should help recall without giving away the exact answer
            8. Preserve all indentation in the 'indentation' field and the actual code in the 'code' field
            `;

            setProcessStatus('Processing code for memorization...')
            setProcessingProgress(0.5)

            const gameResult = await model.generateContent(memoryPrompt)
            const gameResponse = gameResult.response.text()
            const jsonMatch = gameResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : gameResponse
            const gameData = JSON.parse(jsonString)

            console.log('Python memory game created:', gameData.length, 'sections')
            setProcessingProgress(1)
            return gameData
        } catch (error) {
            console.error('Error creating Python memory game:', error)
            return [{
                name: "Error Section",
                description: "Could not process the Python code",
                lines: [
                    {
                        code: "print('Error processing code for memory game')",
                        indentation: "",
                        hint: "Simple print statement showing an error",
                        difficulty: 1
                    }
                ]
            }]
        }
    }

    // Handle regeneration
    const handleRegenerate = () => {
        Alert.alert(
            "Regenerate Content",
            "This will reset your progress. Regenerate the content?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Regenerate",
                    onPress: async () => {
                        setLoading(true)
                        setProcessStatus('Regenerating content...')
                        const storageKey = `python-memory-${subInt}-${index}`
                        await SecureStore.deleteItemAsync(storageKey)
                        setForceRegenerate(true)
                    }
                }
            ]
        )
    }

    const handleSectionChange = (sectionIndex) => {
        setCurrentSectionIndex(sectionIndex)
        setCurrentLineIndex(0)
        setUserInput('')
        setShowHint(false)
        setShowAnswer(false)
        setStudyMode(true) // Return to study mode when changing sections
    }

    // Check user input against current line
    const checkAnswer = () => {
        if (!gameData || studyMode) return

        const currentSection = gameData[currentSectionIndex]
        const currentLine = currentSection.lines[currentLineIndex]
        const trimmedUserInput = userInput.trim()
        const trimmedCorrectAnswer = currentLine.code.trim()
        
        // Special case for empty lines
        if (currentLine.code === "" && (trimmedUserInput === "" || userInput === "")) {
            handleCorrectAnswer()
            return
        }
        
        // Case-sensitive exact match or close enough (ignores some whitespace differences)
        if (trimmedUserInput === trimmedCorrectAnswer || 
            userInput === currentLine.code) {
            handleCorrectAnswer()
        } else {
            // Wrong answer
            setTotalAttempts(totalAttempts + 1)
            setShowAnswer(true) // Show the correct answer
        }
    }

    const handleCorrectAnswer = () => {
        setTotalAttempts(totalAttempts + 1)
        setCorrectAnswers(correctAnswers + 1)
        
        // Award points based on difficulty
        const currentLine = gameData[currentSectionIndex].lines[currentLineIndex]
        const earnedPoints = currentLine.difficulty * (showHint ? 1 : 2) // Half points if hint was used
        setPoints(points + earnedPoints)
        
        // Move to next line
        handleNextLine()
    }

    // Move to next line
    const handleNextLine = () => {
        const currentSection = gameData[currentSectionIndex]

        // Reset states
        setUserInput('')
        setShowHint(false)
        setShowAnswer(false)

        // Check if we're at the end of all lines in all sections
        if (currentSectionIndex === gameData.length - 1 &&
            currentLineIndex === currentSection.lines.length - 1) {
            setIsComplete(true)
            return
        }

        // Move to next line or section
        if (currentLineIndex < currentSection.lines.length - 1) {
            setCurrentLineIndex(currentLineIndex + 1)
        } else if (currentSectionIndex < gameData.length - 1) {
            setCurrentSectionIndex(currentSectionIndex + 1)
            setCurrentLineIndex(0)
            setStudyMode(true) // Return to study mode when moving to new section
        }

        // Focus the input field
        setTimeout(() => {
            if (inputRef.current) {
                inputRef.current.focus()
            }
        }, 100)
    }

    // Toggle study mode (show all code vs test memory)
    const toggleStudyMode = () => {
        setStudyMode(!studyMode)
    }

    // Adjust difficulty level
    const changeDifficultyLevel = (level) => {
        setDifficultyLevel(level)
    }

    // Progress bar component
    const ProgressBar = ({ progress, width, height = 6, color = '#5c6bc0', backgroundColor = '#e0e0e0' }) => {
        return (
            <View style={{ height, width: width || '100%', backgroundColor, borderRadius: height / 2, overflow: 'hidden' }}>
                <View style={{ height: '100%', width: `${Math.min(100, Math.max(0, progress * 100))}%`, backgroundColor: color, borderRadius: height / 2 }} />
            </View>
        )
    }

    // Handle game completion
    const handleComplete = async () => {
        try {
            let oldScore = parseInt(await SecureStore.getItemAsync("score-" + subInt)) || 0

            // Calculate score based on correct answers
            const accuracy = correctAnswers / totalAttempts
            let pointsToAdd = 0

            for (let i = 0; i < lesson.tools.length; i++) {
                if (lesson.tools[i].name === "py-memory") {
                    pointsToAdd += Math.round(lesson.tools[i].score * accuracy)
                }
            }

            const newScore = oldScore + pointsToAdd
            await SecureStore.setItemAsync('score-' + subInt, newScore.toString())

            Alert.alert(
                "Congratulations!",
                `You've completed the memory challenge!\n\nScore: ${points}\nAccuracy: ${Math.round(accuracy * 100)}%\nPoints Added: +${pointsToAdd}`,
                [{ text: "Continue", onPress: () => router.back() }]
            )
        } catch (error) {
            console.error('Error saving score:', error)
            Alert.alert("Error", "Could not save your score.")
            router.back()
        }
    }

    // Render the code lines for study mode
    const renderStudySection = () => {
        if (!gameData || gameData.length === 0) return null

        const currentSection = gameData[currentSectionIndex]

        return (
            <View className="bg-white rounded-xl p-4 shadow-sm mb-4">
                <View className="flex-row justify-between items-center mb-3">
                    <Text className="text-indigo-700 font-medium">Study Mode</Text>
                    <View className="bg-indigo-100 px-3 py-1 rounded-full">
                        <Text className="text-indigo-700 font-bold">{points} pts</Text>
                    </View>
                </View>

                {/* Section description */}
                <View className="bg-yellow-50 p-3 rounded-lg mb-4">
                    <Text className="text-gray-800 font-medium">{currentSection.description}</Text>
                </View>

                {/* Code display */}
                <View className="bg-gray-900 p-3 rounded-lg mb-4">
                    <ScrollView>
                        {currentSection.lines.map((line, idx) => (
                            <Text key={idx} className="font-mono text-green-500">
                                {line.indentation}{line.code}
                            </Text>
                        ))}
                    </ScrollView>
                </View>

                {/* Controls */}
                <TouchableOpacity
                    onPress={toggleStudyMode}
                    className="bg-indigo-600 py-2 rounded-lg mt-3 items-center"
                >
                    <Text className="text-white font-medium">Start Memory Test</Text>
                </TouchableOpacity>
            </View>
        )
    }

    // Render current memory test line
    const renderMemoryTest = () => {
        if (!gameData || gameData.length === 0) return null

        const currentSection = gameData[currentSectionIndex]
        const currentLine = currentSection.lines[currentLineIndex]
        if (!currentLine) return null

        // Only test lines with appropriate difficulty based on user's selected level
        const shouldTest = currentLine.difficulty <= difficultyLevel
        const isEmptyLine = currentLine.code === ""

        // Previous context (show up to 3 previous lines)
        const previousLines = []
        for (let i = Math.max(0, currentLineIndex - 3); i < currentLineIndex; i++) {
            previousLines.push(currentSection.lines[i])
        }

        return (
            <View className="bg-white rounded-xl p-4 shadow-sm mb-4">
                <View className="flex-row justify-between items-center mb-3">
                    <Text className="text-indigo-700 font-medium">
                        Line {currentLineIndex + 1}/{currentSection.lines.length}
                    </Text>
                    <View className="bg-indigo-100 px-3 py-1 rounded-full">
                        <Text className="text-indigo-700 font-bold">{points} pts</Text>
                    </View>
                </View>

                {/* Previous context */}
                <View className="bg-gray-800 p-3 rounded-t-lg">
                    {previousLines.map((line, idx) => (
                        <Text key={idx} className="font-mono text-gray-400">
                            {line.indentation}{line.code}
                        </Text>
                    ))}
                </View>

                {/* Current line */}
                <View className="bg-gray-900 p-3 rounded-b-lg mb-4">
                    {isEmptyLine ? (
                        <Text className="font-mono text-yellow-500 italic">
                            (This is an empty line, press "Submit" to continue)
                        </Text>
                    ) : shouldTest ? (
                        <View className="flex-row">
                            <Text className="font-mono text-green-500">{currentLine.indentation}</Text>
                            <Text className="font-mono text-red-500">Complete this line...</Text>
                        </View>
                    ) : (
                        <Text className="font-mono text-green-500">
                            {currentLine.indentation}{currentLine.code}
                        </Text>
                    )}
                </View>

                {/* Hint */}
                {currentLine.hint && shouldTest && !isEmptyLine && (
                    <View className="mb-3">
                        <TouchableOpacity 
                            onPress={() => setShowHint(!showHint)}
                            className="flex-row items-center"
                        >
                            <FontAwesome5 name={showHint ? "eye-slash" : "eye"} size={16} color="#4f46e5" />
                            <Text className="text-indigo-600 ml-2 font-medium">
                                {showHint ? "Hide Hint" : "Show Hint"}
                            </Text>
                        </TouchableOpacity>
                        
                        {showHint && (
                            <View className="bg-indigo-50 p-2 mt-2 rounded-lg">
                                <Text className="text-indigo-800">{currentLine.hint}</Text>
                            </View>
                        )}
                    </View>
                )}

                {/* User input */}
                {shouldTest && !isEmptyLine ? (
                    <View className="mb-3">
                        <TextInput
                            ref={inputRef}
                            className="border border-gray-300 rounded-lg p-2 bg-gray-50 font-mono"
                            value={userInput}
                            onChangeText={setUserInput}
                            placeholder="Type the code line here..."
                            autoCapitalize="none"
                            autoCorrect={false}
                        />
                    </View>
                ) : null}

                {/* Show answer */}
                {showAnswer && shouldTest && !isEmptyLine && (
                    <View className="bg-red-50 p-3 rounded-lg mb-3">
                        <Text className="text-red-800 font-bold mb-1">Correct answer:</Text>
                        <Text className="font-mono text-red-700">{currentLine.code}</Text>
                    </View>
                )}

                {/* Controls */}
                <View className="flex-row justify-between mt-2">
                    <TouchableOpacity
                        onPress={toggleStudyMode}
                        className="bg-gray-200 py-2 px-4 rounded-lg"
                    >
                        <Text className="text-gray-800">Return to Study</Text>
                    </TouchableOpacity>

                    {shouldTest ? (
                        <TouchableOpacity
                            onPress={showAnswer ? handleNextLine : checkAnswer}
                            className={`py-2 px-4 rounded-lg ${showAnswer ? "bg-green-600" : "bg-indigo-600"}`}
                        >
                            <Text className="text-white font-medium">
                                {showAnswer ? "Next Line" : "Submit"}
                            </Text>
                        </TouchableOpacity>
                    ) : (
                        <TouchableOpacity
                            onPress={handleNextLine}
                            className="bg-indigo-600 py-2 px-4 rounded-lg"
                        >
                            <Text className="text-white font-medium">Next Line</Text>
                        </TouchableOpacity>
                    )}
                </View>
            </View>
        )
    }

    // Difficulty selector
    const renderDifficultySelector = () => {
        return (
            <View className="bg-white p-3 rounded-lg mb-4 flex-row justify-between">
                <Text className="text-gray-700 font-medium self-center">Difficulty:</Text>
                <View className="flex-row">
                    {[1, 2, 3].map(level => (
                        <TouchableOpacity
                            key={level}
                            onPress={() => changeDifficultyLevel(level)}
                            className={`mx-1 px-3 py-1 rounded ${
                                difficultyLevel === level 
                                    ? 'bg-indigo-600' 
                                    : 'bg-gray-200'
                            }`}
                        >
                            <Text className={`${
                                difficultyLevel === level 
                                    ? 'text-white' 
                                    : 'text-gray-700'
                            }`}>
                                {level === 1 ? 'Easy' : level === 2 ? 'Medium' : 'Hard'}
                            </Text>
                        </TouchableOpacity>
                    ))}
                </View>
            </View>
        )
    }

    // Loading screen
    if (loading) {
        return (
            <SafeAreaView className="flex-1 bg-blue-50">
                <StatusBar barStyle="dark-content" />
                <View className="flex-1 justify-center items-center p-5">
                    <View className="bg-white rounded-2xl p-6 w-full items-center shadow-md">
                        <FontAwesome5 name="brain" size={60} color="#5c6bc0" className="mb-5" />
                        <Text className="text-xl font-bold text-gray-800 mb-3">Preparing Memory Challenge</Text>
                        <Text className="text-base text-gray-600 text-center mb-6">{processStatus}</Text>
                        <ProgressBar progress={processingProgress} height={8} />
                        <View className="flex-row items-center mt-5">
                            <ActivityIndicator size="small" color="#5c6bc0" />
                            <Text className="ml-2 text-indigo-600 font-medium">
                                {Math.round(processingProgress * 100)}% Complete
                            </Text>
                        </View>
                    </View>
                </View>
            </SafeAreaView>
        )
    }

    // Main render
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" />

            {/* Header */}
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                    <Text className="ml-2 text-gray-800">Back</Text>
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800">{lesson.title || 'Python Memory Test'}</Text>
                <View className="flex-row items-center">
                    <TouchableOpacity onPress={handleRegenerate} disabled={loading} className="mr-2">
                        <FontAwesome5 name="sync" size={20} color="#333" />
                    </TouchableOpacity>
                    <View className="bg-green-100 px-2 py-1 rounded-full flex-row items-center">
                        <FontAwesome5 name="star" size={14} color="#4caf50" />
                        <Text className="ml-1 text-green-600 font-bold">{points}</Text>
                    </View>
                </View>
            </View>

            {gameData && gameData.length > 0 && (
                <ReaderSelector
                    sections={gameData}
                    currentSectionIndex={currentSectionIndex}
                    onSelectSection={handleSectionChange}
                    className="mx-4 mt-4"
                />
            )}

            {/* Progress bar */}
            <View className="px-6 my-3">
                <ProgressBar
                    progress={(currentLineIndex + 1) / gameData[currentSectionIndex].lines.length}
                />
            </View>

            {/* Difficulty selector (only show in memory test mode) */}
            {!studyMode && renderDifficultySelector()}

            {/* Main content */}
            <ScrollView className="flex-1 px-4">
                {studyMode ? renderStudySection() : renderMemoryTest()}

                {isComplete && (
                    <View className="bg-white rounded-xl p-5 shadow-sm mb-4">
                        <Text className="text-xl font-bold text-center mb-3">Memory Challenge Complete! 🎉</Text>
                        <View className="bg-indigo-50 p-4 rounded-lg mb-4">
                            <Text className="text-lg text-center mb-2">Your Results</Text>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Total Points:</Text>
                                <Text className="font-bold">{points}</Text>
                            </View>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Correct Lines:</Text>
                                <Text className="font-bold">{correctAnswers}/{totalAttempts}</Text>
                            </View>
                            <View className="flex-row justify-between">
                                <Text className="text-gray-700">Accuracy:</Text>
                                <Text className="font-bold">
                                    {totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0}%
                                </Text>
                            </View>
                        </View>
                        <TouchableOpacity
                            onPress={handleComplete}
                            className="bg-green-600 py-3 rounded-lg items-center"
                        >
                            <Text className="text-white font-bold text-lg">Finish & Save Score</Text>
                        </TouchableOpacity>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    )
}

export default PythonMemoryTest
--- END OF FILE app/tools/py-memory.jsx ---

--- START OF FILE app/tools/py-program.jsx ---
import { View, Text, TouchableOpacity, ScrollView, SafeAreaView, StatusBar, ActivityIndicator, Alert } from 'react-native'
import { Ionicons, FontAwesome5 } from '@expo/vector-icons'
import React, { useState, useEffect } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import * as SecureStore from 'expo-secure-store'
import axios from 'axios'
import { GoogleGenerativeAI } from '@google/generative-ai'
import ReaderSelector from './components/ReaderSelector'

const PythonCodeUnderstanding = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const [loading, setLoading] = useState(true)
    const [gameData, setGameData] = useState(null)
    const [processStatus, setProcessStatus] = useState('Initializing...')
    const [processingProgress, setProcessingProgress] = useState(0)
    const [forceRegenerate, setForceRegenerate] = useState(false)

    // Game state variables
    const [currentSectionIndex, setCurrentSectionIndex] = useState(0)
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0)
    const [selectedAnswer, setSelectedAnswer] = useState(null)
    const [correctAnswers, setCorrectAnswers] = useState(0)
    const [totalAttempts, setTotalAttempts] = useState(0)
    const [points, setPoints] = useState(0)
    const [showResults, setShowResults] = useState(false)
    const [isComplete, setIsComplete] = useState(false)

    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    // Fetch and process data
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true)
                setProcessStatus('Checking cached data...')
                const storageKey = `python-understanding-${subInt}-${index}`
                let storedData = await SecureStore.getItemAsync(storageKey)

                if (storedData && !forceRegenerate) {
                    console.log('Using stored game data')
                    setProcessStatus('Using cached data...')
                    setProcessingProgress(0.9)
                    setGameData(JSON.parse(storedData))
                    setLoading(false)
                    return
                }

                setProcessStatus('Downloading Python code...')
                setProcessingProgress(0.1)
                let codeData;
                if (!lesson.text) {
                    const response = await axios.get(dataUrl)
                    codeData = response.data
                } else {
                    codeData = lesson.text
                }

                setProcessingProgress(0.2)

                const apiKey = await SecureStore.getItemAsync('google-api')
                if (!apiKey) {
                    console.error('Google API key not found in secure storage')
                    setProcessStatus('Error: API key not found, Set API Key in Tools')
                    return
                }

                const processedData = await processPythonCodeForUnderstanding(codeData, apiKey)
                await SecureStore.setItemAsync(storageKey, JSON.stringify(processedData))
                setGameData(processedData)
            } catch (error) {
                console.error('Error fetching data:', error)
                setProcessStatus(`Error: ${error.message}`)
            } finally {
                setForceRegenerate(false)
                setLoading(false)
            }
        }

        fetchData()
    }, [forceRegenerate])

    // Reset indices and game state when gameData changes
    useEffect(() => {
        if (gameData) {
            setCurrentSectionIndex(0)
            setCurrentQuestionIndex(0)
            setSelectedAnswer(null)
            setCorrectAnswers(0)
            setTotalAttempts(0)
            setPoints(0)
            setShowResults(false)
            setIsComplete(false)
        }
    }, [gameData])

    // Process Python code for understanding game
    const processPythonCodeForUnderstanding = async (pythonCode, apiKey) => {
        try {
            setProcessStatus('Analyzing Python code...')
            setProcessingProgress(0.3)
            console.log('Processing Python code for understanding game')

            const genAI = new GoogleGenerativeAI(apiKey)
            const model = genAI.getGenerativeModel({
                model: 'gemini-2.0-flash',
                generationConfig: { temperature: 0.2 }
            })

            const understandingPrompt = `
            Create a Python code understanding quiz from this code. Divide the code into logical sections and create multiple-choice questions to test understanding:
            
            Python Code: ${pythonCode}
            
            Return ONLY a JSON array in this exact format without any additional text:
            [
              {
                "name": "Section name (e.g. 'Functions', 'Classes', 'Main Loop')",
                "code": "Relevant code snippet for this section",
                "questions": [
                  {
                    "question": "A question about the code's functionality, purpose, or behavior?",
                    "options": ["Option A", "Option B", "Option C", "Option D"],
                    "correctAnswer": "Option that is correct",
                    "explanation": "Explanation of why this answer is correct and what the code does"
                  }
                ]
              }
            ]
            
            Guidelines:
            1. Create 3-5 sections based on logical divisions of the code
            2. Each section should have 2-4 questions
            3. Questions should test understanding, not just syntax recognition
            4. Include questions about:
               - What the code does
               - Why certain approaches were used
               - Potential outputs for given inputs
               - Understanding of algorithms or logic used
            5. Make sure options are plausible but only one is correct
            6. Provide clear explanations that help learn from mistakes
            `;

            setProcessStatus('Creating understanding questions...')
            setProcessingProgress(0.5)

            const gameResult = await model.generateContent(understandingPrompt)
            const gameResponse = gameResult.response.text()
            const jsonMatch = gameResponse.match(/\[\s*\{[\s\S]*\}\s*\]/)
            const jsonString = jsonMatch ? jsonMatch[0] : gameResponse
            const gameData = JSON.parse(jsonString)

            console.log('Python understanding game created:', gameData.length, 'sections')
            setProcessingProgress(1)
            return gameData
        } catch (error) {
            console.error('Error creating Python understanding game:', error)
            return [{
                name: "Error Section",
                code: "print('Hello, world!')",
                questions: [{
                    question: "Error processing Python code for understanding game.",
                    options: ["Try again", "Regenerate", "Check API key", "Contact support"],
                    correctAnswer: "Regenerate",
                    explanation: "There was an error processing the Python code. Please try regenerating the content."
                }]
            }]
        }
    }

    // Handle regeneration
    const handleRegenerate = () => {
        Alert.alert(
            "Regenerate Content",
            "This will reset your progress. Regenerate the content?",
            [
                { text: "Cancel", style: "cancel" },
                {
                    text: "Regenerate",
                    onPress: async () => {
                        setLoading(true)
                        setProcessStatus('Regenerating content...')
                        const storageKey = `python-understanding-${subInt}-${index}`
                        await SecureStore.deleteItemAsync(storageKey)
                        setForceRegenerate(true)
                    }
                }
            ]
        )
    }

    const handleSectionChange = (sectionIndex) => {
        setCurrentSectionIndex(sectionIndex)
        setCurrentQuestionIndex(0)
        setSelectedAnswer(null)
        setShowResults(false)
    }

    // Select an answer option
    const handleSelectAnswer = (answer) => {
        setSelectedAnswer(answer)
        setShowResults(true)

        const currentQuestion = gameData[currentSectionIndex].questions[currentQuestionIndex]
        const isCorrect = answer === currentQuestion.correctAnswer
        
        setTotalAttempts(totalAttempts + 1)
        if (isCorrect) {
            setCorrectAnswers(correctAnswers + 1)
            setPoints(points + 10) // 10 points for correct answer
        }
    }

    // Move to next question
    const handleNextQuestion = () => {
        const currentSection = gameData[currentSectionIndex]

        // Check if we're at the end of all questions in all sections
        if (currentSectionIndex === gameData.length - 1 &&
            currentQuestionIndex === currentSection.questions.length - 1) {
            setIsComplete(true)
            return
        }

        // Move to next question or section
        if (currentQuestionIndex < currentSection.questions.length - 1) {
            setCurrentQuestionIndex(currentQuestionIndex + 1)
        } else if (currentSectionIndex < gameData.length - 1) {
            setCurrentSectionIndex(currentSectionIndex + 1)
            setCurrentQuestionIndex(0)
        }

        setSelectedAnswer(null)
        setShowResults(false)
    }

    // Progress bar component
    const ProgressBar = ({ progress, width, height = 6, color = '#5c6bc0', backgroundColor = '#e0e0e0' }) => {
        return (
            <View style={{ height, width: width || '100%', backgroundColor, borderRadius: height / 2, overflow: 'hidden' }}>
                <View style={{ height: '100%', width: `${Math.min(100, Math.max(0, progress * 100))}%`, backgroundColor: color, borderRadius: height / 2 }} />
            </View>
        )
    }

    // Handle game completion
    const handleComplete = async () => {
        try {
            let oldScore = parseInt(await SecureStore.getItemAsync("score-" + subInt)) || 0

            // Calculate score based on correct answers
            const accuracy = correctAnswers / totalAttempts
            let pointsToAdd = 0

            for (let i = 0; i < lesson.tools.length; i++) {
                if (lesson.tools[i].name === "py-program") {
                    pointsToAdd += Math.round(lesson.tools[i].score * accuracy)
                }
            }

            const newScore = oldScore + pointsToAdd
            await SecureStore.setItemAsync('score-' + subInt, newScore.toString())

            Alert.alert(
                "Congratulations!",
                `You've completed the code challenge!\n\nScore: ${points}\nAccuracy: ${Math.round(accuracy * 100)}%\nPoints Added: +${pointsToAdd}`,
                [{ text: "Continue", onPress: () => router.back() }]
            )
        } catch (error) {
            console.error('Error saving score:', error)
            Alert.alert("Error", "Could not save your score.")
            router.back()
        }
    }

    // Render current question
    const renderCurrentQuestion = () => {
        if (!gameData || gameData.length === 0) return null

        const currentSection = gameData[currentSectionIndex]
        const currentQuestion = currentSection.questions[currentQuestionIndex]
        if (!currentQuestion) return null

        return (
            <View className="bg-white rounded-xl p-4 shadow-sm mb-4">
                <View className="flex-row justify-between items-center mb-3">
                    <Text className="text-indigo-700 font-medium">
                        Question {currentQuestionIndex + 1}/{currentSection.questions.length}
                    </Text>
                    <View className="bg-indigo-100 px-3 py-1 rounded-full">
                        <Text className="text-indigo-700 font-bold">{points} pts</Text>
                    </View>
                </View>

                {/* Code snippet */}
                <View className="bg-gray-900 p-3 rounded-lg mb-4">
                    <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                        <Text className="font-mono text-green-500">
                            {currentSection.code}
                        </Text>
                    </ScrollView>
                </View>

                {/* Question */}
                <View className="bg-gray-50 p-3 rounded-lg mb-4">
                    <Text className="text-lg font-medium mb-3">{currentQuestion.question}</Text>
                    
                    {/* Answer options */}
                    <View className="space-y-2">
                        {currentQuestion.options.map((option, index) => (
                            <TouchableOpacity
                                key={index}
                                onPress={() => !showResults && handleSelectAnswer(option)}
                                className={`p-3 rounded-lg border ${
                                    showResults && option === currentQuestion.correctAnswer
                                        ? 'bg-green-100 border-green-500'
                                        : showResults && option === selectedAnswer && option !== currentQuestion.correctAnswer
                                        ? 'bg-red-100 border-red-500'
                                        : selectedAnswer === option
                                        ? 'bg-indigo-100 border-indigo-500'
                                        : 'border-gray-300'
                                }`}
                                disabled={showResults}
                            >
                                <Text className={`${
                                    showResults && option === currentQuestion.correctAnswer
                                        ? 'text-green-700'
                                        : showResults && option === selectedAnswer && option !== currentQuestion.correctAnswer
                                        ? 'text-red-700'
                                        : selectedAnswer === option
                                        ? 'text-indigo-700'
                                        : 'text-gray-700'
                                }`}>
                                    {option}
                                </Text>
                            </TouchableOpacity>
                        ))}
                    </View>
                </View>

                {/* Results feedback */}
                {showResults && (
                    <View className="bg-gray-50 p-3 rounded-lg mb-3">
                        <Text className="text-lg font-bold mb-2">
                            {selectedAnswer === currentQuestion.correctAnswer 
                                ? "Correct! 🎉" 
                                : "Not quite right 🤔"
                            }
                        </Text>
                        <Text className="text-gray-700 mb-3">{currentQuestion.explanation}</Text>
                        <TouchableOpacity
                            onPress={handleNextQuestion}
                            className="bg-indigo-600 py-2 px-4 rounded-lg mt-2 items-center"
                        >
                            <Text className="text-white font-medium">
                                {isComplete ? "See Results" : "Next Question"}
                            </Text>
                        </TouchableOpacity>
                    </View>
                )}
            </View>
        )
    }

    // Loading screen
    if (loading) {
        return (
            <SafeAreaView className="flex-1 bg-blue-50">
                <StatusBar barStyle="dark-content" />
                <View className="flex-1 justify-center items-center p-5">
                    <View className="bg-white rounded-2xl p-6 w-full items-center shadow-md">
                        <FontAwesome5 name="python" size={60} color="#5c6bc0" className="mb-5" />
                        <Text className="text-xl font-bold text-gray-800 mb-3">Analyzing Python Code</Text>
                        <Text className="text-base text-gray-600 text-center mb-6">{processStatus}</Text>
                        <ProgressBar progress={processingProgress} height={8} />
                        <View className="flex-row items-center mt-5">
                            <ActivityIndicator size="small" color="#5c6bc0" />
                            <Text className="ml-2 text-indigo-600 font-medium">
                                {Math.round(processingProgress * 100)}% Complete
                            </Text>
                        </View>
                    </View>
                </View>
            </SafeAreaView>
        )
    }

    // Main render
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" />

            {/* Header */}
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                    <Text className="ml-2 text-gray-800">Back</Text>
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800">{lesson.title || 'Python Understanding'}</Text>
                <View className="flex-row items-center">
                    <TouchableOpacity onPress={handleRegenerate} disabled={loading} className="mr-2">
                        <FontAwesome5 name="sync" size={20} color="#333" />
                    </TouchableOpacity>
                    <View className="bg-green-100 px-2 py-1 rounded-full flex-row items-center">
                        <FontAwesome5 name="star" size={14} color="#4caf50" />
                        <Text className="ml-1 text-green-600 font-bold">{points}</Text>
                    </View>
                </View>
            </View>

            {gameData && gameData.length > 0 && (
                <ReaderSelector
                    sections={gameData}
                    currentSectionIndex={currentSectionIndex}
                    onSelectSection={handleSectionChange}
                    className="mx-4 mt-4"
                />
            )}

            {/* Progress bar */}
            <View className="px-6 my-3">
                <ProgressBar
                    progress={(currentQuestionIndex + 1) / gameData[currentSectionIndex].questions.length}
                />
            </View>

            {/* Main content */}
            <ScrollView className="flex-1 px-4">
                {renderCurrentQuestion()}

                {isComplete && (
                    <View className="bg-white rounded-xl p-5 shadow-sm mb-4">
                        <Text className="text-xl font-bold text-center mb-3">Challenge Complete! 🎉</Text>
                        <View className="bg-indigo-50 p-4 rounded-lg mb-4">
                            <Text className="text-lg text-center mb-2">Your Results</Text>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Total Points:</Text>
                                <Text className="font-bold">{points}</Text>
                            </View>
                            <View className="flex-row justify-between mb-2">
                                <Text className="text-gray-700">Correct Answers:</Text>
                                <Text className="font-bold">{correctAnswers}/{totalAttempts}</Text>
                            </View>
                            <View className="flex-row justify-between">
                                <Text className="text-gray-700">Accuracy:</Text>
                                <Text className="font-bold">
                                    {totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0}%
                                </Text>
                            </View>
                        </View>
                        <TouchableOpacity
                            onPress={handleComplete}
                            className="bg-green-600 py-3 rounded-lg items-center"
                        >
                            <Text className="text-white font-bold text-lg">Finish & Save Score</Text>
                        </TouchableOpacity>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    )
}

export default PythonCodeUnderstanding
--- END OF FILE app/tools/py-program.jsx ---

--- START OF FILE app/tools/template.jsx ---
import { View, Text, TouchableOpacity,SafeAreaView, StatusBar} from 'react-native'
import { Ionicons } from '@expo/vector-icons'
import React, { useEffect, useState } from 'react'
import { useLocalSearchParams, useRouter } from 'expo-router'
import { getItemAsync, setItemAsync } from 'expo-secure-store'

const Template = () => {
    const { exp } = useLocalSearchParams()
    const router = useRouter()
    const { subject, index, subInt, lesson } = JSON.parse(exp)
    const dataUrl = lesson.data

    const toolName = 'template'
    const tool = lesson.tools.filter((t,i)=>t.name == toolName)[0]

    const [score, setScore] = useState(0)

    useEffect(()=>{
        const loadScore = async ()=>{
            let storedScore = await getItemAsync('score-'+subInt)
            if(storedScore) setScore(storedScore)
            else await setItemAsync("score-"+subInt,score+"")
            console.log(storedScore)
            }

        loadScore()
    },[])

    const [accuracy, setAccuracy] = useState(0)

    const gameOver = async ()=>{
        let addScore = accuracy*tool.score
        setScore(score + addScore)
        await setItemAsync("score-"+subInt,score+"")
    }

    
    return (
        <SafeAreaView className="flex-1 bg-gray-50">
            <StatusBar barStyle="dark-content" backgroundColor="#fff"/>
            <View className="flex-row justify-between items-center p-4 border-b border-gray-200 bg-white">
                <TouchableOpacity onPress={() => router.back()} className="flex-row items-center">
                    <Ionicons name="arrow-back" size={24} color="#333" />
                </TouchableOpacity>
                <Text className="text-xl font-bold text-gray-800 mr-auto ml-auto">{tool.label}</Text>
            </View>
        </SafeAreaView>
    )
}

export default Template
--- END OF FILE app/tools/template.jsx ---

--- START OF FILE app/tools/components/ReaderSelector.js ---
import { View, Text, TouchableOpacity, ScrollView } from 'react-native'
import React from 'react'
import { FontAwesome5 } from '@expo/vector-icons'

const ReaderSelector = ({ sections, currentSectionIndex, onSelectSection, className }) => {
  if (!sections || sections.length === 0) return null
  
  return (
    <View className={`bg-white rounded-lg shadow mb-2 ${className}`}>
      <Text className="text-lg font-bold text-gray-800 px-4 pt-4 pb-2">
        Select Section
      </Text>
      
      <ScrollView horizontal showsHorizontalScrollIndicator={false} className="pb-4">
        {sections.map((section, index) => (
          <TouchableOpacity
            key={index}
            onPress={() => onSelectSection(index)}
            className={`mx-2 px-4 py-2 rounded-full ${
              index === currentSectionIndex 
                ? 'bg-indigo-600' 
                : 'bg-gray-100'
            }`}
          >
            <View className="flex-row items-center">
              <FontAwesome5 
                name="bookmark" 
                size={14} 
                color={index === currentSectionIndex ? '#ffffff' : '#4b5563'} 
              />
              <Text 
                className={`ml-2 ${
                  index === currentSectionIndex 
                    ? 'text-white font-medium' 
                    : 'text-gray-600'
                }`}
                numberOfLines={1}
              >
                {section.name}
              </Text>
            </View>
          </TouchableOpacity>
        ))}
      </ScrollView>
    </View>
  )
}

export default ReaderSelector
--- END OF FILE app/tools/components/ReaderSelector.js ---

--- START OF FILE app/webview/[...path].js ---
import React from 'react';
import { View, Text, Platform } from 'react-native';
import { WebView } from 'react-native-webview';
import { useLocalSearchParams } from 'expo-router';
import Constants from 'expo-constants';
import { SafeAreaView } from 'react-native-safe-area-context';

const WebViewComponent = () => {
    const { path } = useLocalSearchParams();
    const fullPath = Array.isArray(path) ? path.join('/') : path;

    // Check if running in Expo Go
    const isExpoGo = Constants.appOwnership === 'expo';

    // Use different base paths based on environment
    const basePath = 'https://ihjas-ahammed.github.io/';

    // Construct the final URI
    const assetPath = `${basePath}${fullPath}`

    /*'.markdown-body {
                max-width: 100%;
                padding: 30px;
                background: rgb(0, 0, 0);
                color:#fff;
                border-radius: 10px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            }'*/
    // Custom CSS to inject
    const customStyles = `
    document.querySelectorAll('.markdown-body').forEach(element => {
      element.style.background = 'rgb(255,255,255)';
      element.style.color = 'rgb(0,0,0)';
    });
  `;

    const resourceCacheScript = `
    (function() {
      // Function to fetch and cache a resource
      function cacheResource(url) {
        if (!url || url.startsWith('data:') || url.startsWith('blob:')) return Promise.resolve();
        const cacheKey = 'cached_' + btoa(url);
        if (localStorage.getItem(cacheKey)) return Promise.resolve();

        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.onload = () => {
            if (xhr.status === 200) {
              try {
                localStorage.setItem(cacheKey, xhr.responseText);
                console.log('Cached: ' + url);
                resolve();
              } catch (e) {
                console.log('localStorage error for ' + url + ': ' + e.message);
                resolve(); // Continue even if storage fails
              }
            } else {
              console.log('Failed to load ' + url + ': ' + xhr.status);
              reject();
            }
          };
          xhr.onerror = () => {
            console.log('Network error for ' + url);
            reject();
          };
          xhr.send();
        });
      }

      // Collect all resources from the page
      function collectResources() {
        const resources = new Set();
        
        // Scripts
        document.querySelectorAll('script[src]').forEach(script => {
          resources.add(script.src);
        });
        
        // Stylesheets
        document.querySelectorAll('link[rel="stylesheet"][href]').forEach(link => {
          resources.add(link.href);
        });
        
        // Images (optional, if you want to cache them)
        document.querySelectorAll('img[src]').forEach(img => {
          resources.add(img.src);
        });

        return Array.from(resources);
      }

      // Monitor dynamically added resources
      const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          if (mutation.addedNodes.length) {
            collectResources().forEach(url => cacheResource(url).catch(() => {}));
          }
        });
      });
      observer.observe(document.documentElement, { childList: true, subtree: true });

      // Initial caching on load
      window.addEventListener('load', () => {
        const resources = collectResources();
        resources.forEach(url => cacheResource(url).catch(() => {}));
      });

      // Re-inject cached resources offline
      window.addEventListener('load', () => {
        const resources = collectResources();
        resources.forEach(url => {
          const cacheKey = 'cached_' + btoa(url);
          const cachedContent = localStorage.getItem(cacheKey);
          if (cachedContent) {
            if (url.endsWith('.js') || url.includes('.js?')) {
              const script = document.createElement('script');
              script.text = cachedContent;
              document.body.appendChild(script);
            } else if (url.endsWith('.css') || url.includes('.css?')) {
              const style = document.createElement('style');
              style.textContent = cachedContent;
              document.head.appendChild(style);
            }
          }
        });
      });
    })();
  `;
    console.log('Running in Expo Go:', isExpoGo);
    console.log('Route params:', path);
    console.log('Full path:', fullPath);
    console.log('Asset URI:', assetPath);

    return (
        <SafeAreaView className="flex-1 bg-black">
            <WebView
                source={{ uri: assetPath }}
                style={{ flex: 1 }}
                originWhitelist={['*']}
                allowFileAccess={true}
                allowUniversalAccessFromFileURLs={Platform.OS === 'android' && !isExpoGo}
                allowFileAccessFromFileURLs={Platform.OS === 'android' && !isExpoGo}
                cacheEnabled={true} // Enable caching
                cacheMode={Platform.OS === 'android' ? 'LOAD_CACHE_ELSE_NETWORK' : undefined} // Cache first, then network
                domStorageEnabled={true} // For localStorage
                javaScriptEnabled={true} // Required for scripts
                mixedContentMode={'always'} // Allow mixed content
                injectedJavaScript={`${customStyles}; ${resourceCacheScript}`} // Inject styles and caching logic
                onError={(syntheticEvent) => {
                    const { nativeEvent } = syntheticEvent;
                    console.warn('WebView error:', nativeEvent);
                }}
                onLoad={() => console.log('WebView loaded:', assetPath)}
                renderError={(errorName) => (
                    <View className="flex-1 justify-center items-center bg-black">
                        <Text className="text-red-500 text-lg font-bold">Error: {errorName}</Text>
                        <Text className="text-gray-300 mt-2">Path: {fullPath}</Text>
                        <Text className="text-gray-300 mt-2">Using: {isExpoGo ? 'GitHub' : 'Android Assets'}</Text>
                    </View>
                )}
            />
        </SafeAreaView>
    );
};

export default WebViewComponent;
--- END OF FILE app/webview/[...path].js ---
